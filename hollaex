#!/bin/bash 

SCRIPTPATH="$HOME/.hollaex-cli"

#### HollaEx CLI Settings ####

RUN_WITH_VERIFY=true 

LOCAL_DEPLOYMENT_MODE='all'

GENERATE_PASSWORDS=false

DOCKER_COMPOSE_NAME_PREFIX='local'

ENVIRONMENT_BRIDGE_TARGET_SERVER='api.bitholla.com'

source $SCRIPTPATH/version_range

err_msg() { echo "$@" ;} >&2
err_msg_a() { err_msg "-a option argument required" ;}
err_msg_l() { err_msg "--long option argument required" ;}

function print_usage() {
/bin/cat << EOF

Usage : 
    hollaex [ dev ] [ setup ] [ start ] [ restart ] [ stop ] [ build ] [ upgrade ] [ terminate ] [ web ] [ toolbox ] [ cloud ] [ status ] [ logs ] [ version ] (--flags)

General Flags (Except for 'hollaex init', 'hollaex import'):
    --path, Manually pointing HollaEx Kit path. Should be always absolute path.
    --kube, Set HollaEx CLI to target Kubernetes. Make sure to setup your local kubectl before using it.
    --skip, Run command without user's double confirmation.

Options:
    init: Pull HollaEx Kit for your new exchange.

    setup: Setup the exchange for the first launch.
        --arch, Specify a CPU arch to run the HollaEx. Default is amd64. 
    
    import: Import settings files generated by using bitHolla Dashboard (dash.bitholla.com).
        --path, Path of file or directory where settings files are stored.
        --with_aws_s3 <BUCKET_NAME>, Import settings files from the remote AWS S3 bucket.

    export: Export settings files to the target location.
        --path, Path of the directory to export settings files.
        --with_aws_s3 <BUCKET_NAME>, Export settings files to the remote AWS S3 bucket.
    
    login: Log in with bitHolla Dashboard account and select my Activation code. 

    logout: Log out and remove my bound Activation code on local.

    pull: Pull my Exchange configurations from bitHolla Dashboard to local.

    start: Start the exchange which already been configured by 'hollaex setup' command.
        --tag, Tag name of the new image to apply.
        --ignore_settings, Ignore local settings files changes and not applying it on the server.

    prod: Bring up the exchange as production. Including public domain setup and SSL configuraiton.

    restart: Restart the existing exchange.
        --tag, Tag name of the new image to apply.
        --ignore_settings, Ignore local settings files changes and not applying it on the server.
    
    stop: Stop the exchagne which already been running.

    build: Build the Docker image for running HollaEx Kit, includes user custom configurations.
        --version, Specify base HollaEx Core version for build.
        --arch, Specify a CPU arch to run the HollaEx. Default is amd64. 
    
    upgrade: Upgrade the exchange to new version.
        --version, Version number of HollaEx Core to upgrade.
        --user_image_registry, Specify Docker registry and version (tag) for the user HollaEx Core image.
        --ignore_compatibility_check, Ignore Kit and Core compatibility check before an upgrade.
        --ignore_settings, Ignore local settings files changes and not applying it on the server.
        --api_only, Rolling Upgrade API Pods only for Kubernetes.
        --plugins_only, Rolling Upgrade Plugins Pods only for Kubernetes.
        --arch, Specify a CPU arch to run the HollaEx. Default is amd64. 

    terminate: Terminate the existing exchange. THIS COMMAND WILL COMPLETELY REMOVE YOUR EXCHANGE AND CAN'T BE UNDO.
      
    web: Run web server for the exchange.
        --setup, Setup the web server for the first launch.
        --start, Start the web server 
        --stop, Stop the web server.
        --restart, Restart the web server while applying new changes (If it's available).
        --build, Build the web server docker image. This command would not affect the existing web server before restart.
        --terminate, Terminate the web server. THIS COMMAND WILL COMPLETELY REMOVE YOUR WEB CLIENT AND CAN'T BE UNDO.
        --arch, Specify a CPU arch to run the HollaEx. Default is amd64. 

    toolbox: Toolbox for advanced features which could be helpful for your exchange operations.
        --backup, Run the full backup with 'pg_dumpall' for exchange's PostgreSQL database.
        --set_backup_cronjob, Set the Kubernetes Cronjob for periodical database backup.
        --flush_redis, Run the full flush of Redis stored data.
        --add_coin, Add new currency on exchange.
        --remove_coin, Remove exisiting currency from exhcnage.
        --add_trading_pair, Add new trading pair on ehchange.
        --remove_trading_pair, Remove existing trading pair from exchange.
        --issue_ssl, Issue SSL certificate on local Nginx by using Let's Encrypt.
        --renew_ssl, Renew SSL certificate on local Nginx by using Let's Encrypt.
        --update_registry_secret, Update existing docker registry secret for Kubernetes.
        --set_config, Update constants configured on the exchange database.
        --set_security, Override security values at admin panel for the exchange.
        --set_activation_code, Set or update activation code for the exchange.
        --connect_database, Direct connection to PostgreSQL Database via postgresql-client.
        --connect_redis, Direct connection to Redis via redis-client.
        --connect_influxdb, Direct connection to InfluxDB via influx-client.
        --install_cli, Install specific version of HollaEx CLI.
        --influxdb_migration, Migrate InfluxDB data to a new InfluxDB.

    cloud: Operate the exchange running on the HollaCloud.
        --start, Start the stopped exchange exists on the HollaCloud. 
        --stop, Stop the running exchange on the HollaCloud.
        --restart, Restart the running exchange on the HollaCloud.
        --upgrade, Upgrade the running exchange on the HollaCloud with the latest version of HollaEx Kit.
        --terminate, Terminate the existing exchange on the HollaCloud. THIS COMMAND WILL COMPLETELY REMOVE YOUR EXCHANGE AND CAN'T BE UNDO.

    status: Show the exchange server status.

    logs: Show overview of logs from the exchange server. 

    version: Print out current installed version of HollaEx CLI.

EOF
}

function dev_print_usage() {
/bin/cat << EOF

# All 'hollaex dev' commands should be run at HollaEx Core directory.

Usage : 
    hollaex [ dev ] (--flags)

General Flags :
    --core-path, Manually pointing HollaEx Core path. Should be always an absolute path.
    --skip, Run command without user's double confirmation.

Options:
    --command: Run Docker-Compose commands. (up, down, stop, --build)

    --database_init: Run database initialization scripts.

    --add_coin: Add coin(s) on dev HollaEx environment.
    
    --remove_coin: Remove coin(s) on dev HollaEx environment.
    
    --add_trading_pair: Add trading pair(s) on dev HollaEx environment.

    --remove_trading_pair: Remove trading pair(s) on dev HollaEx environment.

EOF
}

if [[ "$1" == "dev" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --command)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_DEV_MANUAL_COMMAND=true
                LOCAL_COMMAND=$1
                echo "Your docker-compose command : $LOCAL_COMMAND."
                shift; continue
                ;;
            --setup)
                shift 
                HOLLAEX_DEV_SETUP=true
                shift; continue
                ;;
            --start)
                shift 
                LOCAL_COMMAND="start"
                echo "Your docker-compose command : $LOCAL_COMMAND."
                shift; continue
                ;;
            --stop)
                shift 
                LOCAL_COMMAND="stop"
                echo "Your docker-compose command : $LOCAL_COMMAND."
                shift; continue
                ;;
            --restart)
                shift 
                HOLLAEX_DEV_RESTART=true
                shift; continue
                ;;
            --terminate)
                shift 
                LOCAL_COMMAND="down --remove-orphans"
                echo "Your docker-compose command : $LOCAL_COMMAND."
                shift; continue
                ;;
            --database_init)
                LOCAL_DATABASE_INIT=true
                echo 'Local database initialization enabled.'
                shift; continue
                ;;
            --test)
                LOCAL_CODE_TEST=true
                echo 'Local mocha code test mode enabled.'
                shift; continue
                ;;
            --core-path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_DEV_FOR_CORE=true
                HOLLAEX_CORE_PATH=$1
                echo "Enabling HollaEx Core development mode."
                echo "HollaEx Core Path : $HOLLAEX_CORE_PATH."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo 'Skipping the command confirmation.'
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                dev_print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    IS_DEVELOP=true

    HOLLAEX_CLI_INIT_PATH=$(pwd)
    CONFIG_FILE_PATH=$(pwd)/settings/*
    TEMPLATE_GENERATE_PATH=$(pwd)/templates
    INIT_PATH_CHECK=$(pwd)/.hollaex

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh

    # #Quit if necessary flags are missing
    # if [[ ! "$LOCAL_DATABASE_INIT" ]] && [[ ! "$LOCAL_COMMAND" ]]; then
    #     echo "*********************************************"
    #     echo "Make sure to specify run mode for dev commands"
    #     echo "*********************************************"
    #     print_usage;
    #     exit 1;
    # fi

    # Checking docker-compose is installed on this machine.
    if command docker-compose version > /dev/null 2>&1; then
        echo "*********************************************"
        echo "docker-compose detected"
        echo "version: $(docker-compose version)"
        echo "*********************************************"

    else
        echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
        exit 1;

    fi

    if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
        mkdir $TEMPLATE_GENERATE_PATH/local;
    fi

    if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
        mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
    fi

    if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
        mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
    fi
    
    # Running database jobs for local db.
    if [[ ! "$LOCAL_COMMAND" ]] && [[ "$LOCAL_DATABASE_INIT" == true ]]; then
    
        local_database_init start;

        docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml restart

        exit 0;

    fi

    if [[ "$HOLLAEX_DEV_SETUP" ]]; then

        # Randomly generates backend passwords
        if [[ ! "$HOLLAEX_SECRET_REDIS_PASSWORD" ]] || [[ ! "$HOLLAEX_SECRET_PUBSUB_PASSWORD" ]] || [[ ! "$HOLLAEX_SECRET_DB_PASSWORD" ]] || [[ ! "$HOLLAEX_SECRET_INFLUX_PASSWORD" ]]; then
        
            generate_backend_passwords;

        fi

    fi

    #Generating random values for passwords and update config file to contain it;
    update_random_values_to_config;

    if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE" == true ]]; then

        load_config_variables;

        generate_local_env;

    fi

    if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then
    
        if [[ "$HOLLAEX_DEV_FOR_CORE" ]]; then
            
            generate_local_docker_compose_for_core_dev;

        else    

            generate_local_docker_compose_for_dev;

        fi

    fi

    generate_nginx_upstream;

    if [[ "$HOLLAEX_DEV_SETUP" ]]; then

        if [[ "$HOLLAEX_DEV_FOR_CORE" ]] ; then 

            function build_hollaex_core_for_dev() {
                
                local BUILD_HOLLAEX_CORE_VERSION=$(grep version $HOLLAEX_CORE_PATH/package.json | cut -c 15- | rev | cut -c 3- | rev)
                local BUILD_HOLLAEX_CORE_BRANCH=$(git --git-dir $HOLLAEX_CORE_PATH/.git rev-parse --abbrev-ref HEAD)
                local BUILD_HOLLAEX_CORE_DATE="$(echo $(date +%y%m%d%H%M))"

                local BUILD_HOLLAEX_CORE_IMAGE_TAG=${BUILD_HOLLAEX_CORE_VERSION}-${BUILD_HOLLAEX_CORE_BRANCH}-${BUILD_HOLLAEX_CORE_DATE}
                export ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE=$BUILD_HOLLAEX_CORE_IMAGE_TAG

                docker build -t bitholla/hollaex-core:$BUILD_HOLLAEX_CORE_IMAGE_TAG -f $HOLLAEX_CORE_PATH/tools/Dockerfile.pm2 $HOLLAEX_CORE_PATH

            }

            build_hollaex_core_for_dev;
            override_docker_image_version;

        else 

            export ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE=$HOLLAEX_CORE_MAXIMUM_COMPATIBLE
            override_docker_image_version;
        
        fi

        export ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION=$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE

        build_user_hollaex_core;

        # Regenerating docker compose file with the new image tag just defined above.
         if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then
    
            if [[ "$HOLLAEX_DEV_FOR_CORE" ]]; then
                
                generate_local_docker_compose_for_core_dev;

            else    

                generate_local_docker_compose_for_dev;

            fi

        fi

        docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml up -d  
        
        echo "Installing npm packages for /plugins"
        docker exec ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server-plugins-controller_1 bash -c '
            cd /app/plugins && \
            npm install --loglevel=error && \
            for d in ./*/ ; do (cd "$d" && npm install --loglevel=error); done'
        
        # echo "Installing npm packages for /mail"
        #     docker exec ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server-api_1 bash -c '
                # cd /app/mail && npm install --loglevel=error'

        hollaex dev --database_init
    
        docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml restart

        hollaex_setup_finalization;

        docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml restart
        
        
    elif [[ "$HOLLAEX_DEV_RESTART" ]]; then

        docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml stop
        docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml up -d

        if [[ ! "$HOLLAEX_DEV_SETUP" ]]; then

            echo "Installing npm packages for /plugins"
            docker exec ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server-plugins-controller_1 bash -c '
                cd /app/plugins && \
                npm install --loglevel=error && \
                for d in ./*/ ; do (cd "$d" && npm install --loglevel=error); done'

            # echo "Installing npm packages for /mail"
            # docker exec ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server-api_1 bash -c '
            #     cd /app/mail && npm install --loglevel=error'

        fi 

    else 

        docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml $LOCAL_COMMAND

    fi


    exit 0;


elif [[ "$1" == "init" ]]; then
    
    # while true; do
    #     [[ $# -eq 0 ]] && break
    #     case $1 in
    #         # --name)
    #         #     shift 
    #         #     case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
    #         #     ENVIRONMENT_EXCHANGE_NAME=$1
    #         #     echo "Name of your Exchange : $ENVIRONMENT_EXCHANGE_NAME."
    #         #     shift; continue
    #         #     ;;
    #         --standalone)
    #             shift 
    #             HOLLAEX_INIT_STANDALONE=true
    #             echo "HollaEx CLI will proceed to generate initialized directory without pulling HollaEx Kit repo."
    #             shift; continue
    #             ;;
    #     esac
    #     shift
    # done

    # #Quit if name of exchange is missing
    # if [[ ! "$ENVIRONMENT_EXCHANGE_NAME" ]]; then

    #     echo "You must specify the name of your Exchange! Use `--name` flag to pass name."
    #     print_usage;
    #     exit 1;

    # fi

    # if [[ ! "$HOLLAEX_INIT_STANDALONE" ]]; then

        echo "Pulling remote HollaEx Kit repo on $(pwd)"
        if command git clone https://github.com/bitholla/hollaex-kit.git; then
            
            HOLLAEX_CLI_INIT_PATH=$(pwd)/hollaex-kit
            CONFIG_FILE_PATH=$(pwd)/hollaex-kit/settings/*
            TEMPLATE_GENERATE_PATH=$(pwd)/hollaex-kit/templates
            INIT_PATH_CHECK=$(pwd)/hollaex-kit/.hollaex

            echo "HollaEx Kit is successfully initialized."
            echo "You can go to: $(pwd)/hollaex-kit and start setting up your exchange with 'hollaex setup' command."
            

        else 

            printf "\033[91mFailed to pull HollaEx Kit repository from GitHub. Please check your internet connectivity.\033[39m\n"
            exit 1;

        fi

    # else 

    #     HOLLAEX_CLI_INIT_PATH=$(pwd)/$ENVIRONMENT_EXCHANGE_NAME

    #     if [[ -d "$HOLLAEX_CLI_INIT_PATH" ]]; then

    #         echo "Init path exists! HollaEx CLI can't override exsiting exchange files."
    #         exit 1;
    #     fi

    #     echo "Initializing new Exchange - $HOLLAEX_CONFIGMAP_API_NAME on $HOLLAEX_CLI_INIT_PATH ..."

    #     mkdir $HOLLAEX_CLI_INIT_PATH

    #     cp -r $SCRIPTPATH/settings $HOLLAEX_CLI_INIT_PATH/settings
    #     cp -r $SCRIPTPATH/plugins $HOLLAEX_CLI_INIT_PATH/plugins
    #     cp -r $SCRIPTPATH/templates $HOLLAEX_CLI_INIT_PATH/templates
    #     touch $HOLLAEX_CLI_INIT_PATH/.hollaex
    #     echo "Initialized by using HollaEx CLI v$(cat $SCRIPTPATH/version)" >> $HOLLAEX_CLI_INIT_PATH/.hollaex

    #     # grep -v ENVIRONMENT_EXCHANGE_NAME= $HOLLAEX_CLI_INIT_PATH/settings/configmap > temp.init && mv temp.init $HOLLAEX_CLI_INIT_PATH/settings/configmap

    #     # (echo "ENVIRONMENT_EXCHANGE_NAME=$ENVIRONMENT_EXCHANGE_NAME" && cat $HOLLAEX_CLI_INIT_PATH/settings/configmap) > temp.init && mv temp.init $HOLLAEX_CLI_INIT_PATH/settings/configmap

    #     echo "All done!"
    #     echo "To run HollaEx CLI commands further, Please get into initialized path first to let HollaEx CLI reads settings."

    # fi
        
        exit 0;
    
elif [[ "$1" == "setup" ]]; then
    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --user_image_registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                export ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE=$1
                echo "Target hollaex docker registry : $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --arch)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                if [[ "$1" == "amd64" ]] || [[ "$1" == "arm64v8" ]] || [[ "$1" == "s390x" ]]; then
                    export ENVIORNMENT_HOLLAEX_CPU_ARCH=$1
                    echo "Target CPU Arch: $ENVIORNMENT_HOLLAEX_CPU_ARCH."
                else 
                    echo -e "\n\033[91mError: Not supported CPU arch!\033[39m"
                    echo "Supported Arches: amd64, arm64v8, s390x."
                    echo -e "Please try it again with the supported arch name.\n"
                    exit 1;
                fi
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    echo "Setting the Kit /settings folder as 'assumed-unchanged' state."
    git --git-dir=$HOLLAEX_CLI_INIT_PATH/.git update-index --assume-unchanged ./settings/*

    source $SCRIPTPATH/tools_generator.sh

    system_dependencies_check;

    check_docker_daemon_status;

    if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]]; then 

        # Check Kit version compatibility range.
        check_kit_version_compatibility_range;
    
    fi 

    #Generating random values for passwords and update config file to contain it;
    update_random_values_to_config;

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_CONFIGMAP_API_NAME=" $i > /dev/null ; then

            export CONFIGMAP_FILE_PATH=$i

        fi

    done

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

            export SECRET_FILE_PATH=$i

        fi

    done

     # Randomly generates backend passwords
    if [[ ! "$HOLLAEX_SECRET_REDIS_PASSWORD" ]] || [[ ! "$HOLLAEX_SECRET_PUBSUB_PASSWORD" ]] || [[ ! "$HOLLAEX_SECRET_DB_PASSWORD" ]] || [[ ! "$HOLLAEX_SECRET_INFLUX_PASSWORD" ]]; then
    
        generate_backend_passwords;

    fi

    # hollaex setup --reconfigure
    if [[ "$RECONFIGURE_BASIC_SETTINGS" ]]; then

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to reconfigure the exchange? (Y/n)"

            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        # Ask for basic necessary settings
        launch_basic_settings_input;

        #hollaex upgrade --skip $(if [[ "$USE_KUBERNETES" ]]; then echo "--kube"; fi)

        echo "All done!"
        echo "Make sure to check your settings files been successfully updated by following your provided values."
        echo "You can run 'hollaex restart (--kube)' for applying the updated values on your exchange."

        exit 0;

    fi

    # PRESET env for user initial setup config value selection
    CONTINUE_WITH_PRECONFIGURED_VALUES=false 
    
    if [[ "$RUN_WITH_VERIFY" == true ]]; then 

        # Check that settings files are already configured.
        if [[ ! "$HOLLAEX_CONFIGMAP_API_NAME" == "my-hollaex-exchange" ]] && [[ $HOLLAEX_SECRET_ACTIVATION_CODE ]]; then

            echo "HollaEx CLI detected the preconfigured values on your HollaEx Kit."
            echo "Do you want to proceed with these preconfigured values? (Y/n)"
            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
                
                export CONTINUE_WITH_PRECONFIGURED_VALUES=false
            
            else 

                export CONTINUE_WITH_PRECONFIGURED_VALUES=true

            fi

        fi
    
    else 

        echo "Proceeding with the preconfigured values..."
        export CONTINUE_WITH_PRECONFIGURED_VALUES=true

    fi

    if [[ "$CONTINUE_WITH_PRECONFIGURED_VALUES" == false ]]; then

        printf "\nWelcome to HollaEx Setup!\n\n"

        echo -e "You need to \033[1msetup your exchange\033[0m with the configurations."
        echo -e "You can follow the \033[1mexchange setup wizard\033[0m on \033[1mhttps://dash.bitholla.com\033[0m before you do this process. (Recommended)"
        echo -e "\033[1mHave you already setup your exchange on bitHolla Dashboard? (Y/n)\033[0m"
        read answer

        if [[ ! "$answer" = "${answer#[Nn]}" ]]; then

            printf "\nWe recommend you to setup your exchange on \033[1mbitHolla dashboard (dash.bitholla.com)\033[0m before you proceed.\n"
            printf "Select \033[1m'Y'\033[0m to \033[1mquit the CLI\033[0m in order to first setup your exchange on the dashboard,\n" 
            printf "Select \033[1m'N'\033[0m to proceed \033[1mmanual\033[0m CLI exchange setup wizard.\n" 
            echo "Do you want to quit the CLI setup? (Y/n)"
            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
                
                echo "Proceeding to a CLI exchange wizard..."
                launch_basic_settings_input;
            
            else 

                printf "\n\nPlease visit \033[1mdash.bitholla.com\033[0m and setup your exchange there first.\n"
                printf "Once your exchange is configured on the dashboard, please start the procedure by using \033[1m'hollaex setup'\033[0m.\n\n"
                exit 1;
            
            fi
        
        else 

            if ! command hollaex login; then

                exit 1;

            fi

            if ! command hollaex pull --skip; then

                exit 1;

            fi

        fi
    
    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    load_config_variables;
    
    if [[ "$ENVIORNMENT_HOLLAEX_CPU_ARCH" ]]; then 

        export ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE="$(echo ${ENVIRONMENT_DOCKER_IMAGE_VERSION} | cut -f1 -d "-")-${ENVIORNMENT_HOLLAEX_CPU_ARCH}"
    
    else 

        export ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE="$(echo ${ENVIRONMENT_DOCKER_IMAGE_VERSION} | cut -f1 -d "-")"

    fi 

    override_docker_image_version;
    
    # export ENVIRONMENT_DOCKER_IMAGE_VERSION=$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE
    if [[ "$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE" ]]; then 

        export ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY=$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE
    
    fi

    export ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-core-${ENVIRONMENT_DOCKER_IMAGE_VERSION}-$(date +%y%m%d%H%M)"

    build_user_hollaex_core;

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then

            echo "*********************************************"
            printf "\033[91mError: HollaEx CLI detected that the exchange exists on your remote Kubernetes environment.\033[39m\n"
            printf "\033[91mCannot setup an exchange multiple times.\033[39m\n\n"
            echo "Exiting..."
            echo "*********************************************"
            exit 1;

        fi

        # launch_basic_settings_input;

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes;
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME"  ]] ; then
            printf "\033[91mError: Please define exchange name and Docker image version on config file before running HollaEx CLI.\033[39m\n"
            print_usage
            exit 1;
        fi

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to launch $HOLLAEX_CONFIGMAP_API_NAME v$ENVIRONMENT_DOCKER_IMAGE_VERSION ($HOLLAEX_CONFIGMAP_API_HOST) on this cluster? (Y/n)"

            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo "Generating Kubernetes Configmap."
        generate_kubernetes_configmap;

        echo "Generating Kubernetes Secret."
        generate_kubernetes_secret;

        echo "Generating Kubernetes Ingress."
        generate_kubernetes_ingress;
        
        echo "Creating namespace on Kubernetes."
        kubectl create ns $ENVIRONMENT_EXCHANGE_NAME

        echo "Applying configmap on the namespace."
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml
        
        echo "Applying secret on the namespace."
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

        if [[ "$ENVIRONMENT_KUBERNETES_RUN_REDIS" == true ]]; then

            generate_nodeselector_values $ENVIRONMENT_KUBERNETES_REDIS_NODESELECTOR redis

            echo "Running Redis."
            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-redis \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --set setAuth.secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                        --set resources.limits.cpu="${ENVIRONMENT_KUBERNETES_REDIS_CPU_LIMITS:-100m}" \
                        --set resources.limits.memory="${ENVIRONMENT_KUBERNETES_REDIS_MEMORY_LIMITS:-200Mi}" \
                        --set resources.requests.cpu="${ENVIRONMENT_KUBERNETES_REDIS_CPU_REQUESTS:-10m}" \
                        --set resources.requests.memory="${ENVIRONMENT_KUBERNETES_REDIS_MEMORY_REQUESTS:-100Mi}" \
                        -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-redis/values.yaml \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-redis.yaml \
                        $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-redis $(kubernetes_set_backend_image_target $ENVIRONMENT_DOCKER_IMAGE_REDIS_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_REDIS_VERSION) $(set_nodeport_access $ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_REDIS_ACCESS $ENVIRONMENT_KUBERNETES_EXTERNAL_REDIS_ACCESS_PORT)
        
        fi

        if [[ "$ENVIRONMENT_KUBERNETES_RUN_POSTGRESQL_DB" == true ]]; then

            generate_nodeselector_values $ENVIRONMENT_KUBERNETES_POSTGRESQL_DB_NODESELECTOR postgresql
            echo "Running PostgreSQL DB."

            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-db \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --set pvc.create=true \
                        --set pvc.name="$ENVIRONMENT_EXCHANGE_NAME-postgres-volume" \
                        --set pvc.size="$ENVIRONMENT_KUBERNETES_POSTGRESQL_DB_VOLUMESIZE" \
                        --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                        --set resources.limits.cpu="${ENVIRONMENT_KUBERNETES_POSTGRESQL_CPU_LIMITS:-100m}" \
                        --set resources.limits.memory="${ENVIRONMENT_KUBERNETES_POSTGRESQL_MEMORY_LIMITS:-200Mi}" \
                        --set resources.requests.cpu="${ENVIRONMENT_KUBERNETES_POSTGRESQL_CPU_REQUESTS:-10m}" \
                        --set resources.requests.memory="${ENVIRONMENT_KUBERNETES_POSTGRESQL_MEMORY_REQUESTS:-100Mi}" \
                        -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres/values.yaml \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-postgresql.yaml \
                        $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres $(kubernetes_set_backend_image_target $ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_VERSION) $(set_nodeport_access $ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_POSTGRESQL_DB_ACCESS $ENVIRONMENT_KUBERNETES_EXTERNAL_POSTGRESQL_DB_ACCESS_PORT)

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_RUN_INFLUXDB" == true ]]; then

            if [[ "$ENVIRONMENT_KUBERNETES_INFLUXDB_NODESELECTOR" ]]; then

                generate_nodeselector_values $ENVIRONMENT_KUBERNETES_INFLUXDB_NODESELECTOR influxdb

            fi

            echo "Running InfluxDB."
            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-influxdb \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --set setCustomUser.enabled="true" \
                        --set setCustomUser.secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                        --set persistence.size="$ENVIRONMENT_KUBERNETES_INFLUXDB_VOLUMESIZE" \
                        --set resources.limits.cpu="${ENVIRONMENT_KUBERNETES_INFLUXDB_CPU_LIMITS:-200m}" \
                        --set resources.limits.memory="${ENVIRONMENT_KUBERNETES_INFLUXDB_MEMORY_LIMITS:-400Mi}" \
                        --set resources.requests.cpu="${ENVIRONMENT_KUBERNETES_INFLUXDB_CPU_REQUESTS:-100m}" \
                        --set resources.requests.memory="${ENVIRONMENT_KUBERNETES_INFLUXDB_MEMORY_REQUESTS:-256Mi}" \
                        -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-influxdb/values.yaml \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-influxdb.yaml \
                        $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-influxdb $(kubernetes_set_backend_image_target is_influxdb $ENVIRONMENT_DOCKER_IMAGE_INFLUXDB_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_INFLUXDB_VERSION)

        fi

        echo "Applying ingress on the namespace."
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml
        
        create_kubernetes_docker_registry_secret;

        # FOR GENERATING NODESELECTOR VALUES
        generate_nodeselector_values ${ENVIRONMENT_KUBERNETES_EXCHANGE_STATEFUL_NODESELECTOR:-$ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR} hollaex-stateful
        generate_nodeselector_values ${ENVIRONMENT_KUBERNETES_EXCHANGE_STATELESS_NODESELECTOR:-$ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR} hollaex-stateless

        echo "Running $HOLLAEX_CONFIGMAP_API_NAME workload containers."

        helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-api \
                     --wait \
                     --namespace $ENVIRONMENT_EXCHANGE_NAME \
                     --set DEPLOYMENT_MODE="api" \
                     --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY" \
                     --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION" \
                     --set stable.replicaCount="${ENVIRONMENT_KUBERNETES_API_SERVER_REPLICAS:-1}" \
                     --set autoScaling.hpa.enable="${ENVIRONMENT_KUBERNETES_API_HPA_ENABLE:-false}" \
                     --set autoScaling.hpa.avgMemory="${ENVIRONMENT_KUBERNETES_API_HPA_AVGMEMORY:-1300000000}" \
                     --set autoScaling.hpa.maxReplicas="${ENVIRONMENT_KUBERNETES_API_HPA_MAXREPLICAS:-4}" \
                     --set envName="$ENVIRONMENT_EXCHANGE_NAME-env" \
                     --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                     --set resources.limits.cpu="${ENVIRONMENT_KUBERNETES_API_CPU_LIMITS:-500m}" \
                     --set resources.limits.memory="${ENVIRONMENT_KUBERNETES_API_MEMORY_LIMITS:-1024Mi}" \
                     --set resources.requests.cpu="${ENVIRONMENT_KUBERNETES_API_CPU_REQUESTS:-10m}" \
                     --set resources.requests.memory="${ENVIRONMENT_KUBERNETES_API_MEMORY_REQUESTS:-1024Mi}" \
                     --set podRestart_webhook_url="$ENVIRONMENT_KUBERNETES_RESTART_NOTIFICATION_WEBHOOK_URL" \
                     -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex-stateless.yaml \
                     -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server

        helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-stream \
                     --namespace $ENVIRONMENT_EXCHANGE_NAME \
                     --set DEPLOYMENT_MODE="stream" \
                     --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY" \
                     --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION" \
                     --set stable.replicaCount="${ENVIRONMENT_KUBERNETES_STREAM_SERVER_REPLICAS:-1}" \
                     --set autoScaling.hpa.enable="${ENVIRONMENT_KUBERNETES_STREAM_HPA_ENABLE:-false}" \
                     --set autoScaling.hpa.avgMemory="${ENVIRONMENT_KUBERNETES_STREAM_HPA_AVGMEMORY:-300000000}" \
                     --set autoScaling.hpa.maxReplicas="${ENVIRONMENT_KUBERNETES_STREAM_HPA_MAXREPLICAS:-4}" \
                     --set envName="$ENVIRONMENT_EXCHANGE_NAME-env" \
                     --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                     --set resources.limits.cpu="${ENVIRONMENT_KUBERNETES_STREAM_CPU_LIMITS:-500m}" \
                     --set resources.limits.memory="${ENVIRONMENT_KUBERNETES_STREAM_MEMORY_LIMITS:-512Mi}" \
                     --set resources.requests.cpu="${ENVIRONMENT_KUBERNETES_STREAM_CPU_REQUESTS:-10m}" \
                     --set resources.requests.memory="${ENVIRONMENT_KUBERNETES_STREAM_MEMORY_REQUESTS:-128Mi}" \
                     --set podRestart_webhook_url="$ENVIRONMENT_KUBERNETES_RESTART_NOTIFICATION_WEBHOOK_URL" \
                     -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex-stateless.yaml \
                     -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server

        helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-plugins-controller \
                     --namespace $ENVIRONMENT_EXCHANGE_NAME \
                     --set DEPLOYMENT_MODE="plugins-controller" \
                     --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY" \
                     --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION" \
                     --set envName="$ENVIRONMENT_EXCHANGE_NAME-env" \
                     --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                     --set resources.limits.cpu="${ENVIRONMENT_KUBERNETES_PLUGINS_CPU_LIMITS:-500m}" \
                     --set resources.limits.memory="${ENVIRONMENT_KUBERNETES_PLUGINS_MEMORY_LIMITS:-512Mi}" \
                     --set resources.requests.cpu="${ENVIRONMENT_KUBERNETES_PLUGINS_CPU_REQUESTS:-10m}" \
                     --set resources.requests.memory="${ENVIRONMENT_KUBERNETES_PLUGINS_MEMORY_REQUESTS:-128Mi}" \
                     --set podRestart_webhook_url="$ENVIRONMENT_KUBERNETES_RESTART_NOTIFICATION_WEBHOOK_URL" \
                     -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex-stateful.yaml \
                     -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server

        helm_dynamic_trading_paris run;

        sleep 5;

        kubernetes_database_init launch;

        if [[ "$ENVIRONMENT_KUBERNETES_S3_BACKUP_CRONJOB_ACCESSKEY" ]] && [[ "$ENVIRONMENT_KUBERNETES_S3_BACKUP_CRONJOB_SECRETKEY" ]]; then

            echo "Installing PostgreSQL database backup Cronjob..."
            hollaex toolbox --set_backup_cronjob --kube --skip

        fi 

        hollaex_setup_finalization;

        exit 0;

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"  
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        if command docker ps -a | grep local_$ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then

            echo "*********************************************"
            printf "\033[91mError: HollaEx CLI detected that the exchange exists on your machine.\033[39m\n"
            printf "\033[91mExchange setup can't be done for multiple times.\033[39m\n\n"
            printf "\033[91mIf you want to just update settings values, Please run 'hollaex setup --reconfigure' instead.\033[39m\n\n"
            echo "Exiting..."
            echo "*********************************************"
            exit 1;

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi
        

        # if [[ "$RUN_WITH_VERIFY" == true ]]; then

        #     echo "Are you sure you want to run $HOLLAEX_CONFIGMAP_API_NAME on your machine? (Y/n)"

        #     read answer

        #     if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
        #         echo "Exiting..."
        #         exit 0;
        #     fi

        # fi

        echo "Generating env file for docker"
        generate_local_env;
        
        # Generating docker-compose yaml for exchange
        echo "Generating docker-compose file"
        generate_local_docker_compose

        echo "Generating Nginx upstream conf"
        generate_nginx_upstream;
        
        # Update nginx.conf to apply user own domains
        echo "Updating nginx conf file based on user settings"
        apply_nginx_user_defined_values;

        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d; then

             # Running database init
            RUN_WITH_VERIFY=false
            local_database_init start;

             # Restarting containers after database init jobs.
            echo "Restarting containers to apply database changes."
            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml stop
            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d

        else 

            printf "\033[91mHollaEx CLI failed to launch containers. Please review your settings and try again.\033[39m\n"
            exit 1;
       
        fi
        
        hollaex_setup_finalization;

        exit 0;

    fi

elif [[ "$1" == "import" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_IMPORT_PATH_INPUT=$@
                shift; continue
                ;;
            --with_aws_s3)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                TARGET_AWS_S3_BUCKET=$1
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    # HOLLAEX_IMPORT_PATH_INPUT=$@
    IFS=' ' read -ra HOLLAEX_IMPORT_PATH <<< "$HOLLAEX_IMPORT_PATH_INPUT"    #Convert string to array

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! -d "$HOLLAEX_CLI_INIT_PATH/.old" ]]; then

        mkdir $HOLLAEX_CLI_INIT_PATH/.old

    fi

# Storing current CURRENCIES and PARIS
cat > $HOLLAEX_CLI_INIT_PATH/.old/old-currencies-and-pairs <<EOL

OLD_CURRENCIES=$(echo $HOLLAEX_CONFIGMAP_CURRENCIES)
OLD_PAIRS=$(echo $HOLLAEX_CONFIGMAP_PAIRS)

EOL

    if [[ "$TARGET_AWS_S3_BUCKET" ]]; then 

        if [[ "$ENVIRONMENT_EXCHANGE_NAME" == "hollaex" ]] && [[ "$HOLLAEX_CONFIGMAP_API_NAME" == "my-hollaex-exchange" ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME" ]] ; then

            echo "Error: Your haven't typed the exchange name yet."
            echo "Please type the registered exchange name."
            echo "The name will be used to point the AWS S3 folder."
            read exchangeName
            exchangeNameParsed=$(echo $exchangeName | tr -dc '[:alnum:]\n\r' | tr '[:upper:]' '[:lower:]' | tr -d ' ')
            
            echo "Your exchange name: $exchangeNameParsed."
            echo "Do you want to proceed with this name? (Y/n)"
            read answer 

            while true;
                do if [[ ! "$answer" = "${answer#[Nn]}" ]]; then 
                    echo "Please type the registered exchange name."
                    read exchangeName
                    exchangeNameParsed=$(echo $exchangeName | tr -dc '[:alnum:]\n\r' | tr '[:upper:]' '[:lower:]' | tr -d ' ')
                    
                    echo "Your exchange name: $exchangeNameParsed."
                    echo "Do you want to proceed with this name? (Y/n)"
                    read answer
                else
                    break;
                fi
            done

            export ENVIRONMENT_EXCHANGE_NAME=$exchangeNameParsed

        fi 

        mkdir -p $HOLLAEX_CLI_INIT_PATH/.settings-temp

        echo "Pulling the settings files from s3://$TARGET_AWS_S3_BUCKET/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME AWS S3 bucket."
        if ! command aws s3 cp --recursive s3://$TARGET_AWS_S3_BUCKET/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME/ $HOLLAEX_CLI_INIT_PATH/.settings-temp; then

            echo "Error: Failed to pull the settings files from s3://$TARGET_AWS_S3_BUCKET/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME."
            echo "Please check the error logs and try again."

            exit 1;

        fi 

        export HOLLAEX_IMPORT_PATH=$HOLLAEX_CLI_INIT_PATH/.settings-temp

    fi 

    if [[ "${HOLLAEX_IMPORT_PATH[@]}" == *"json"* ]]; then

         # Returns error If 'jq' doesn't exists.
        if ! command jq --version > /dev/null 2>&1; then

            printf "\033[91mError: 'jq' (https://stedolan.github.io/jq/) has not been detected on your system.\033[39m\n"
            echo "HollaEx CLI requires 'jq' to handle certain functionalities."
            echo "Please install it first and try again."

            printf "\nFor Ubuntu (Debian) users: 'apt-get install -y jq'\n"
            printf "For macOS users with Homebrew: 'brew install jq'\n\n"

            exit 1;

        fi

        echo "Converting imported file to HollaEx CLI settings file format..."

        for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_CONFIGMAP_API_NAME=" $i > /dev/null ; then

            export CONFIGMAP_FILE_PATH=$i

        fi

        done

        for i in ${CONFIG_FILE_PATH[@]}; do

            if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

                export SECRET_FILE_PATH=$i

            fi

        done
        
        BITHOLLA_USER_EXCHANGE_LIST=$(cat $HOLLAEX_IMPORT_PATH)

        # SAVING USER ACTIVATION CODE.
        export EXCHANGE_USER_ACTIVATION_CODE=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[0].activation_code";);
        sed -i.bak "s/HOLLAEX_SECRET_ACTIVATION_CODE=.*/HOLLAEX_SECRET_ACTIVATION_CODE=${EXCHANGE_USER_ACTIVATION_CODE}/" $SECRET_FILE_PATH;
        rm $SECRET_FILE_PATH.bak

        BITHOLLA_USER_EXCHANGE_ORDER=0

        hollaex_pull_and_apply_exchange_data;

        apply_coins_config_to_settings_file;

        apply_pairs_config_to_settings_file;

        if command grep -q "ENVIRONMENT_ADD_COIN_${COIN_PREFIX}_COIN" $CONFIGMAP_FILE_PATH > /dev/null && command grep -q "ENVIRONMENT_ADD_PAIR_${PAIR_PREFIX}" $CONFIGMAP_FILE_PATH > /dev/null; then

            IS_IMPORT_SUCCESS=true

        else 

            IS_IMPORT_SUCCESS=false

        fi

    else 

        rm $CONFIG_FILE_PATH

        for i in ${HOLLAEX_IMPORT_PATH[@]}; do

            if [[ -d "$i" ]]; then
                
                if command cp $i/* $IMPORT_FILE_PATH; then

                    IS_IMPORT_SUCCESS=true
                
                else 

                    IS_IMPORT_SUCCESS=false
                
                fi

            elif [[ -f "$i" ]]; then

                if command cp $i $IMPORT_FILE_PATH; then

                    IS_IMPORT_SUCCESS=true
                
                else 

                    IS_IMPORT_SUCCESS=false
                
                fi
            
            fi

        done;

        if [[ -d "$HOLLAEX_IMPORT_PATH" ]]; then
            
            if command cp $HOLLAEX_IMPORT_PATH/* $IMPORT_FILE_PATH; then

                IS_IMPORT_SUCCESS=true
            
            fi

        elif [[ -f "$HOLLAEX_IMPORT_PATH" ]]; then

            if command cp $HOLLAEX_IMPORT_PATH $IMPORT_FILE_PATH; then

                IS_IMPORT_SUCCESS=true
            
            fi
        
        fi

    fi

    if [[ "$IS_IMPORT_SUCCESS" == true ]]; then 

        printf "\033[92mYour settings files has been imported into your HollaEx Kit!\033[39m\n"
        echo "If you are trying to run a brand-new exchange, proceed to run 'hollaex setup'."
        echo "If you are already running the exchange, and trying to apply reconfigured files, run 'hollaex restart'."

    else 

        printf "\033[91m\nFailed to import your files into HollaEx Kit.\033[39m\n"
        echo "Please confirm that you passed the correct path of your settings files (or directory), and try again."

        exit 1;
    
    fi

    if [[ -d "$HOLLAEX_CLI_INIT_PATH/.settings-temp" ]]; then

        rm -r $HOLLAEX_CLI_INIT_PATH/.settings-temp

    fi 

elif [[ "$1" == "export" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_EXPORT_PATH_INPUT=$@
                shift; continue
                ;;
            --with_aws_s3)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                TARGET_AWS_S3_BUCKET=$1
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    # HOLLAEX_IMPORT_PATH_INPUT=$@
    IFS=' ' read -ra HOLLAEX_EXPORT_PATH <<< "$HOLLAEX_EXPORT_PATH_INPUT"    #Convert string to array

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! -d "$HOLLAEX_CLI_INIT_PATH/.old" ]]; then

        mkdir $HOLLAEX_CLI_INIT_PATH/.old

    fi


    if [[ "$TARGET_AWS_S3_BUCKET" ]]; then 

        if [[ "$ENVIRONMENT_EXCHANGE_NAME" == "hollaex" ]] && [[ "$HOLLAEX_CONFIGMAP_API_NAME" == "my-hollaex-exchange" ]]; then

            echo "Error: Your haven't typed the exchange name yet."
            echo "Please type the registered exchange name."
            echo "The name will be used to point the AWS S3 folder."
            read exchangeName
            exchangeNameParsed=$(echo $exchangeName | tr -dc '[:alnum:]\n\r' | tr '[:upper:]' '[:lower:]' | tr -d ' ')
            
            echo "Your exchange name: $exchangeNameParsed."
            echo "Do you want to proceed with this name? (Y/n)"
            read answer 

            while true;
                do if [[ ! "$answer" = "${answer#[Nn]}" ]]; then 
                    echo "Please type the registered exchange name."
                    read exchangeName
                    exchangeNameParsed=$(echo $exchangeName | tr -dc '[:alnum:]\n\r' | tr '[:upper:]' '[:lower:]' | tr -d ' ')
                    
                    echo "Your exchange name: $exchangeNameParsed."
                    echo "Do you want to proceed with this name? (Y/n)"
                    read answer
                else
                    break;
                fi
            done

            export ENVIRONMENT_EXCHANGE_NAME=$exchangeNameParsed

        fi 

        echo "Pushing the settings files to s3://$TARGET_AWS_S3_BUCKET/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME AWS S3 bucket."
        if ! command aws s3 cp --recursive $HOLLAEX_CLI_INIT_PATH/settings s3://$TARGET_AWS_S3_BUCKET/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME; then

            echo "Error: Failed to push the settings files to s3://$TARGET_AWS_S3_BUCKET/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME."
            echo "Please check the error logs and try again."

            exit 1;

        fi 

    elif [[ "$HOLLAEX_EXPORT_PATH_INPUT" ]]; then

        echo "Exporting HollaEx Kit settings files to $HOLLAEX_EXPORT_PATH_INPUT/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME."

        mkdir -p $HOLLAEX_EXPORT_PATH_INPUT/hollaex-kit-settings
        mkdir -p $HOLLAEX_EXPORT_PATH_INPUT/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME
        
        cp $HOLLAEX_CLI_INIT_PATH/settings/* $HOLLAEX_EXPORT_PATH_INPUT/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME

    fi 

    printf "\033[92mYour settings files has been exported successfully!\033[39m\n"

elif [[ "$1" == "login" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --renew)
                HOLLAEX_LOGIN_RENEW=true
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    # Returns error If 'jq' doesn't exists.
    if ! command jq --version > /dev/null 2>&1; then

        printf "\033[91mError: 'jq' (https://stedolan.github.io/jq/) has not been detected on your system.\033[39m\n"
        echo "HollaEx CLI requires 'jq' to handle certain functionalities."
        echo "Please install it first and try again."

        printf "\nFor Ubuntu (Debian) users: 'apt-get install -y jq'\n"
        printf "For macOS users with Homebrew: 'brew install jq'\n\n"

        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

            export SECRET_FILE_PATH=$i

        fi

    done

    source $SCRIPTPATH/tools_generator.sh

    hollaex_login_token_validate_and_issue;

    BITHOLLA_USER_EXCHANGE_LIST=$(curl -s -H "Content-Type: application/json" -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN"\
        --request GET \
        https://$ENVIRONMENT_BRIDGE_TARGET_SERVER/v1/exchange \
       | jq '.')
    
    BITHOLLA_USER_EXCHANGE_COUNT=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r '.count')
    
    # Exit with error if user doesn't have any exchange on the account.
    if [[ "$BITHOLLA_USER_EXCHANGE_COUNT" == "0" ]]; then

        printf "\n\033[91mError: You don't have any exchange on your account.\033[39m\n"
        echo "Please go to the bitHolla Dashboard (dash.bitholla.com), and do an exchange configuration first."
        
        exit 1;

    fi

    # Subtracting 1 from total count due to the array starts from 0, not from 1.
    BITHOLLA_USER_EXCHANGE_COUNT=$((BITHOLLA_USER_EXCHANGE_COUNT-1))

    printf "\n"

    function hollaex_login_select_exchange() {

        printf "Please pick the \033[1mexchange number\033[0m you want to bind.\n\n"

        for ((i=0;i<=BITHOLLA_USER_EXCHANGE_COUNT;i++)); do 

        printf "Exchange number : \033[1m$((i+1))\033[0m\n";

        echo "Name:" $(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].name");
        echo "Activation Code:" $(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].activation_code");
        printf "\n"

        EXCHANGE_NAME_TEMP=EXCHANGE_NAME_${i}
        EXCHANGE_ACTIVATION_CODE_TEMP=EXCHANGE_ACTIVATION_CODE_${i}

        export $(echo $EXCHANGE_NAME_TEMP)=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].name";);
        export $(echo $EXCHANGE_ACTIVATION_CODE_TEMP)=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].activation_code";);

        done;

        printf "Input the exchange number: "
        read answer

        while true;
            do if [[ ! "${answer}" =~ ^[0-9]+$ ]]; then 
                printf "\033[91m\nError: The input always should be numberic.\033[39m\n"
                echo "Please pick the exchange number you want to bind."
                read answer
            else
                break;
            fi
        done

        answer=$((answer-1))
        
        printf "\n"
        SELECTED_EXCHANGE_NAME=EXCHANGE_NAME_${answer}
        SELECTED_EXCHANGE_ACTIVATION_CODE=EXCHANGE_ACTIVATION_CODE_${answer}

        if [[ ! "${!SELECTED_EXCHANGE_NAME}" ]] || [[ ! "${!SELECTED_EXCHANGE_ACTIVATION_CODE}" ]]; then

            printf "\033[91m\nError: Failed to read the data from the selected exchange.\033[39m\n"
            printf "Please make sure that you selected the correct number, and try again.\n\n"
            hollaex_login_select_exchange;

        fi
        
        echo -e "\033[1mSelected Exchange name: ${!SELECTED_EXCHANGE_NAME}\033[0m"
        echo -e "\033[1mSelected Activation code: ${!SELECTED_EXCHANGE_ACTIVATION_CODE}\033[0m"
        echo "Do you want to continue? (Y/n)"
        read answer

        if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then

            hollaex_login_select_exchange;

        fi
    }

    hollaex_login_select_exchange;

    if command sed -i.bak "s/HOLLAEX_SECRET_ACTIVATION_CODE=.*/HOLLAEX_SECRET_ACTIVATION_CODE=${!SELECTED_EXCHANGE_ACTIVATION_CODE}/" $SECRET_FILE_PATH; then

        rm $SECRET_FILE_PATH.bak

        printf "\n\033[92mSuccessfully bound the selected exchange to HollaEx Kit.\033[39m\n"

    else

        printf "\033[91mFailed to bind selected exchange to HollaEx Kit.\033[39m\n"
        echo "Please review the error and try again."
        exit 1;

    fi

elif [[ "$1" == "logout" ]]; then

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    printf "\nAre you sure you want to \033[1mlogout\033[0m from bitHolla? (y/N)\n"
    printf "This command \033[1mwould not affect\033[0m your exchange data.\n"
    read answer

    if [[ "$answer" = "${answer#[Yy]}" ]]; then
        echo "Exiting..."
        exit 0;
    fi

    # Removing the login token
    if [[ -f "$HOLLAEX_CLI_INIT_PATH/.token" ]]; then

        rm $HOLLAEX_CLI_INIT_PATH/.token
    
    else 

        printf "\n\033[93mThere was no login data to revoke.\033[39m\n"
    
    fi

    printf "\nPlease run 'hollaex login' if you want to login back.\n"
    printf "Bye!\n\n"

elif [[ "$1" == "pull" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --renew)
                HOLLAEX_LOGIN_RENEW=true
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    # Returns error If 'jq' doesn't exists.
    if ! command jq --version > /dev/null 2>&1; then

        printf "\033[91mError: 'jq' (https://stedolan.github.io/jq/) has not been detected on your system.\033[39m\n"
        echo "HollaEx CLI requires 'jq' to handle certain functionalities."
        echo "Please install it first and try again."

        printf "\nFor Ubuntu (Debian) users: 'apt-get install -y jq'\n"
        printf "For macOS users with Homebrew: 'brew install jq'\n\n"

        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_CONFIGMAP_API_NAME=" $i > /dev/null ; then

            export CONFIGMAP_FILE_PATH=$i

        fi

    done

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

            export SECRET_FILE_PATH=$i

        fi

    done

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! "$HOLLAEX_SECRET_ACTIVATION_CODE" ]]; then

        printf "\033[91mFailed to read pre-bound Activation code.\033[39m\n"
        echo "'hollaex pull' works only after you successfully logged in."
        echo "Please run 'hollaex login' to sign in first."
        exit 1;
    
    fi

    if [[ "$RUN_WITH_VERIFY" == true ]]; then 

        printf "\nCurrent bound activation code: \033[92m$HOLLAEX_SECRET_ACTIVATION_CODE\033[39m\n\n"
        echo "This command will override the current Exchange settings at '/settings' folder of your HollaEx Kit."
        echo "Are you sure you want to pull the exchange settings from bitHolla Dashboard? (y/N)"
        read answer

        if [[ "$answer" = "${answer#[Yy]}" ]]; then
            echo "Exiting..."
            exit 0;
        fi
    
    fi 

    if [[ -f "$HOLLAEX_CLI_INIT_PATH/.token" ]]; then

        export BITHOLLA_ACCOUNT_TOKEN=$(cat $HOLLAEX_CLI_INIT_PATH/.token)

    else 

        printf "\033[91mError: An access token has not been detected.\033[39m\n"
        printf "Please login with your bitHolla account to issue an access token.\n\n"
        hollaex login --renew

    fi

    BITHOLLA_USER_TOKEN_EXPIRY_CHECK=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN"\
            --request GET \
            https://$ENVIRONMENT_BRIDGE_TARGET_SERVER/v1/exchange)

    BITHOLLA_USER_EXCHANGE_LIST=$(curl -s -H "Content-Type: application/json" -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN"\
        --request GET \
        https://$ENVIRONMENT_BRIDGE_TARGET_SERVER/v1/exchange \
       | jq '.')

    if [[ ! "$BITHOLLA_USER_TOKEN_EXPIRY_CHECK" ]] || [[ ! "$BITHOLLA_USER_TOKEN_EXPIRY_CHECK" == "200" ]]; then

        printf "\033[91mFailed to pull the exchange data from bitHolla.\033[39m\n\n"
        printf "\033[91mError: Your access token has been expired!\033[39m\n"
        printf "Please login again with your bitHolla account to issue a new access token.\n\n"
        hollaex login --renew

    else 

        printf "\n\033[92mSuccessfully authenticated on bitHolla Server.\033[39m\n"
        printf "Proceeding to pull data from bitHolla...\n"

    fi

    BITHOLLA_USER_EXCHANGE_COUNT=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r '.count')

    BITHOLLA_USER_EXCHANGE_COUNT=$((BITHOLLA_USER_EXCHANGE_COUNT-1))

    for ((i=0;i<=BITHOLLA_USER_EXCHANGE_COUNT;i++)); do 

        if [[ $(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].activation_code") == "$HOLLAEX_SECRET_ACTIVATION_CODE" ]]; then

            export BITHOLLA_USER_EXCHANGE_ORDER=$i
        
        fi

    done;

    if [[ $(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$BITHOLLA_USER_EXCHANGE_ORDER].is_completed") == false ]]; then

        BITHOLLA_USER_EXCHANGE_UPDATED_DATE=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$BITHOLLA_USER_EXCHANGE_ORDER].updated_at" | cut -f1 -d "T" | tr -d '-')
        BITHOLLA_DASH_1_3_RELEASE_DATE=20200219

        printf "\n\033[91mError: Your exchange is not fully configured at bitHolla Dashboard.\033[39m\n"
        printf "Please finalize the exchange setup at bitHolla Dashboard (https://dash.bitholla.com), and try agian.\n\n"

        if (($BITHOLLA_DASH_1_3_RELEASE_DATE > $BITHOLLA_USER_EXCHANGE_UPDATED_DATE)); then

            printf "\033[1mFor the HollaEx users who updated the exchange before Feb 19th, 2020.\033[0m\n"
            printf "You should \033[1mgo through the exchange setup once more\033[0m to update your exchange status.\n"
            printf "You don't need to update any vaules on the dashboard if it's not required.\n\n"

        fi

        exit 1;

    fi

    hollaex_pull_and_apply_exchange_data;

    apply_coins_config_to_settings_file;

    apply_pairs_config_to_settings_file;

    if command grep -q "ENVIRONMENT_ADD_COIN_${COIN_PREFIX}_COIN" $CONFIGMAP_FILE_PATH > /dev/null && command grep -q "ENVIRONMENT_ADD_PAIR_${PAIR_PREFIX}" $CONFIGMAP_FILE_PATH > /dev/null; then

        printf "\n\033[92mSuccessfully pulled and applied your exchange data to Hollaex Kit!\033[39m\n\n"

        if [[ ! "$RUN_WITH_VERIFY" ]]; then

            echo "You can now proceed to run 'hollaex setup' to initialize your brand-new exchange."
            printf "If you already have existing exchange, Please run 'hollaex restart' to apply new configurations.\n"
            
        fi

    else

        printf "\033[91mError: Failed to pull and apply data from bitHolla.\033[39m\n"
        echo "Please review the logs and try it again."
        exit 1;

    fi


elif [[ "$1" == "start" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --tag)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CORE_USER_APPLY_TAG=$1
                shift; continue
                ;;
            --mode)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_DEPLOYMENT_MODE=$1
                echo "Your DEPLOYMENT MODE setup : $LOCAL_DEPLOYMENT_MODE."
                shift; continue
                ;;
            --with_backends)
                WITH_BACKENDS=true
                echo "Creating backend components. Running backend components such as PostgreSQL or Redis together on this machine."
                shift; continue
                ;;
            --ignore_settings)
                IGNORE_SETTINGS=true
                echo "HollaEx CLI will ignore local settings update on restart."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi


    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

     source $SCRIPTPATH/tools_generator.sh

    # Update random secrets if env generation is enabled.
    if [[ ! "$IGNORE_SETTINGS" ]]; then 

        #Regenerate random secrets
        update_random_values_to_config;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;


     # Override user HollaEx Core tag if the flag is available.
    if [[ "$HOLLAEX_CORE_USER_APPLY_TAG" ]]; then
        
        override_user_docker_tag;

    fi

    load_config_variables;

    if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]]; then 

        # Check Kit version compatibility range.
        check_kit_version_compatibility_range;
    
    fi 

    if [[ "$IGNORE_SETTINGS" ]]; then

        export ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE=false 
        
    fi 

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME"  ]] ; then
            printf "\033[91mError: Please define exchange name and Docker image version on config file before running HollaEx CLI.\033[39m\n"
            print_usage
            exit 1;
        fi

        check_empty_values_on_settings;

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        # if [[ "$RUN_WITH_VERIFY" == true ]]; then


        #     echo "Are you sure you want to start (scale up) $HOLLAEX_CONFIGMAP_API_NAME v$ENVIRONMENT_DOCKER_IMAGE_VERSION ($HOLLAEX_CONFIGMAP_API_HOST) on this cluster? (Y/n)"

        #     read answer

        #     if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
        #         echo "Exiting..."
        #         exit 0;
        #     fi

        # fi

        #Generating and updating settings

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE" == true ]]; then

            echo "Generating Kubernetes Configmap"
            generate_kubernetes_configmap;

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE" == true ]]; then

            echo "Generating Kubernetes Secret"
            generate_kubernetes_secret;

        fi


        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_INGRESS_ENABLE" == true ]]; then

            echo "Generating Kubernetes Ingress"
            generate_kubernetes_ingress;

        fi

        if [[ ! "$IGNORE_SETTINGS" ]]; then 

            echo "Applying configmap on the namespace"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml

            echo "Applying secret on the namespace"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml
        
        fi 

        # For scaling up exisitng Exchange on Kubernetes
        if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then

            echo "Scaling up containers on the cluster..."
            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-redis --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-db --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-influxdb --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-api --replicas=${ENVIRONMENT_KUBERNETES_API_SERVER_REPLICAS:-1} --namespace $ENVIRONMENT_EXCHANGE_NAME

            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-stream --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME
            
            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-plugins-controller --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME
            
            helm_dynamic_trading_paris scaleup;

            echo "Applying Ingress rules..."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

            echo "All done!"
            echo "Containers successfully scaled up"

            hollaex_ascii_exchange_is_up;

            exit 0;

        else 

            echo "HollaEx CLI failed to detect existing exchange running on this Kubernetes."
            echo "Please review your settings files and targeted Kubernetes."

            exit 1;

        fi

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        # Exit HollaEx CLI If docker_compose 
        if [[ ! "$ENVIRONMENT_EXCHANGE_RUN_MODE" ]]; then

            echo "Your ENVIRONMENT_EXCHANGE_RUN_MODE value is missing! Please reconfirm your settings files."
            exit 1;

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi

        check_empty_values_on_settings;
        
        LOCAL_COMMAND="up -d"

        #Quit if necessary flags are missing
        if [[ ! "$LOCAL_COMMAND" ]]; then

            echo "Some necessary flags are missing! Please check agian your command."
            print_usage;
            exit 1;

        fi

        # if [[ "$RUN_WITH_VERIFY" == true ]]; then

        #     echo "Are you sure you want to start $HOLLAEX_CONFIGMAP_API_NAME on your machine? (Y/n)"

        #     read answer

        #     if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
        #         echo "Exiting..."
        #         exit 0;
        #     fi

        # fi

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE" == true ]]; then

            echo "Generating env file for docker"
            generate_local_env;

        fi  
        
        # Generating docker-compose yaml for exchange
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then
            
            echo "Generating docker-compose file"
            generate_local_docker_compose

        fi
        
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_NGINX_UPSTREAM" == true ]]; then

            echo "Generating Nginx upstream conf"
            generate_nginx_upstream;
        
        fi

        # Update nginx.conf to apply user own domains
        echo "Updating nginx conf file based on user settings"
        apply_nginx_user_defined_values;

        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml $LOCAL_COMMAND; then

            hollaex_ascii_exchange_is_up;
        
        else 

            printf "\033[91mFailed to start exchange! Please review your settings and try again.\033[39m\n"
            exit 1;
        
        fi

        exit 0;

    fi

elif [[ "$1" == "scale" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --target)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_SCALE_TARGET=$1
                echo "Scaling Target: $HOLLAEX_SCALE_TARGET."
                shift; continue
                ;;
            --replicas)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_SCALE_TARGET_REPLICAS=$1
                echo "Target Replicas: $HOLLAEX_SCALE_TARGET_REPLICAS."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    export ENVIRONMENT_HOLLAEX_SCALEING=true

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

     source $SCRIPTPATH/tools_generator.sh

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    load_config_variables;

    if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]]; then 

        # Check Kit version compatibility range.
        check_kit_version_compatibility_range;
    
    fi 

    if [[ "$IGNORE_SETTINGS" ]]; then

        export ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE=false 
        
    fi 

     # Target filtering

    SUPPORTED_TARGETS=("api" "stream")

    if [[ "$HOLLAEX_SCALE_TARGET" ]]; then

        if ! command printf '%s\n' ${SUPPORTED_TARGETS[@]} | grep $HOLLAEX_SCALE_TARGET > /dev/null; then

            echo "Error: The specified target $HOLLAEX_SCALE_TARGET is not supported for scaling."
            echo "Supported targets: ${SUPPORTED_TARGETS[@]}."
            echo "Please try it again."

            exit 1;

        fi 

        export HOLLAEX_SCALE_TARGET_CONVERTED="${ENVIRONMENT_EXCHANGE_NAME}-server-${HOLLAEX_SCALE_TARGET}"

    else

        echo "Error: You must specify the target server for scaling with '--target' flag."
        echo "Please try it again."

        exit 1;

    fi

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME"  ]] ; then
            printf "\033[91mError: Please define exchange name and Docker image version on config file before running HollaEx CLI.\033[39m\n"
            print_usage
            exit 1;
        fi

        check_empty_values_on_settings;

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        # For scaling up exisitng Exchange on Kubernetes
        if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then

            echo "Scaling up containers on the cluster..."
            kubectl scale deployment/$HOLLAEX_SCALE_TARGET_CONVERTED --replicas=$HOLLAEX_SCALE_TARGET_REPLICAS --namespace $ENVIRONMENT_EXCHANGE_NAME
            
            export HOLLAEX_SCALE_TARGET_REPLICAS_SETTINGS="ENVIRONMENT_KUBERNETES_$(echo $HOLLAEX_SCALE_TARGET | tr '[:lower:]' '[:upper:]')_SERVER_REPLICAS"

            for i in ${CONFIG_FILE_PATH[@]}; do

                # Update exchange name
                if command grep -q "ENVIRONMENT_EXCHANGE_NAME" $i > /dev/null ; then
                    CONFIGMAP_FILE_PATH=$i
                    sed -i.bak "s/$HOLLAEX_SCALE_TARGET_REPLICAS_SETTINGS=.*/$HOLLAEX_SCALE_TARGET_REPLICAS_SETTINGS=$HOLLAEX_SCALE_TARGET_REPLICAS/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak
                fi
                
            done

            printf "\033[92m\nTarget $HOLLAEX_SCALE_TARGET has been successfully scaled to $HOLLAEX_SCALE_TARGET_REPLICAS.\033[39m\n"

            exit 0;

        else 

            printf "\033[91mFailed to scale the target $HOLLAEX_SCALE_TARGET! Please review your settings and try again.\033[39m\n"
            exit 1;

        fi

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        # Exit HollaEx CLI If docker_compose 
        if [[ ! "$ENVIRONMENT_EXCHANGE_RUN_MODE" ]]; then

            echo "Your ENVIRONMENT_EXCHANGE_RUN_MODE value is missing! Please reconfirm your settings files."
            exit 1;

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi

        # Checking that the existing docker-compose file got the host port bound specifications.
        if command cat $TEMPLATE_GENERATE_PATH/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml | grep -e "10010" -e "10080" > /dev/null 2>&1; then
            
            echo "Generating docker-compose file"
            generate_local_docker_compose

        fi

        # Running docker-compose scale command.
        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d --no-recreate --scale $HOLLAEX_SCALE_TARGET_CONVERTED=$HOLLAEX_SCALE_TARGET_REPLICAS; then
            
            # Nginx Reload
            docker exec -it $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload

            printf "\033[92m\nTarget $HOLLAEX_SCALE_TARGET has been successfully scaled to $HOLLAEX_SCALE_TARGET_REPLICAS.\033[39m\n"
        
        else 

            printf "\033[91mFailed to scale the target $HOLLAEX_SCALE_TARGET! Please review your settings and try again.\033[39m\n"
            exit 1;
        
        fi

    fi

    exit 0;


elif [[ "$1" == "prod" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi


    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    # for i in ${CONFIG_FILE_PATH[@]}; do
    #     source $i
    # done;
    
    source $SCRIPTPATH/tools_generator.sh
    # load_config_variables;

    if [[ "$RUN_WITH_VERIFY" == true ]]; then

        
        printf "\nPreparing the exchange for production deployment\n\n"

        echo -e "This command is going to apply \033[1mproduction domain\033[0m to your exchange."
        echo -e "Before you proceed make sure you have your own exchange domain. (Required)"
        echo -e "\033[1mAre you ready to proceed? (Y/n)\033[0m"

        read answer

        if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
            echo "Exiting..."
            exit 0;
        fi

    fi

    function hollaex_prod_domain_questions() {

        # Web Domain
        echo "***************************************************************"
        echo "Exchange Web Domain"
        printf "\033[2m- Enter the full domain of your exchange website, without 'http' or 'https'.\033[22m\n"
        read answer
        
        while true;
            do if [[ "$answer" == *"http"* ]]; then
                printf "\nValue should be an URL without 'http' or 'https'.\n\n"
                echo  "Exchange Web Domain: "
                read answer
                local INPUT_HOLLAEX_CONFIGMAP_DOMAIN="${answer}"
            elif [[ -z "$answer" ]]; then
                printf "\nThe value should not be empty!\n"
                echo  "Exchange Web Domain: "
                read answer
                local INPUT_HOLLAEX_CONFIGMAP_DOMAIN="${answer}"
            else
                break;
            fi
        done

        export INPUT_HOLLAEX_CONFIGMAP_DOMAIN="${answer}"
        export INPUT_HOLLAEX_CONFIGMAP_DOMAIN_WITH_HTTP="http://${answer}"
        local PARSED_INPUT_HOLLAEX_CONFIGMAP_DOMAIN=${INPUT_HOLLAEX_CONFIGMAP_DOMAIN_WITH_HTTP//\//\\/}

        printf "\n"
        echo "${INPUT_HOLLAEX_CONFIGMAP_DOMAIN} ✔"
        printf "\n"

        #Automatically mark the API url as api.<MY_DOMAIN>
        export INPUT_HOLLAEX_CONFIGMAP_API_HOST="api.${INPUT_HOLLAEX_CONFIGMAP_DOMAIN}"
        local INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTP="http://${INPUT_HOLLAEX_CONFIGMAP_API_HOST}"
        local PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST=${INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTP//\//\\/}

        printf "Since you selected the Exchange Web domain as: \033[1m$INPUT_HOLLAEX_CONFIGMAP_DOMAIN,\033[0m\n"
        printf "Your Exchange Server \033[1mAPI domain\033[0m would be: \033[1m$INPUT_HOLLAEX_CONFIGMAP_API_HOST\033[0m.\n"
        printf "Type \033[1m'Y'\033[0m to continute, or \033[1m'N'\033[0m to modify the Exchange Server API domain. (Y/n)\n"
        read answer

        if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
        
            # API Domain
            echo "***************************************************************"
            echo "Exchange Server API Domain"
            printf "\033[2m- Enter the full domain of your exchange API server, without 'http' or 'https'.\033[22m\n"
            read answer

            while true;
                do if [[ "$answer" == *"http"* ]]; then
                    printf "\nValue should be an URL without 'http' or 'https'.\n"
                    echo  "Exchange API Domain: "
                    read answer
                    local INPUT_HOLLAEX_CONFIGMAP_API_HOST="${answer}"
                elif [[ -z "$answer" ]]; then
                    printf "\nThe value should not be empty!\n\n"
                    echo  "Exchange API Domain: "
                    read answer
                    local INPUT_HOLLAEX_CONFIGMAP_API_HOST="${answer}"
                else
                    break;
                fi
            done

            export INPUT_HOLLAEX_CONFIGMAP_API_HOST="${answer}"

            printf "\n"
            echo "${INPUT_HOLLAEX_CONFIGMAP_API_HOST} ✔"
            printf "\n"

            local INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTP="http://${answer}"
            local PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST=${INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTP//\//\\/}

        fi 

        export HOLLAEX_CONFIGMAP_DOMAIN=$INPUT_HOLLAEX_CONFIGMAP_DOMAIN
        export HOLLAEX_CONFIGMAP_API_HOST=$INPUT_HOLLAEX_CONFIGMAP_API_HOST

        printf "\nYour Exchange Web Domain: \033[92m$INPUT_HOLLAEX_CONFIGMAP_DOMAIN\033[39m"
        printf "\nYour Exchange API Domain: \033[92m$INPUT_HOLLAEX_CONFIGMAP_API_HOST\033[39m\n"
        echo "Type 'Y' to proceed (Y/n)"
        read answer

        if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
    
            hollaex_prod_domain_questions;

        else 

            echo "Updating user settings file based on the provided values..."

            for i in ${CONFIG_FILE_PATH[@]}; do

                # Update exchange name
                if command grep -q "ENVIRONMENT_EXCHANGE_NAME" $i > /dev/null ; then
                    CONFIGMAP_FILE_PATH=$i
                    sed -i.bak "s/HOLLAEX_CONFIGMAP_DOMAIN=.*/HOLLAEX_CONFIGMAP_DOMAIN=$PARSED_INPUT_HOLLAEX_CONFIGMAP_DOMAIN/" $CONFIGMAP_FILE_PATH
                    sed -i.bak "s/HOLLAEX_CONFIGMAP_API_HOST=.*/HOLLAEX_CONFIGMAP_API_HOST=$PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak
                fi
                
            done
        
        fi

    }

    # Asking for domains questions for production.
    hollaex_prod_domain_questions;

    #Checking the domains are reachable
    function hollaex_prod_check_domains_reachability() {
        
        if command nslookup $INPUT_HOLLAEX_CONFIGMAP_DOMAIN > /dev/null; then

            printf "\n\033[92mSuccessfully resolved the exchange web URL ($INPUT_HOLLAEX_CONFIGMAP_DOMAIN).\033[39m\n"
            HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY=true

        else 

            HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY=false
        
        fi

        if command nslookup $INPUT_HOLLAEX_CONFIGMAP_API_HOST > /dev/null; then

            printf "\n\033[92mSuccessfully resolved the exchange API URL ($INPUT_HOLLAEX_CONFIGMAP_API_HOST).\033[39m\n"
            HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY=true

        else

            HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY=false
        
        fi

        if [[ "$HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY" == "false" ]] || [[ "$HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY" == "false" ]]; then

            # Announcing the domain configuration how-to.
            SYSTEM_PUBLIC_IP=$(curl -s ifconfig.me)

            if [[ ! "$SYSTEM_PUBLIC_IP" ]]; then
                printf "\n\033[91mError: Failed to get the system public IP automatically.\033[39m\n"
                echo "You should check it by yourself."
                SYSTEM_PUBLIC_IP="<YOUR_PUBLIC_IP>"
            fi

            printf "\n\nYour Public IP: $SYSTEM_PUBLIC_IP.\n\n"

            if [[ "$HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY" == "false" ]]; then

                printf "\n\033[93mThe domain DNS setup is required for $INPUT_HOLLAEX_CONFIGMAP_DOMAIN.\033[39m\n"
                printf "\nPlease set an \033[1mA RECORD\033[0m for \033[1m$INPUT_HOLLAEX_CONFIGMAP_DOMAIN to point $SYSTEM_PUBLIC_IP\033[0m.\n"
                printf "It is recommended to set the \033[1mTTL shorter\033[0m to apply DNS rule faster.\n\n"
                read -p "Press enter once you configured the DNS."
            fi

            if [[ "$HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY" == "false" ]]; then

                printf "\n\033[93mThe domain DNS setup is required for $INPUT_HOLLAEX_CONFIGMAP_API_HOST.\033[39m\n"
                printf "\nPlease set an \033[1mA RECORD\033[0m for \033[1m$INPUT_HOLLAEX_CONFIGMAP_API_HOST to point $SYSTEM_PUBLIC_IP\033[0m.\n"
                printf "It is recommended to set the \033[1mTTL shorter\033[0m to apply DNS rule faster.\n\n"
                read -p "Press enter once you configured the DNS."

            fi

            printf "\n\033[93mChecking the DNS reachability...\033[39m\n"
            echo "Info: You could always quit the DNS checking loop with 'Crtl + C'."
            hollaex_prod_check_domains_reachability;

        fi
    }

    hollaex_prod_check_domains_reachability;

    # if [[ "$HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY" == "false" ]] || [[ "$HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY" == "false" ]]; then

    #     # Announcing the domain configuration how-to.
    #     SYSTEM_PUBLIC_IP=$(curl -s ifconfig.me)

    #     if [[ ! "$SYSTEM_PUBLIC_IP" ]]; then
    #         printf "\n\033[91mError: Failed to get the system public IP automatically.\033[39m\n"
    #         echo "You should check it by yourself."
    #         SYSTEM_PUBLIC_IP="<YOUR_PUBLIC_IP>"
    #     fi

    #     printf "\n\nYour Public IP: $SYSTEM_PUBLIC_IP.\n\n"

    #     if [[ "$HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY" == "false" ]]; then

    #         printf "\n\033[93mThe domain DNS setup is required for $INPUT_HOLLAEX_CONFIGMAP_DOMAIN.\033[39m\n"
    #         printf "\nPlease set an \033[1mA RECORD\033[0m for \033[1m$INPUT_HOLLAEX_CONFIGMAP_DOMAIN to point $SYSTEM_PUBLIC_IP\033[0m.\n"
    #         printf "It is recommended to set the \033[1mTTL shorter\033[0m to apply DNS rule faster.\n\n"
    #         read -p "Press enter once you configured the DNS."
    #     fi

    #     if [[ "$HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY" == "false" ]]; then

    #         printf "\n\033[93mThe domain DNS setup is required for $INPUT_HOLLAEX_CONFIGMAP_API_HOST.\033[39m\n"
    #         printf "\nPlease set an \033[1mA RECORD\033[0m for \033[1m$INPUT_HOLLAEX_CONFIGMAP_API_HOST to point $SYSTEM_PUBLIC_IP\033[0m.\n"
    #         printf "It is recommended to set the \033[1mTTL shorter\033[0m to apply DNS rule faster.\n\n"
    #         read -p "Press enter once you configured the DNS."

    #     fi

    #     printf "\n\033[93mChecking the DNS reachability...\033[39m\n"
    #     hollaex_prod_check_domains_reachability;

    #     if [[ "$HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY" == "false" ]] || [[ "$HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY" == "false" ]]; then

    #         printf "\n\033[93mWarning: Your domain URLs are still not reachable.\033[39m\n\n"
    #         printf "It could take \033[1mfew minutes ~ few hours to the DNS gets fully configured\033[0m and functioning.\n"
    #         printf "Checking the DNS status again...\n"
    #         hollaex_prod_check_domains_reachability;

    #     fi

    # fi

    apply_nginx_user_defined_values;

    printf "\n"

    if [[ ! "$USE_KUBERNETES" ]]; then
    
        echo "Do you want to issue SSL cert for your exchange? (Y/n)"
        echo "If you are going to use an external load balancer with SSL, Please type 'N'."

    elif [[ "$USE_KUBERNETES" ]]; then

        echo "HollaEx CLI natively supports issuing SSL cert through 'cert-manager' and Let's encrypt."
        echo "Please make sure to install latest 'cert-manager' on your Kubernetes cluster."
        echo "Official document is available for installation. (cert-manager.io/docs/installation/kubernetes)"

        printf "\n"

        echo "Do you want to set up cert-manager issuer name for SSL? (Y/n)"
        echo "If you are going to use an external load balancer with SSL, Please type 'N'."

    fi
    
    read answer 

    printf "\n"

    if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
    
        echo "Skipping to issue SSL cert..."
        printf "\n\n\033[93mInfo: You could also issue SSL cert later by running 'hollaex toolbox --issue_ssl' command.\033[39m\n"

    else 

        if [[ "$USE_KUBERNETES" ]]; then
        
            echo "The 'cert-manager' requires an issuer name to reach SSL ACME service."
            echo "Please provide your cert-manager issuer name."
            read answer

            echo "Updating the issuer name on user's settings file..."
            for i in ${CONFIG_FILE_PATH[@]}; do

                # Update exchange name
                if command grep -q "HOLLAEX_CONFIGMAP_API_NAME" $i > /dev/null ; then
                CONFIGMAP_FILE_PATH=$i
                sed -i.bak "s/ENVIRONMENT_KUBERNETES_INGRESS_CERT_MANAGER_ISSUER=.*/ENVIRONMENT_KUBERNETES_INGRESS_CERT_MANAGER_ISSUER=$answer/" $CONFIGMAP_FILE_PATH
                rm $CONFIGMAP_FILE_PATH.bak
                fi
                
            done

            printf "\n"
            echo "$answer ✔"
            printf "\n"

        elif [[ ! "$USE_KUBERNETES" ]]; then

            echo "HollaEx CLI natively supports issuing SSL cert through 'certbot' and Let's encrypt."
            echo "Running 'certbot' now..."
            printf "\n"
            while true;
                do if command hollaex toolbox --issue_ssl --skip; then

                    echo "Do you want to issue more SSL cert for different domain? (Y/n)"
                    read answer

                    if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then

                        echo "Skipping..."
                        break;

                    else 

                        hollaex toolbox --issue_ssl --skip;
                        break;

                    fi
                
                else 

                    printf "\033[91mFailed to issue SSL certificate by using Certbot. Please confirm your settings and try again.\033[39m\n"
                    exit 1;

                fi

            done;

            
        fi

        if [[ "$USE_KUBERNETES" ]]; then 

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "HOLLAEX_CONFIGMAP_API_NAME" $i > /dev/null ; then
                    CONFIGMAP_FILE_PATH=$i
                fi 
            
            done

            echo "Do you want to enable cert-manager based SSL for API server? (Y/n)"
            read answer

             if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
            
                echo "Skipping to enable SSL for API server..."

                 if command grep -q "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER" $CONFIGMAP_FILE_PATH > /dev/null ; then
            
                    echo "Updating the existing ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER value..."
                    sed -i.bak "s/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=.*/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=false/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak

                else 

                    echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER is missing on your settings file. Adding it now..."
                    echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=false" >> $CONFIGMAP_FILE_PATH

                fi

            else 

                export ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=true

                if command grep -q "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER" $CONFIGMAP_FILE_PATH > /dev/null ; then
            
                    echo "Updating the existing ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER value..."
                    sed -i.bak "s/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=.*/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=true/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak

                else 

                    echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER is missing on your settings file. Adding it now..."
                    echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=true" >> $CONFIGMAP_FILE_PATH

                fi

                printf "\n"
                echo "✔"
                printf "\n"
            
            fi 

            echo "Do you want to enable cert-manager based SSL for Web server? (Y/n)"
            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
            
                echo "Skipping to enable SSL for Web server..."

                if command grep -q "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB" $CONFIGMAP_FILE_PATH > /dev/null ; then
            
                    echo "Updating the existing ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB value..."
                    sed -i.bak "s/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=.*/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=false/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak

                else 

                    echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB is missing on your settings file. Adding it now..."
                    echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=false" >> $CONFIGMAP_FILE_PATH

                fi

            else 

                export ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=true

                if command grep -q "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB" $CONFIGMAP_FILE_PATH > /dev/null ; then
            
                    echo "Updating the existing ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB value..."
                    sed -i.bak "s/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=.*/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=true/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak

                else 

                    echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB is missing on your settings file. Adding it now..."
                    echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=true" >> $CONFIGMAP_FILE_PATH

                fi

                printf "\n"
                echo "✔"
                printf "\n"
            
            fi 
        
        fi

        echo "Updating domains on settings files to use 'https' as a prefix..."

        INPUT_HOLLAEX_CONFIGMAP_DOMAIN_WITH_HTTPS="https://${INPUT_HOLLAEX_CONFIGMAP_DOMAIN}"
        PARSED_INPUT_HOLLAEX_CONFIGMAP_DOMAIN=${INPUT_HOLLAEX_CONFIGMAP_DOMAIN_WITH_HTTPS//\//\\/}

        INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTPS="https://${INPUT_HOLLAEX_CONFIGMAP_API_HOST}"
        PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST=${INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTPS//\//\\/}

        for i in ${CONFIG_FILE_PATH[@]}; do

            # Update exchange name
            if command grep -q "ENVIRONMENT_EXCHANGE_NAME" $i > /dev/null ; then
                CONFIGMAP_FILE_PATH=$i
                sed -i.bak "s/HOLLAEX_CONFIGMAP_DOMAIN=.*/HOLLAEX_CONFIGMAP_DOMAIN=$PARSED_INPUT_HOLLAEX_CONFIGMAP_DOMAIN/" $CONFIGMAP_FILE_PATH
                sed -i.bak "s/HOLLAEX_CONFIGMAP_API_HOST=.*/HOLLAEX_CONFIGMAP_API_HOST=$PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST/" $CONFIGMAP_FILE_PATH
                rm $CONFIGMAP_FILE_PATH.bak
            fi
            
        done

    fi

    hollaex_prod_complete;

    exit 0;

elif [[ "$1" == "stop" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
           --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --mode)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_DEPLOYMENT_MODE=$1
                echo "Your DEPLOYMENT_MODE setup : $LOCAL_DEPLOYMENT_MODE."
                shift; continue
                ;;
            --is_hollaex_setup)
                IS_HOLLAEX_SETUP=true
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done
    
    # Export hollaex-kit directory

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]]; then 

        # Check Kit version compatibility range.
        check_kit_version_compatibility_range;
    
    fi 

    #check_empty_values_on_settings

    if [[ "$USE_KUBERNETES" ]]; then
        

         #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to stop (scale down) $HOLLAEX_CONFIGMAP_API_NAME on this cluster? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        # Only tries to attempt remove ingress rules from Kubernetes if it exists.
        if ! command kubectl get ingress -n $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then
        
            echo "Removing $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

        fi

        echo "Scaling down containers on the cluster..."
        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-api --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-stream --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-plugins-controller --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        helm_dynamic_trading_paris scaledown;

        echo "Scaling down backend components..."

        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-redis --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-db --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-influxdb --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        hollaex_ascii_exchange_has_been_stopped;

        # exit 0;

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi 

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to stop $HOLLAEX_CONFIGMAP_API_NAME running on your machine? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml stop; then

            hollaex_ascii_exchange_has_been_stopped;

        else 

            printf "\033[91mFailed to stop exchange! Please review your settings and try again.\033[39m\n"
            exit 1;
        
        fi

        #exit 0;

    fi

elif [[ "$1" == "restart" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
             --tag)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CORE_USER_APPLY_TAG=$1
                shift; continue
                ;;
            --ignore_settings)
                IGNORE_SETTINGS=true
                echo "HollaEx CLI will ignore local settings update on restart."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

     source $SCRIPTPATH/tools_generator.sh
     
    # Update random secrets if env generation is enabled.
    if [[ ! "$IGNORE_SETTINGS" ]]; then 

        #Regenerate random secrets
        update_random_values_to_config;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    # Override user HollaEx Core tag if the flag is available.
    if [[ "$HOLLAEX_CORE_USER_APPLY_TAG" ]]; then
        
        override_user_docker_tag;

    fi

     if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]]; then 

        # Check Kit version compatibility range.
        check_kit_version_compatibility_range;
    
    fi 

    if [[ "$IGNORE_SETTINGS" ]]; then

        export ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE=false 

    fi 

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME"  ]] ; then
            printf "\033[91mError: Please define exchange name and Docker image version on config file before running HollaEx CLI.\033[39m\n"
            print_usage
            exit 1;
        fi

        check_empty_values_on_settings;

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            printf "\033[93mWarning: Exchange service will be unavailable during the restart!\033[39m\n"
            echo "Are you sure you want to restart $HOLLAEX_CONFIGMAP_API_NAME on this cluster? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        load_config_variables;

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE" == true ]]; then

            echo "Generating Kubernetes Configmap"
            generate_kubernetes_configmap;

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE" == true ]]; then

            echo "Generating Kubernetes Secret"
            generate_kubernetes_secret;

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_INGRESS_ENABLE" == true ]]; then

            echo "Generating Kubernetes Ingress"
            generate_kubernetes_ingress;

        fi

        # Only tries to attempt remove ingress rules from Kubernetes if it exists.
        if command kubectl get ingress -n $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then
        
            echo "Removing $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

        fi

        if [[ "$ENVIRONMENT_WEB_ENABLE" == true ]]; then

            echo "Removing ingress for web client on the namespace"
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

        fi

        if [[ ! "$IGNORE_SETTINGS" ]]; then

            echo "Applying latest configmap env on the cluster."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml

            echo "Applying latest secret on the cluster"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

        fi

        echo "Restarting all exchange containers on cluster"
        kubectl delete pods --namespace $ENVIRONMENT_EXCHANGE_NAME -l role=$ENVIRONMENT_EXCHANGE_NAME

        echo "Flushing Redis..."
        kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- node tools/dbs/flushRedis.js

        echo "Applying $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

        if [[ "$ENVIRONMENT_WEB_ENABLE" == true ]]; then

            echo "Applying ingress for web client on the namespace"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

        fi

        hollaex_ascii_exchange_is_up;

        exit 0;
    
    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            printf "\033[91mHollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI.\033[39m\n"
            
            exit 1;

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi

        check_empty_values_on_settings;

        if [[ "$RUN_WITH_VERIFY" == true ]]; then
            
            printf "\033[93mWarning: Exchange service will be unavailable during the restart!\033[39m\n"
            echo "Are you sure you want to restart $HOLLAEX_CONFIGMAP_API_NAME on your machine? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE" == true ]]; then

            echo "Generating env file for docker"
            load_config_variables;
            generate_local_env;

        fi

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then

            echo "Generating docker-compose file"
            generate_local_docker_compose

        fi

        # Generating nginx upstream.conf for exchange
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_NGINX_UPSTREAM" == true ]]; then

            echo "Generating Nginx upstream conf"
            generate_nginx_upstream
        
        fi
        
        # Update nginx.conf to apply user own domains
        echo "Updating nginx conf file based on user settings"
        apply_nginx_user_defined_values;

        # echo "Restarting containers to apply new changes..."
        # docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml stop
        # docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d

        echo "Flushing Redis..."
        IFS=',' read -ra CONTAINER_PREFIX <<< "-${ENVIRONMENT_EXCHANGE_RUN_MODE}"
        docker exec ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX[0]}_1 node tools/dbs/flushRedis.js
        
        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml stop; then

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d --remove-orphans; then
                
                hollaex_ascii_exchange_is_up;

            else 

                printf "\033[91mFailed to restart exchange! Please review your settings and try again.\033[39m\n"
                exit 1;
            fi

        else 

            printf "\033[91mFailed to restart exchange! Please review your settings and try again.\033[39m\n"
            exit 1;
        
        fi

        exit 0;

    fi

elif [[ "$1" == "build" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --user_image_registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_DOCKER_IMAGE_REGISTRY_OVERRIDE=$1
                echo "Target hollaex docker registry : $ENVIRONMENT_DOCKER_IMAGE_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --version)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE=$1
                echo "Target hollaex release version : v $ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE."
                shift; continue
                ;;
            --arch)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                if [[ "$1" == "amd64" ]] || [[ "$1" == "arm64v8" ]] || [[ "$1" == "s390x" ]]; then
                    export ENVIORNMENT_HOLLAEX_CPU_ARCH=$1
                    echo "Target CPU Arch: $ENVIORNMENT_HOLLAEX_CPU_ARCH."
                else 
                    echo -e "\n\033[91mError: Not supported CPU arch!\033[39m"
                    echo "Supported Arches: amd64, arm64v8, s390x."
                    echo -e "Please try it again with the supported arch name.\n"
                    exit 1;
                fi
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ "$ENVIORNMENT_HOLLAEX_CPU_ARCH" ]]; then 

        export ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE="$(echo ${ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE:-$ENVIRONMENT_DOCKER_IMAGE_VERSION} | cut -f1 -d "-")-${ENVIORNMENT_HOLLAEX_CPU_ARCH}"
    
    else 

        export ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE="$(echo ${ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE:-$ENVIRONMENT_DOCKER_IMAGE_VERSION} | cut -f1 -d "-")"

    fi 
    
    override_docker_image_version;

    export ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-core-${ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE}-$(date +%y%m%d%H%M)"

    build_user_hollaex_core;

    if [[ "$USER_HOLLAEX_CORE_PUSHED" ]]; then 

        export ENVIRONMENT_USER_REGISTRY_OVERRIDE=$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY
        export HOLLAEX_CORE_USER_APPLY_TAG=$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION
        override_user_docker_registry;
        override_user_docker_tag;

    fi

    printf "\nYou can apply the new image by running '\033[1mhollaex upgrade\033[0m'.\n"

elif [[ "$1" == "upgrade" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --user_image_registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_USER_REGISTRY_OVERRIDE=$1
                echo "User HollaEx Core image registry and version : $ENVIRONMENT_USER_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --version)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE=$1
                echo "Target HollaEx Core release version : v$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE."
                shift; continue
                ;;
             --no_image_build)
                NO_IMAGE_BUILD=true
                echo "Skipping the new image build."
                shift; continue
                ;;
            --ignore_settings)
                IGNORE_SETTINGS=true
                echo "HollaEx CLI will ignore local settings update on restart."
                shift; continue
                ;;
            --api_only)
                UPGRADE_API_ONLY=true
                echo "HollaEx CLI will rolling-upgrade API pods on Kubernetes."
                shift; continue
                ;;
            --plugins_only)
                UPGRADE_PLUGINS_ONLY=true
                echo "HollaEx CLI will rolling-upgrade plugins pods on Kubernetes."
                shift; continue
                ;;
            --arch)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                if [[ "$1" == "amd64" ]] || [[ "$1" == "arm64v8" ]] || [[ "$1" == "s390x" ]]; then
                    export ENVIORNMENT_HOLLAEX_CPU_ARCH=$1
                    echo "Target CPU Arch: $ENVIORNMENT_HOLLAEX_CPU_ARCH."
                else 
                    echo -e "\n\033[91mError: Not supported CPU arch!\033[39m"
                    echo "Supported Arches: amd64, arm64v8, s390x."
                    echo -e "Please try it again with the supported arch name.\n"
                    exit 1;
                fi
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    if [[ "$UPGRADE_API_ONLY" ]] || [[ "$UPGRADE_PLUGINS_ONLY" ]] && [[ ! "$USE_KUBERNETES" ]]; then

        echo "Error: '--api_only' and '--plugins_only' flags are only available for Kubernetes deployment."
        echo "If you are trying to target the Kubernetes cluster, please use '--kube' flag along your command."

        exit 1;

    fi 


    source $SCRIPTPATH/tools_generator.sh

    # Update random secrets if env generation is enabled.
    if [[ ! "$IGNORE_SETTINGS" ]]; then 

        #Regenerate random secrets
        update_random_values_to_config;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    load_config_variables;

    # Update HollaEx CLI to latest if there is newer release available.
    update_hollaex_cli_to_latest;

    if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]]; then

        echo "Checking the version compatibility between the latest HollaEx CLI and your local Kit..."
        if command curl -s -f https://raw.githubusercontent.com/bitholla/hollaex-cli/master/version_range > $SCRIPTPATH/.master_version_range; then 

            source $SCRIPTPATH/.master_version_range
            rm $SCRIPTPATH/.master_version_range

        else 

            printf "\n\033[91mError: Failed to read latest version compatibility range from the server.\n\033[39m"
            echo "Please check your internet connectivity and try it again."
            
            exit 1;

        fi

        # Check Kit version compatibility range.
        check_kit_version_compatibility_range;

        check_core_version_compatibility_range;

    fi

     # Override target docker registry if user passed it manually with flag.
    if [[ "$ENVIRONMENT_USER_REGISTRY_OVERRIDE" ]]; then
        
        override_user_docker_registry;
        
    fi
    
    # Override target docker image version if user passed it manually with flag / version range available at each CLI releases.  
    if [[ ! "$NO_IMAGE_BUILD" ]]; then   

        if [[ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE" ]]; then

            if [[ "$ENVIORNMENT_HOLLAEX_CPU_ARCH" ]]; then 
                
                export ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE=$HOLLAEX_CORE_MAXIMUM_COMPATIBLE-${ENVIORNMENT_HOLLAEX_CPU_ARCH}

            else 

                export ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE=$HOLLAEX_CORE_MAXIMUM_COMPATIBLE

            fi 
        fi 

        override_docker_image_version;
        export ENVIRONMENT_DOCKER_IMAGE_VERSION=$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE

        # Building new HollaEx Core image based on passed (or specified) version.
        export ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-core-${ENVIRONMENT_DOCKER_IMAGE_VERSION}-$(date +%y%m%d%H%M)"
        build_user_hollaex_core;
    
    fi

    if [[ "$IGNORE_SETTINGS" ]]; then

        export ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE=false 

    fi 

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME"  ]] ; then
            printf "\033[91mError: Please define exchange name and Docker image version on config file before running HollaEx CLI.\033[39m\n"
            print_usage
            exit 1;
        fi

        check_empty_values_on_settings;
        
        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            printf "\033[93mWarning: Exchange service will be unavailable during the upgrade!\033[39m\n"
            echo "Are you sure you want to upgrade $HOLLAEX_CONFIGMAP_API_NAME by using $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY:$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION with ${ENVIRONMENT_KUBERNETES_API_SERVER_REPLICAS:-1} api containers on this cluster? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE" == true ]]; then

            echo "Generating Kubernetes Configmap"
            generate_kubernetes_configmap;

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE" == true ]]; then

            echo "Generating Kubernetes Secret"
            generate_kubernetes_secret;

        fi


        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_INGRESS_ENABLE" == true ]]; then

            echo "Generating Kubernetes Ingress"
            generate_kubernetes_ingress;

        fi

        if [[ ! "$UPGRADE_API_ONLY" ]] && [[ ! "$UPGRADE_PLUGINS_ONLY" ]]; then 
        
            # Only tries to attempt remove ingress rules from Kubernetes if it exists.
            if command kubectl get ingress -n $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then
            
                echo "Removing $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
                kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

            fi

        fi

        if [[ ! "$IGNORE_SETTINGS" ]]; then 

            echo "Applying latest configmap env on the cluster."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml

            echo "Applying latest secret on the cluster"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

        fi

        if [[ "$ENVIRONMENT_WEB_ENABLE" == true ]]; then
        
            echo "Applying web client configmap on the namespace"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-web-configmap.yaml

        fi

        # FOR GENERATING NODESELECTOR VALUES
        generate_nodeselector_values ${ENVIRONMENT_KUBERNETES_EXCHANGE_STATEFUL_NODESELECTOR:-$ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR} hollaex-stateful
        generate_nodeselector_values ${ENVIRONMENT_KUBERNETES_EXCHANGE_STATELESS_NODESELECTOR:-$ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR} hollaex-stateless

        echo "Upgrading $HOLLAEX_CONFIGMAP_API_NAME Pods on Kubernetes."

        if [[ ! "$UPGRADE_PLUGINS_ONLY" ]]; then 

        helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-api \
                    --namespace $ENVIRONMENT_EXCHANGE_NAME \
                    --set DEPLOYMENT_MODE="api" \
                    --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY" \
                    --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION" \
                    --set stable.replicaCount="${ENVIRONMENT_KUBERNETES_API_SERVER_REPLICAS:-1}" \
                    --set autoScaling.hpa.enable="${ENVIRONMENT_KUBERNETES_API_HPA_ENABLE:-false}" \
                    --set autoScaling.hpa.avgMemory="${ENVIRONMENT_KUBERNETES_API_HPA_AVGMEMORY:-1300000000}" \
                    --set autoScaling.hpa.maxReplicas="${ENVIRONMENT_KUBERNETES_API_HPA_MAXREPLICAS:-4}" \
                    --set envName="$ENVIRONMENT_EXCHANGE_NAME-env" \
                    --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                    --set resources.limits.cpu="${ENVIRONMENT_KUBERNETES_API_CPU_LIMITS:-1000m}" \
                    --set resources.limits.memory="${ENVIRONMENT_KUBERNETES_API_MEMORY_LIMITS:-1536Mi}" \
                    --set resources.requests.cpu="${ENVIRONMENT_KUBERNETES_API_CPU_REQUESTS:-10m}" \
                    --set resources.requests.memory="${ENVIRONMENT_KUBERNETES_API_MEMORY_REQUESTS:-1536Mi}" \
                    --set podRestart_webhook_url="$ENVIRONMENT_KUBERNETES_RESTART_NOTIFICATION_WEBHOOK_URL" \
                    -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex-stateless.yaml \
                    -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server/values.yaml \
                    $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server

        fi 

        if [[ ! "$UPGRADE_API_ONLY" ]] && [[ ! "$UPGRADE_PLUGINS_ONLY" ]]; then 

            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-stream \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --set DEPLOYMENT_MODE="stream" \
                        --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY" \
                        --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION" \
                        --set stable.replicaCount="${ENVIRONMENT_KUBERNETES_STREAM_SERVER_REPLICAS:-1}" \
                        --set autoScaling.hpa.enable="${ENVIRONMENT_KUBERNETES_STREAM_HPA_ENABLE:-false}" \
                        --set autoScaling.hpa.avgMemory="${ENVIRONMENT_KUBERNETES_STREAM_HPA_AVGMEMORY:-300000000}" \
                        --set autoScaling.hpa.maxReplicas="${ENVIRONMENT_KUBERNETES_STREAM_HPA_MAXREPLICAS:-4}" \
                        --set envName="$ENVIRONMENT_EXCHANGE_NAME-env" \
                        --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                        --set resources.limits.cpu="${ENVIRONMENT_KUBERNETES_STREAM_CPU_LIMITS:-1000m}" \
                        --set resources.limits.memory="${ENVIRONMENT_KUBERNETES_STREAM_MEMORY_LIMITS:-1536Mi}" \
                        --set resources.requests.cpu="${ENVIRONMENT_KUBERNETES_STREAM_CPU_REQUESTS:-10m}" \
                        --set resources.requests.memory="${ENVIRONMENT_KUBERNETES_STREAM_MEMORY_REQUESTS:-1536Mi}" \
                        --set podRestart_webhook_url="$ENVIRONMENT_KUBERNETES_RESTART_NOTIFICATION_WEBHOOK_URL" \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex-stateless.yaml \
                        -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server/values.yaml \
                        $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server
        fi

        if [[ ! "$UPGRADE_API_ONLY" ]] || [[ "$UPGRADE_PLUGINS_ONLY" ]]; then 

        helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-plugins-controller \
                     --namespace $ENVIRONMENT_EXCHANGE_NAME \
                     --set DEPLOYMENT_MODE="plugins-controller" \
                     --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY" \
                     --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION" \
                     --set envName="$ENVIRONMENT_EXCHANGE_NAME-env" \
                     --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                     --set resources.limits.cpu="${ENVIRONMENT_KUBERNETES_PLUGINS_CPU_LIMITS:-1000m}" \
                     --set resources.limits.memory="${ENVIRONMENT_KUBERNETES_PLUGINS_MEMORY_LIMITS:-1536Mi}" \
                     --set resources.requests.cpu="${ENVIRONMENT_KUBERNETES_PLUGINS_CPU_REQUESTS:-10m}" \
                     --set resources.requests.memory="${ENVIRONMENT_KUBERNETES_PLUGINS_MEMORY_REQUESTS:-1536Mi}" \
                     --set podRestart_webhook_url="$ENVIRONMENT_KUBERNETES_RESTART_NOTIFICATION_WEBHOOK_URL" \
                     -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex-stateful.yaml \
                     -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server/values.yaml \
                     $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server

        fi 

        if [[ ! "$UPGRADE_API_ONLY" ]] && [[ ! "$UPGRADE_PLUGINS_ONLY" ]]; then 

            helm_dynamic_trading_paris run;

            # Running database job for Kubernetes
            kubernetes_database_init upgrade;

            echo "Flushing Redis..."
            kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- node tools/dbs/flushRedis.js

            echo "Restarting all containers to apply latest database changes..."
            kubectl delete pods --namespace $ENVIRONMENT_EXCHANGE_NAME -l role=$ENVIRONMENT_EXCHANGE_NAME

            echo "Waiting for the containers get fully ready..."
            sleep 15;
        

            echo "Applying $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml
        
        fi

        if [[ ! "$UPGRADE_API_ONLY" ]] && [[ ! "$UPGRADE_PLUGINS_ONLY" ]]; then 

            if [[ "$ENVIRONMENT_WEB_ENABLE" == true ]]; then

                echo "Applying ingress for web client on the namespace"
                kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

            fi

        fi

        hollaex_ascii_exchange_has_been_upgraded;

        exit 0;
    
    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi

        check_empty_values_on_settings;

        if [[ "$RUN_WITH_VERIFY" == true ]]; then
            
            printf "\033[93mWarning: Exchange service will be unavailable during the upgrade!\033[39m\n"
            echo "Are you sure you want to upgrade $HOLLAEX_CONFIGMAP_API_NAME on your machine? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        # Override target docker image version If user passed it manually with flag.
        if [[ "$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE" ]]; then
            
            override_docker_image_version;
            ENVIRONMENT_DOCKER_IMAGE_VERSION=$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE
            
        fi

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE" == true ]]; then

            echo "Generating env file for docker"
            generate_local_env;

        fi

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then
            
            echo "Generating docker-compose file"
            generate_local_docker_compose

        fi

        # Generating nginx upstream.conf for exchange
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_NGINX_UPSTREAM" == true ]]; then

            echo "Generating Nginx upstream conf"
            generate_nginx_upstream
        
        fi
        
        if [[ "$ENVIRONMENT_CUSTOM_PLUGINS_AUTOCONFIGURE_ENABLE" == "true" ]]; then

            generate_nginx_config_for_plugin;

        elif [[ "$ENVIRONMENT_CUSTOM_PLUGINS_AUTOCONFIGURE_ENABLE" == "false" ]]; then

            rm -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/plugins.conf

        fi
        
        # Update nginx.conf to apply user own domains
        echo "Updating nginx conf file based on user settings"
        apply_nginx_user_defined_values;

        echo "Restarting containers to apply new changes..."
        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d --build; then

            RUN_WITH_VERIFY=false
            local_database_init upgrade;

            echo "Flushing Redis..."
            IFS=',' read -ra CONTAINER_PREFIX <<< "-${ENVIRONMENT_EXCHANGE_RUN_MODE}"
            docker exec ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX[0]}_1 node tools/dbs/flushRedis.js

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml restart; then

                hollaex_ascii_exchange_has_been_upgraded;
            
            else 

                printf "\033[91mFailed to upgrade exchange! Please review your settings and try again.\033[39m\n"
                exit 1;

            fi

        else

            printf "\033[91mFailed to upgrade exchange! Please review your settings and try again.\033[39m\n"
            exit 1;

        fi

        exit 0;

    fi

elif [[ "$1" == "terminate" ]]; then

     while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
     done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]]; then 

        # Check Kit version compatibility range.
        check_kit_version_compatibility_range;
    
    fi 

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to terminate $HOLLAEX_CONFIGMAP_API_NAME on this cluster? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

         # Only tries to attempt remove ingress rules from Kubernetes if it exists.
        if command kubectl get ingress -n $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then
        
            echo "Removing $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

        fi

        echo "Removing helm packages on the cluster."
        helm uninstall --namespace $ENVIRONMENT_EXCHANGE_NAME $ENVIRONMENT_EXCHANGE_NAME-server-api
        helm uninstall --namespace $ENVIRONMENT_EXCHANGE_NAME $ENVIRONMENT_EXCHANGE_NAME-server-stream
        helm uninstall --namespace $ENVIRONMENT_EXCHANGE_NAME $ENVIRONMENT_EXCHANGE_NAME-server-plugins-controller

        helm_dynamic_trading_paris terminate;

        helm uninstall --namespace $ENVIRONMENT_EXCHANGE_NAME $ENVIRONMENT_EXCHANGE_NAME-redis 
        helm uninstall --namespace $ENVIRONMENT_EXCHANGE_NAME $ENVIRONMENT_EXCHANGE_NAME-db
        helm uninstall --namespace $ENVIRONMENT_EXCHANGE_NAME $ENVIRONMENT_EXCHANGE_NAME-influxdb

        #Remove web server together if it exists on same namespace.
        if command helm ls | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null ; then
            
            helm uninstall --namespace $ENVIRONMENT_EXCHANGE_NAME $ENVIRONMENT_EXCHANGE_NAME-web

        fi

        echo "Removing $HOLLAEX_CONFIGMAP_API_NAME namespace."
        kubectl delete ns $ENVIRONMENT_EXCHANGE_NAME

        hollaex_ascii_exchange_has_been_terminated;

        echo "$HOLLAEX_CONFIGMAP_API_NAME ($HOLLAEX_CONFIGMAP_API_HOST) has been successfully terminated."
        echo "If there's an issue, please review the logs and try it again."
        printf "\nBye!\n\n"

        exit 0;

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to terminate $HOLLAEX_CONFIGMAP_API_NAME on your machine? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml down --remove-orphans -v

        # Remove web server together if it exists.
        if [[ -f "$TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml" ]] ; then

            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client down 
        fi

        hollaex_ascii_exchange_has_been_terminated;

        echo "$HOLLAEX_CONFIGMAP_API_NAME ($HOLLAEX_CONFIGMAP_API_HOST) has been successfully terminated."
        echo "If there's an issue, please review the logs and try it again."
        printf "\nBye!\n\n"

        exit 0;

    fi

elif [[ "$1" == "web" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "Setting target to Kubernetes..."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --setup)
                WEB_CLIENT_SETUP=true
                shift; continue
                ;;
            --start)
                WEB_CLIENT_START=true
                shift; continue
                ;;
            --stop)
                WEB_CLIENT_STOP=true
                shift; continue
                ;;
            --restart)
                WEB_CLIENT_RESTART=true
                shift; continue
                ;;
            --build)
                WEB_CLIENT_REBUILD=true
                shift; continue
                ;;
            --terminate)
                WEB_CLIENT_TERMINATE=true
                shift; continue
                ;;
            # Build related
            --user_image_registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE=$1
                echo "Target hollaex docker registry : $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --arch)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                if [[ "$1" == "amd64" ]] || [[ "$1" == "arm64v8" ]] || [[ "$1" == "s390x" ]]; then
                    export ENVIORNMENT_HOLLAEX_CPU_ARCH=$1
                    echo "Target CPU Arch: $ENVIORNMENT_HOLLAEX_CPU_ARCH."
                else 
                    echo -e "\n\033[91mError: Not supported CPU arch!\033[39m"
                    echo "Supported Arches: amd64, arm64v8, s390x."
                    echo -e "Please try it again with the supported arch name.\n"
                    exit 1;
                fi
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    # Setting web operation enabled command to true.
    ENVIRONMENT_WEB_ENABLE=true

    if [[ ! "$USE_KUBERNETES" ]]; then

         if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi
    
    elif [[ "$USE_KUBERNETES" ]]; then

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

    fi
    
    # Multi arch build support
    if [[ "$ENVIORNMENT_HOLLAEX_CPU_ARCH" ]]; then 
    
        ENVIRONMENT_WEB_NGINX_VERSION=$(cat $HOLLAEX_CLI_INIT_PATH/web/docker/Dockerfile | grep "FROM.*nginx:" | cut -f2 -d ":")

        # Overriding the base image with the env value
        sed -i.bak "s/FROM .*nginx.*/FROM ${ENVIORNMENT_HOLLAEX_CPU_ARCH}\/nginx:${ENVIRONMENT_WEB_NGINX_VERSION}/" $HOLLAEX_CLI_INIT_PATH/web/docker/Dockerfile

        rm $HOLLAEX_CLI_INIT_PATH/web/docker/Dockerfile.bak*

    fi

    # hollaex web --setup
    if [[ "$WEB_CLIENT_SETUP" ]]; then

        if [[ "$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE" ]]; then 
        
            export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY=$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE
        
        fi 

        export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-web-$(cat version)-$(date +%y%m%d%H%M)"
        build_user_hollaex_web;

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            #Verify remote Kubernetes cluster is correct.
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to setup the web server on this cluster? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi
            
            # Web server installation status checking.
            if command helm ls | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null 2>&1; then

                printf "\033[91m\nError: You already installed the web server on your Kuberentes cluster!\033[39m\n"
                echo "To start it, Please run 'hollaex web --start --kube' command instead."

                exit 1;
            
            fi

            #Creating kubernetes_config directory for generating config for Kubernetes.
            if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
                mkdir $TEMPLATE_GENERATE_PATH/kubernetes;
                mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
            fi

            echo "Generating web ingress rules for Kubernetes"
            generate_kubernetes_ingress_for_web;

            echo "Applying web ingress rules for Kubernetes"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

            
            # Create docker registry secret on Kubernetes.
            if ! command kubectl get secret docker-registry-secret --namespace $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then

                create_kubernetes_docker_registry_secret;
            
            fi

            # FOR GENERATING NODESELECTOR VALUES
            generate_nodeselector_values ${ENVIRONMENT_KUBERNETES_EXCHANGE_STATELESS_NODESELECTOR:-$ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR} hollaex-stateless

            echo "Running the web server on Kubernetes..."
            if command helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-web \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY" \
                        --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION" \
                        --set stable.replicaCount="${ENVIRONMENT_KUBERNETES_WEB_SERVER_REPLICAS:-1}" \
                        --set autoScaling.hpa.enable="${ENVIRONMENT_KUBERNETES_WEB_HPA_ENABLE:-false}" \
                        --set autoScaling.hpa.avgMemory="${ENVIRONMENT_KUBERNETES_WEB_HPA_AVGMEMORY:-500000000}" \
                        --set autoScaling.hpa.maxReplicas="${ENVIRONMENT_KUBERNETES_WEB_HPA_MAXREPLICAS:-4}" \
                        --set resources.limits.cpu="${ENVIRONMENT_KUBERNETES_WEB_CPU_LIMITS:-1000m}" \
                        --set resources.limits.memory="${ENVIRONMENT_KUBERNETES_WEB_MEMORY_LIMITS:-1024Mi}" \
                        --set resources.requests.cpu="${ENVIRONMENT_KUBERNETES_WEB_CPU_REQUESTS:-2m}" \
                        --set resources.requests.memory="${ENVIRONMENT_KUBERNETES_WEB_MEMORY_REQUESTS:-100Mi}" \
                        --set envName="$ENVIRONMENT_EXCHANGE_NAME-web-env" \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex-stateless.yaml \
                        -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-web/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-web; then


                echo "Scaling down the web server after the initialization..."
                hollaex web --stop --kube --skip

                hollaex_ascii_web_server_has_been_setup;
            
            else 

                printf "\n\033[91mFailed to setup the web server on the Kubernetes!\033[39m\n"
                echo "Please review the logs and try again."

                helm uninstall --namespace $ENVIRONMENT_EXCHANGE_NAME $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null;

                exit 1;

            fi

            exit 0;
        
        elif [[ ! "$USE_KUBERNETES" ]]; then

            # Checking docker-compose is installed on this machine.
            check_docker_compose_is_installed;

            # if [[ "$RUN_WITH_VERIFY" == true ]]; then

            #     echo "Are you sure you want to setup the web server on this machine? (Y/n)"

            #     read answer

            #     if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
            #         echo "Exiting..."
            #         exit 0;
            #     fi

            # fi

            echo "Generating web docker-compose file"
            generate_local_docker_compose_for_web

            echo "Generating web .env file"
            generate_hollaex_web_local_env

            if [[ ! -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]] || [[ ! -s "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]]; then

                if [[ -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf" ]] && [[ -s "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf" ]]; then

                    echo "Restoring old web Nginx configuration file"
                    cp -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf

                    rm $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf

                else

                    echo "Generating web Nginx configuration file"
                    generate_hollaex_web_local_nginx_conf
                
                fi

            fi

            echo "Generating web Nginx upstream file"
            generate_nginx_upstream_for_web

            echo "Updating main Nginx.conf based on user settings..."
            apply_nginx_user_defined_values

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client up -d; then

                echo "Reloading Nginx..."
                if command docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload; then
                
                    printf "\n\033[92mSuccessfully reloaded the Nginx\033[39m\n"
        
                else

                    printf "\033[93mFailed to reload Nginx. Please make sure to start the exchange API server first.\033[39m\n"
                    echo "The web server could be still reachable through 'http://localhost:8080',"
                    echo "But the allocated domain for the web would not function correctly."

                fi

                hollaex web --stop --skip

                hollaex_ascii_web_server_has_been_setup;

            else 

                printf "\n\033[91mError: Failed to restart the web server.\033[39m\n"
                echo "Please review the logs and try again."
                exit 1;
            
            fi

            exit 0;

        fi

        exit 0;

    fi

    if [[ "$WEB_CLIENT_START" ]]; then

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            #Verify remote Kubernetes cluster is correct.
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            # if [[ "$RUN_WITH_VERIFY" == true ]]; then

            #     echo "Are you sure you want to start (scale up) the web server on this cluster? (Y/n)"

            #     read answer

            #     if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
            #         echo "Exiting..."
            #         exit 0;
            #     fi

            # fi
            
            # Web server installation status checking.
            if ! command helm ls | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null 2>&1; then

                printf "\033[91mFailed to detect the web server installed on your Kubernetes cluster.\033[39m\n"
                echo "If you haven't launched the web server yet, Please run 'hollaex web --setup --kube' to set it up first."

                exit 1;
            
           fi

            echo "Generating web ingress rules for Kubernetes"
            generate_kubernetes_ingress_for_web;

            echo "Applying web ingress rules for Kubernetes"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml


            if ! command kubectl get secret docker-registry-secret --namespace $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then

                create_kubernetes_docker_registry_secret;
            
            fi

            echo "Starting (Scaling up) the web server on Kubernetes..."
            if command kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-web --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1 ; then

                hollaex_ascii_web_server_is_up;
            
            else 

                printf "\033[91mFailed to start the web on your Kubernetes cluster!033[39m\n"
                echo "Please review the logs and try again."

                exit 1;

            fi
        

        elif [[ ! "$USE_KUBERNETES" ]]; then

            if ! command docker images | grep $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY > /dev/null && command docker images | grep $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION > /dev/null; then

                echo "Error: Can't detect built web docker image on this machine!"
                echo "If this is your first time launching the web server, please run 'hollaex web --setup' instead."
                echo "You can also build the image manually by using 'hollaex web --build' command."

                exit 1;
              
            fi

            # Checking docker-compose is installed on this machine.
            check_docker_compose_is_installed;

            # if [[ "$RUN_WITH_VERIFY" == true ]]; then

            #     echo "Are you sure you want to start the web client on this machine? (Y/n)"

            #     read answer

            #     if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
            #         echo "Exiting..."
            #         exit 0;
            #     fi

            # fi

            if ! command docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null 2>&1; then

                printf "\033[91m\nError: Failed to detect stopped web server on this machine.\033[39m\n"
                echo "If you haven't setup the web server yet, Please run 'hollaex web --setup' first."

                exit 1;

            fi

            echo "Generating web docker-compose file"
            generate_local_docker_compose_for_web

            if [[ ! -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]] || [[ ! -s "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]]; then

                if [[ -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf" ]] && [[ -s "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf" ]]; then

                    echo "Restoring old web Nginx configuration file"
                    cp -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf

                    rm $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf

                else

                    echo "Generating web Nginx configuration file"
                    generate_hollaex_web_local_nginx_conf
                
                fi

            fi

            echo "Updating main Nginx.conf based on user settings..."
            apply_nginx_user_defined_values

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client start; then

                echo "Reloading Nginx..."
                if command docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload; then
                
                    printf "\n\033[92mSuccessfully reloaded the Nginx\033[39m\n"
        
                else

                    printf "\033[93mFailed to reload Nginx. Please make sure to start the exchange API server first.\033[39m\n"
                    echo "The web server could be still reachable through 'http://localhost:8080',"
                    echo "But the allocated domain for the web would not function correctly."

                fi

                hollaex_ascii_web_server_is_up;

            else 

                printf "\n\033[91mError: Failed to restart the web server.\033[39m\n"
                echo "Please review your settings and try again."
                exit 1;
            
            fi

            exit 0;

        fi
    fi

    if [[ "$WEB_CLIENT_STOP" ]]; then

        if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        echo "*********************************************"
        #Verify remote Kubernetes cluster is correct.
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to stop (scale down) the web server on this cluster? (Y/n)"

            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        # Web server installation status checking.
        echo "Checking the web installation status on your Kubernetes..."
        if ! command helm ls | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null 2>&1; then

            printf "\033[91mFailed to detect the web server installed on your Kubernetes cluster.\033[39m\n"
            echo "If you haven't launched the web server yet, Please run 'hollaex web --setup --kube' to set it up first."

            exit 1;
        
        fi

        echo "Removing web ingress rules from the Kubernetes"
        kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

        echo "Stopping (Scaling down) the web server..."
        if command kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-web --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME; then

            printf "\n\033[92mSuccessfully stopped the web server.\033[39m\n"
            echo "To bring it up, Please run 'hollaex web --start --kube' command".
        
        else 

            printf "\033[91m\nError: Failed to stop the web server on the Kubernetes.\033[39m\n"
            echo "Please review the logs and try again."

            exit 1;
        
        fi
    
        elif [[ ! "$USE_KUBERNETES" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to stop the web client on this machine? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Generating web docker-compose file"
            generate_local_docker_compose_for_web

            echo "Cleaning up the web Nginx configuration..."
            cp -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf
            rm $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client stop; then

                echo "Reloading Nginx..."
                if command docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload; then
                
                    printf "\n\033[92mSuccessfully reloaded the Nginx\033[39m\n"
        
                else

                    printf "\033[93mFailed to reload Nginx. Please make sure to start the exchange API server first.\033[39m\n"

                fi

                printf "\n\033[92mSuccessfully stopped the web server.\033[39m\n"
                echo "To bring it up, Please run 'hollaex web --start' command".

            else 

                printf "\n\033[91mError: Failed to stop the web server.\033[39m\n"
                echo "Please review your settings and try again."
                exit 1;
            
            fi

        fi

        exit 0;
        
    fi

    if [[ "$WEB_CLIENT_RESTART" ]]; then

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            if command docker images | grep $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY > /dev/null && command docker images | grep $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION > /dev/null; then

                printf "\nPre-built image for web server has been detected on your system.\n"
                echo "You should build the image again if you made code changes for web."
                echo "Plase input 'Y' to skip the build, 'N' to build the image again."
                echo "Do you want to proceed with the pre-built image? (Y/n)"
                read answer 

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then

                    export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-web-$(cat version)-$(date +%y%m%d%H%M)"
                    echo "Building the web server image..."
                    build_user_hollaex_web;
                
                else 

                    echo "Proceeding..."
                
                fi
            
            else 

                export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-web-$(cat version)-$(date +%y%m%d%H%M)"
                echo "Building the web server image..."
                build_user_hollaex_web;

            fi

        else 

            export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-web-$(cat version)-$(date +%y%m%d%H%M)"
            echo "Building the web server image..."
            build_user_hollaex_web;

        fi

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            #Verify remote Kubernetes cluster is correct.
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to restart web client for the exchange on this cluster? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Generating web ingress rules for Kubernetes"
            generate_kubernetes_ingress_for_web;

            echo "Applying web ingress rules for Kubernetes"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml
            
            # FOR GENERATING NODESELECTOR VALUES
            generate_nodeselector_values ${ENVIRONMENT_KUBERNETES_EXCHANGE_STATELESS_NODESELECTOR:-$ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR} hollaex-stateless

            echo "Restarting the $HOLLAEX_CONFIGMAP_API_NAME web server."
            if command helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-web \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY" \
                        --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION" \
                        --set stable.replicaCount="${ENVIRONMENT_KUBERNETES_WEB_SERVER_REPLICAS:-1}" \
                        --set autoScaling.hpa.enable="${ENVIRONMENT_KUBERNETES_WEB_HPA_ENABLE:-false}" \
                        --set autoScaling.hpa.avgMemory="${ENVIRONMENT_KUBERNETES_WEB_HPA_AVGMEMORY:-500000000}" \
                        --set autoScaling.hpa.maxReplicas="${ENVIRONMENT_KUBERNETES_WEB_HPA_MAXREPLICAS:-4}" \
                        --set envName="$ENVIRONMENT_EXCHANGE_NAME-web-env" \
                        --set resources.limits.cpu="${ENVIRONMENT_KUBERNETES_WEB_CPU_LIMITS:-1000m}" \
                        --set resources.limits.memory="${ENVIRONMENT_KUBERNETES_WEB_MEMORY_LIMITS:-1024Mi}" \
                        --set resources.requests.cpu="${ENVIRONMENT_KUBERNETES_WEB_CPU_REQUESTS:-2m}" \
                        --set resources.requests.memory="${ENVIRONMENT_KUBERNETES_WEB_MEMORY_REQUESTS:-100Mi}" \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex-stateless.yaml \
                        -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-web/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-web; then

                # Scaling up the web in case of it gets already scaled down.
                kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-web --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

                echo -e "\n\033[92mSuccessfully restarted the web server on the Kubernetes!\033[39m\n"

                hollaex_ascii_web_server_is_up;
               
            else 

                printf "\033[91mFailed to restart the web server.\033[39m\n"
                echo "Please review the logs and try agian."
                exit 1;

            fi

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_is_installed;

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to restart web client for the exchange on this machine? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi
                
            fi

            echo "Generating web docker-compose file"
            generate_local_docker_compose_for_web

            echo "Generating web .env file"
            generate_hollaex_web_local_env

            if [[ ! -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]]; then

                echo "Generating web Nginx configuration file"
                generate_hollaex_web_local_nginx_conf

            fi

            echo "Updating main Nginx.conf based on user settings..."
            apply_nginx_user_defined_values

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client stop; then
                
                docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client up -d

                echo "Reloading Nginx..."
                if command docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload; then
                
                    printf "\n\033[92mSuccessfully reloaded the Nginx\033[39m\n"
        
                else

                    printf "\033[93mFailed to reload Nginx. Please make sure to start the exchange API server first.\033[39m\n"
                    echo "The web server could be still reachable through 'http://localhost:8080',"
                    echo "But the allocated domain for the web would not function correctly."

                fi

                hollaex_ascii_web_server_is_up;

            else 

                printf "\n\033[91mError: Failed to restart the web server.\033[39m\n"
                echo "Please review your settings and try again."
                exit 1;
            
            fi

            exit 0;

        fi
    fi

    if [[ "$WEB_CLIENT_REBUILD" ]];  then
        
        export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-web-$(cat version)-$(date +%y%m%d%H%M)"
        build_user_hollaex_web;

        exit 0;

    fi

    if [[ "$WEB_CLIENT_TERMINATE" ]]; then

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            #Verify remote Kubernetes cluster is correct.
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to terminate the web server on this cluster? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Removing web ingress rule on the cluster"
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

            echo "Removing the web server..."
            if command helm uninstall --namespace $ENVIRONMENT_EXCHANGE_NAME $ENVIRONMENT_EXCHANGE_NAME-web; then

                printf "\n\033[92mWeb server has been successfully terminated.\033[39m\n"
                echo "Please run 'hollaex web --setup --kube' if you want to set it up again."
            
            else 

                printf "\033[91mFailed to terminate the web server from the Kubernetes.\033[39m\n"
                echo "Please review the logs and try agian."
                exit 1;

            fi

            exit 0;
                

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_is_installed;

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to terminate the web client on this machine? (y/N)"
                echo "This can't be undo."

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Cleaning up the web Nginx configuration..."
            cp -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf
            rm $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client down --remove-orphans; then

                echo "Reloading Nginx..."
                if command docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload; then
                
                    printf "\n\033[92mSuccessfully reloaded the Nginx\033[39m\n"
        
                else

                    printf "\033[93mFailed to reload Nginx. Please make sure to start the exchange API server first.\033[39m\n"

                fi

                printf "\n\033[92mThe web server has been successfully terminated.\033[39m\n"
                echo "Please run 'hollaex web --setup' to set it up again."

            else 

                printf "\033[91mHollaEx CLI failed to terminate the web server. Please review your settings and try again.\033[39m\n"
                exit 1;
            
            fi

            exit 0;

        fi
    fi

elif [[ "$1" == "toolbox" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --dev)
                IS_DEVELOP=true
                echo "HollaEx CLI is configured as dev mode for development purpose."
                shift; continue
                ;;
            --upgrade_backends)
                UPGRADE_BACKENDS=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will upgrade your backends (PostgreSQL, Redis, InfluxDB) based on your settings files value."
                shift; continue
                ;;
            --backup)
                BACKUP_POSTGRESQL=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will run PostgreSQL database dump on your initialized exchange folder."
                shift; continue
                ;;
            --set_backup_cronjob)
                KUBERNETES_SET_BACKUP_POSTGRESQL_CRONJOB=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will install PostgreSQL database dump cronjob on your Kubernetes cluster."
                shift; continue
                ;;
            --flush_redis)
                FLUSH_REDIS=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will run full flush of Redis stored data. This could be helpful in certain situation If the exchange doesnt work properly."
                shift; continue
                ;;
            --add_coin)
                ADD_COIN=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to add new coin on your existing exchange."
                shift; continue
                ;;
            --add_trading_pair)
                ADD_TRADING_PAIR=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to add new trading pair on your existing exchange."
                shift; continue
                ;;
            --remove_coin)
                REMOVE_COIN=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to remove coin on your existing exchange."
                shift; continue
                ;;
            --remove_trading_pair)
                REMOVE_TRADING_PAIR=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to remove trading pair on your existing exchange."
                shift; continue
                ;;
            --coin_symbol)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                IS_COIN_SYMBOL_PASSED=true
                PASSED_COIN_SYMBOL=$1
                shift; continue
                ;;
             --pair_name)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                IS_PAIR_NAME_PASSED=true
                PASSED_PAIR_NAME=$1
                shift; continue
                ;;
            --is_hollaex_setup)
                IS_HOLLAEX_SETUP=true
                shift; continue
                ;;
            # --reconfigure_basic_settings)
            #     RECONFIGURE_BASIC_SETTINGS=true
            #     TOOLBOX_ENABLE=true
            #     echo "HollaEx CLI will proceed to reconfigure your exchange's basic settings."
            #     shift; continue
            #     ;;
            # --reactivate_exchange)
            #     REACTIVATE_EXCHANGE=true
            #     TOOLBOX_ENABLE=true
            #     echo "HollaEx CLI will proceed to reactivate your exchange with new activate information."
            #     shift; continue
            #     ;;
            --issue_ssl)
                ISSUE_SSL_CERT=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to issue SSL certificate by using Let's Encrypt for local exchange."
                shift; continue
                ;;
            --renew_ssl)
                RENEW_SSL_CERT=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to renew SSL certificate by using Let's Encrypt for local exchange."
                shift; continue
                ;;
             --update_registry_secret)
                UPDATE_REGISTRY_SECRET=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will update your docker image registry secret for Kubernetes."
                shift; continue
                ;;
            --set_activation_code)
                SET_ACTIVATION_CODE=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will update your activation code for the exchange."
                shift; continue
                ;;
            --check_constants)
                CHECK_CONSTANTS=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will check and update your database constants."
                shift; continue
                ;;
            --set_config)
                SET_CONFIG=true
                TOOLBOX_ENABLE=true
                echo "Override database-stored cosntants with local configmap-stored values."
                shift; continue
                ;;
            --set_security)
                set_security=true
                TOOLBOX_ENABLE=true
                echo "Override exchange secret values with provided ones."
                shift; continue
                ;;
             --connect_database)
                CONNECT_DATABASE=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will open a direct connection to your PostgreSQL database via postgresql-client."
                shift; continue
                ;;
             --connect_redis)
                CONNECT_REDIS=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will open a direct connection to your PostgreSQL database via redis-client."
                shift; continue
                ;;
             --connect_influxdb)
                CONNECT_INFLUXDB=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will open a direct connection to your PostgreSQL database via influx-client."
                shift; continue
                ;;
            --install_cli)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                INSTALL_CLI_ENABLE=true
                INSTALL_CLI_TARGET=$1
                TOOLBOX_ENABLE=true
                shift; continue
                ;;
            --influxdb_migration)
                INFLUXDB_MIGRATION=true
                TOOLBOX_ENABLE=true
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    # For dev command legacy mode
    if [[ "$HOLLAEX_DEV_FOR_CORE" ]]; then

        HOLLAEX_CODEBASE_PATH=$(pwd)

        HOLLAEX_CLI_INIT_PATH=$HOLLAEX_KIT_PATH
        CONFIG_FILE_PATH=$HOLLAEX_KIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_KIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_KIT_PATH/.hollaex

    fi

    # PATH overriding for develop    
    if [[ "$IS_DEVELOP" ]]; then

        if [[ "$HOLLAEX_CODEBASE_PATH" ]]; then

            CONFIG_FILE_PATH=$HOLLAEX_CODEBASE_PATH/tools/hollaex-cli-settings/*
            TEMPLATE_GENERATE_PATH=$HOLLAEX_CODEBASE_PATH/tools/hollaex-cli-templates
            INIT_PATH_CHECK=$HOLLAEX_CODEBASE_PATH/.hollaex

        elif [[ ! "$HOLLAEX_CODEBASE_PATH" ]]; then

            CONFIG_FILE_PATH=$(pwd)/tools/hollaex-cli-settings/*
            TEMPLATE_GENERATE_PATH=$(pwd)/tools/hollaex-cli-templates
            INIT_PATH_CHECK=$(pwd)/.hollaex
            HOLLAEX_CODEBASE_PATH=$(pwd)

        fi

    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    if [[ ! "$TOOLBOX_ENABLE" ]]; then
    
        print_usage;
        echo "No features are enabled for toolbox. Please recheck the command."
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    #Creating kubernetes_config directory for generating config for Kubernetes.
    if [[ "$USE_KUBERNETES" ]]; then 
        
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes;
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! -f "$TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex-stateful.yaml" ]]; then

            generate_nodeselector_values ${ENVIRONMENT_KUBERNETES_EXCHANGE_STATEFUL_NODESELECTOR:-ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR} hollaex-stateful

        fi

    else 

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi

    fi

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        echo "*********************************************"
        #Verify remote Kubernetes cluster is correct.
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

    fi

    # Features
    if [[ "$UPGRADE_BACKENDS" ]]; then 

        printf "\033[93mWarning: Exchange service will be unavailable during the upgrade!\033[39m\n"

        echo "All workload containers will be restarted once the upgrade process is done."
    
        if [[ "$USE_KUBERNETES" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to upgrade backends (PostgreSQL, Redis, InfluxDB) to latest compatible on this cluster? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Deleting Ingress rules for the exchange..."
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

            
            if [[ "$ENVIRONMENT_KUBERNETES_RUN_POSTGRESQL_DB" ]]; then

                echo "Upgrading PostgreSQL DB"
                generate_nodeselector_values $ENVIRONMENT_KUBERNETES_POSTGRESQL_DB_NODESELECTOR postgresql

                helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-db \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --set pvc.create=true \
                        --set pvc.name="$ENVIRONMENT_EXCHANGE_NAME-postgres-volume" \
                        --set pvc.size="$ENVIRONMENT_KUBERNETES_POSTGRESQL_DB_VOLUMESIZE" \
                        --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                        --set resources.limits.cpu="${ENVIRONMENT_KUBERNETES_POSTGRESQL_CPU_LIMITS:-100m}" \
                        --set resources.limits.memory="${ENVIRONMENT_KUBERNETES_POSTGRESQL_MEMORY_LIMITS:-200Mi}" \
                        --set resources.requests.cpu="${ENVIRONMENT_KUBERNETES_POSTGRESQL_CPU_REQUESTS:-10m}" \
                        --set resources.requests.memory="${ENVIRONMENT_KUBERNETES_POSTGRESQL_MEMORY_REQUESTS:-100Mi}" \
                        -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres/values.yaml \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-postgresql.yaml \
                        $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres $(kubernetes_set_backend_image_target $ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_VERSION) $(set_nodeport_access $ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_POSTGRESQL_DB_ACCESS $ENVIRONMENT_KUBERNETES_EXTERNAL_POSTGRESQL_DB_ACCESS_PORT)

            fi

            if [[ "$ENVIRONMENT_KUBERNETES_RUN_REDIS" ]]; then

                echo "Upgrading Redis"
                generate_nodeselector_values $ENVIRONMENT_KUBERNETES_REDIS_NODESELECTOR redis

                helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-redis \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --set setAuth.secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                        --set resources.limits.cpu="${ENVIRONMENT_KUBERNETES_REDIS_CPU_LIMITS:-100m}" \
                        --set resources.limits.memory="${ENVIRONMENT_KUBERNETES_REDIS_MEMORY_LIMITS:-200Mi}" \
                        --set resources.requests.cpu="${ENVIRONMENT_KUBERNETES_REDIS_CPU_REQUESTS:-10m}" \
                        --set resources.requests.memory="${ENVIRONMENT_KUBERNETES_REDIS_MEMORY_REQUESTS:-100Mi}" \
                        $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-redis $(kubernetes_set_backend_image_target $ENVIRONMENT_DOCKER_IMAGE_REDIS_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_REDIS_VERSION) $(set_nodeport_access $ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_REDIS_ACCESS $ENVIRONMENT_KUBERNETES_EXTERNAL_REDIS_ACCESS_PORT)

            fi

            if [[ "$ENVIRONMENT_KUBERNETES_RUN_INFLUXDB" ]]; then
                
                echo "Upgrading InfluxDB"
                generate_nodeselector_values $ENVIRONMENT_KUBERNETES_INFLUXDB_NODESELECTOR influxdb

                helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-influxdb \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --set setCustomUser.enabled="true" \
                        --set setCustomUser.secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                        --set persistence.size="$ENVIRONMENT_KUBERNETES_INFLUXDB_VOLUMESIZE" \
                        --set resources.limits.cpu="${ENVIRONMENT_KUBERNETES_INFLUXDB_CPU_LIMITS:-200m}" \
                        --set resources.limits.memory="${ENVIRONMENT_KUBERNETES_INFLUXDB_MEMORY_LIMITS:-400Mi}" \
                        --set resources.requests.cpu="${ENVIRONMENT_KUBERNETES_INFLUXDB_CPU_REQUESTS:-100m}" \
                        --set resources.requests.memory="${ENVIRONMENT_KUBERNETES_INFLUXDB_MEMORY_REQUESTS:-256Mi}" \
                        -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-influxdb/values.yaml \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-influxdb.yaml \
                        $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-influxdb $(kubernetes_set_backend_image_target is_influxdb $ENVIRONMENT_DOCKER_IMAGE_INFLUXDB_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_INFLUXDB_VERSION)
            fi

            echo "Restarting all workload containers..."
            kubectl delete pods --namespace $ENVIRONMENT_EXCHANGE_NAME -l role=$ENVIRONMENT_EXCHANGE_NAME

            sleep 10;

            echo "Applying Ingress rules for the exchange..."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

            exit 0;

        elif [[ ! "$USE_KUBERNETES" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to upgrade backends (PostgreSQL, Redis, InfluxDB) to latest compatible on this machine? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "All workload containers will be restarted once the upgrade process is done."

            echo "Regenerating docker-compose file..."
            generate_local_docker_compose $ENVIRONMENT_EXCHANGE_RUN_MODE

            echo "Restarting containers..."
            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d

            exit 0;

        fi

    elif [[ "$BACKUP_POSTGRESQL" ]]; then

        # Check pg_dump is available on your local
        if command pg_dumpall --version > /dev/null 2>&1; then

            echo "pg_dump detected on your machine!"
            pg_dumpall --version

        else 

            echo "HollaEx CLI failed to detect pg_dump on your machine"
            echo "Please make sure that you already installed pg_dump"

            exit 1;

        fi 

        if [[ ! -d $HOLLAEX_CLI_INIT_PATH/backups ]]; then

            echo "Creating '/backups' folder on HollaEx Kit directory"
            mkdir $HOLLAEX_CLI_INIT_PATH/backups

        fi

        if [[ "$USE_KUBERNETES" ]] && [[ "$ENVIRONMENT_KUBERNETES_RUN_POSTGRESQL_DB" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to run full PostgreSQL database backup (pg_dumpall) on this cluster? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "HollaEx CLI will open proxy tunnel between your machine and remote proxy with kubectl proxy."

            echo "Opening local proxy on 5432 port of your machine..."
            kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-db" -o name | sed 's/pod\///' | head -n 1) 5432:5432 &

            echo "Waiting for the proxy tunnel get fully ready..."
            sleep 10;
            
            echo "Running pg_dumpall..."
            export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
            export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
            export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
            export PGHOST=localhost

            pg_dumpall > "${HOLLAEX_CLI_INIT_PATH}"/backups/hollaex-db-"$(date +%y%m%d%H%M)".dump
            
            unset PGUSER
            unset PGPASSWORD
            unset PGDATABASE
            unset PGHOST

            echo "Dump data is saved as "${HOLLAEX_CLI_INIT_PATH}"/backups/$HOLLAEX_CONFIGMAP_API_NAME-db-$(date +%y%m%d%H%M).dump"

            echo "Killing the opened proxy tunnel..."
            kill $(ps -ef | grep "kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME" | awk '{print $2}' | head -n 1)

            exit 0;

        fi

        if [[ ! "$USE_KUBERNETES" ]] && [[ "$ENVIRONMENT_DOCKER_COMPOSE_RUN_POSTGRESQL_DB" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to run full PostgreSQL database backup (pg_dumpall) on this machine? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "HollaEx CLI will backup your local PostgreSQL DB."

            echo "Running pg_dumpall..."
            
            export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
            export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
            export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
            export PGHOST=localhost
            pg_dumpall > $HOLLAEX_CLI_INIT_PATH/backups/$HOLLAEX_CONFIGMAP_API_NAME-db-$(date +%y%m%d%H%M).dump
            
            unset PGUSER
            unset PGPASSWORD
            unset PGDATABASE
            unset PGHOST

            echo "Dump data is saved as $HOLLAEX_CLI_INIT_PATH/backups/$HOLLAEX_CONFIGMAP_API_NAME-db-$(date +%y%m%d%H%M).dump"

            exit 0;

        fi

    elif [[ "$KUBERNETES_SET_BACKUP_POSTGRESQL_CRONJOB" ]]; then

        if [[ "$USE_KUBERNETES" ]] ; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to install cronjob for database backup on this cluster? (y/N)"
                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            generate_db_s3_backup_cronjob_config;

            echo "Installing cronjob for database backup on Kubernetes."
            if command helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-db-backup-s3 \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/db-s3-backup-cronjob.yaml \
                        $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres-s3-backup-cronjob; then
                
                echo "The cronjob has been installed successfully!"

                echo "The job will be triggered by following $ENVIRONMENT_KUBERNETES_S3_BACKUP_CRONJOB_RULE rule."
                
                exit 0;

            else 

                echo "Failed to install the cronjob at the Kubernetes cluster."
                echo "Please check the error logs and try again."

                exit 1;

            fi
            
        
        elif [[ ! "$USE_KUBERNETES" ]] ; then

            echo "HollaEx CLI only supports install cronjob for database backup on Kubernetes environment."
            echo "Please use --kube flag to target Kubernetes."

            exit 1;

        fi
        
    elif [[ "$FLUSH_REDIS" ]]; then

        printf "\033[93mWarning: Exchange service will be unavailable during the flush!\033[39m\n"

        if [[ "$USE_KUBERNETES" ]] ; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to run flush Redis data on this cluster? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Flushing Redis..."
            kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- node tools/dbs/flushRedis.js

            echo "Restarting all workload containers..."
            kubectl delete pods --namespace $ENVIRONMENT_EXCHANGE_NAME -l role=$ENVIRONMENT_EXCHANGE_NAME

            exit 0;

        elif [[ ! "$USE_KUBERNETES" ]] ; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to to run flush Redis data on this machine? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Shutting down Nginx to block exchange external access"
            docker stop $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ")

            IFS=',' read -ra CONTAINER_PREFIX <<< "-${ENVIRONMENT_EXCHANGE_RUN_MODE}"
            
            echo "Flushing Redis..."
            docker exec ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX[0]}_1 node tools/dbs/flushRedis.js

            echo "Restarting all workload containers..."
            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml restart

            sleep 10;

            exit 0;
        fi

    elif [[ "$ADD_COIN" ]]; then

        if [[ "$IS_HOLLAEX_SETUP" ]]; then

            echo "Adding user custom currencies on the exchange..."

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "ENVIRONMENT_USER_HOLLAEX_CORE_" $i > /dev/null ; then

                    export CONFIGMAP_FILE_PATH=$i

                fi

            done

            IFS=',' read -ra CUSTOM_CURRENCIES_TO_ADD <<< "$HOLLAEX_CONFIGMAP_CURRENCIES"

            for j in ${CUSTOM_CURRENCIES_TO_ADD[@]}; do

                if command grep -q $j $CONFIGMAP_FILE_PATH > /dev/null; then

                    export COIN_SYMBOL=$j
                    export VALUE_IMPORTED_FROM_CONFIGMAP=true

                    if command grep -q "ENVIRONMENT_ADD_COIN_$(echo $j | tr a-z A-Z)_" $CONFIGMAP_FILE_PATH > /dev/null ; then

                        printf "\033[92mCoin configurations for $j has been detected at user's configmap file!\033[39m\n"
                        echo "Proceeding to add..."

                        add_coin_exec;
                    
                    else 

                        printf "\033[91mError: Coin configurations for $j doesn't exists at user's configmap file.\033[39m\n"
                        echo "Skipping to add..."

                    fi
                
                fi
            
            done

            if [[ "$USE_KUBERNETES" ]]; then

                kubernetes_database_init upgrade;

            else 

                echo "Running database triggers"
                docker exec --env "CURRENCIES=${HOLLAEX_CONFIGMAP_CURRENCIES}" ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX[0]}_1 node tools/dbs/runTriggers.js > /dev/null;
            
            fi
             
        elif [[ "$IS_COIN_SYMBOL_PASSED" ]]; then

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "ENVIRONMENT_USER_HOLLAEX_CORE_" $i > /dev/null ; then

                    export CONFIGMAP_FILE_PATH=$i

                fi

            done

            IFS=',' read -ra CUSTOM_CURRENCIES_TO_ADD <<< "$PASSED_COIN_SYMBOL"

            for j in ${CUSTOM_CURRENCIES_TO_ADD[@]}; do
                
                for i in ${CONFIG_FILE_PATH[@]}; do
                    source $i
                done;

                if [[ $(echo $j | grep $HOLLAEX_CONFIGMAP_CURRENCIES) ]]; then

                    echo "Error: Coin $j is already exists on your exchange."
                    exit 1;

                fi
                
                COIN_SYMBOL=$j
                COIN_FULLNAME=$(echo $j | tr a-z A-Z)
                COIN_ALLOW_DEPOSIT=true
                COIN_ALLOW_WITHDRAWAL=true
                COIN_WITHDRAWAL_FEE=0.01
                COIN_MIN=0.01
                COIN_MAX=10000
                COIN_INCREMENT_UNIT=0.001
                COIN_ACTIVE=true
                COIN_DEPOSIT_LIMITS=$(join_array_to_json $(for ((i=1;i<=$HOLLAEX_CONFIGMAP_USER_LEVEL_NUMBER;i++)); do echo -n "$i " ; done;))
                COIN_WITHDRAWAL_LIMITS=$(join_array_to_json $(for ((i=1;i<=$HOLLAEX_CONFIGMAP_USER_LEVEL_NUMBER;i++)); do echo -n "$i " ; done;))
                
                add_coin_exec;
                   
            done

        else 

            printf "\033[93mWarning: Adding new coin requires full restart of the exchange!\033[39m\n"
            echo "Please double confirm that you are good to proceed"
            
            add_coin_input;

            add_coin_exec;
        
        fi
        
    elif [[ "$REMOVE_COIN" ]]; then

        printf "\033[93mWarning: Removing new coin requires full restart of the exchange!\033[39m\n"
        echo "Please double confirm that you are good to proceed"

        if [[ "$IS_COIN_SYMBOL_PASSED" ]]; then

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "ENVIRONMENT_USER_HOLLAEX_CORE_" $i > /dev/null ; then

                    export CONFIGMAP_FILE_PATH=$i

                fi

            done

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "ENVIRONMENT_USER_HOLLAEX_CORE_" $i > /dev/null ; then

                    export CONFIGMAP_FILE_PATH=$i

                fi

            done

            IFS=',' read -ra CUSTOM_CURRENCIES_TO_REMOVE <<< "$PASSED_COIN_SYMBOL"

            for j in ${CUSTOM_CURRENCIES_TO_REMOVE[@]}; do

                for i in ${CONFIG_FILE_PATH[@]}; do
                    source $i
                done;

                if [[ ! $(echo $HOLLAEX_CONFIGMAP_CURRENCIES | grep $j) ]]; then

                    echo "Error: Coin $j doesn't exists on your exchange."
                    exit 1;

                fi
                
                COIN_SYMBOL=$j

                remove_coin_exec;
                   
            done

        else 
            
            remove_coin_input;

            remove_coin_exec;
        
        fi
    
    elif [[ "$ADD_TRADING_PAIR" ]]; then

        if [[ "$IS_HOLLAEX_SETUP" ]]; then

            echo "Adding user custom trading pairs on the exchange..."

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "ENVIRONMENT_USER_HOLLAEX_CORE_" $i > /dev/null ; then

                    export CONFIGMAP_FILE_PATH=$i

                fi

            done

            IFS=',' read -ra CUSTOM_PAIRS_TO_ADD <<< "$HOLLAEX_CONFIGMAP_PAIRS"

            for j in ${CUSTOM_PAIRS_TO_ADD[@]}; do

                if command grep -q $j $CONFIGMAP_FILE_PATH > /dev/null; then

                    export PAIR_NAME=$j
                    export PAIR_BASE=$(echo $j | cut -f1 -d "-")
                    export PAIR_2=$(echo $j | cut -f2 -d "-")
                    export PAIR_PREFIX=$(echo $PAIR_BASE | tr a-z A-Z)_$(echo $PAIR_2 | tr a-z A-Z)
     
                    export VALUE_IMPORTED_FROM_CONFIGMAP=true

                    if command grep -q "ENVIRONMENT_ADD_PAIR_$(echo $PAIR_PREFIX)_" $CONFIGMAP_FILE_PATH > /dev/null ; then

                        printf "\033[92mTrading pair configurations for $j has been detected at user's configmap file!\033[39m\n"
                        echo "Proceeding to add..."

                        add_pair_exec;
                    
                    else 

                        printf "\033[91mError: Trading pair configurations for $j doesn't exists at user's configmap file.\033[39m\n"
                        echo "Skipping to add..."
                    
                    fi
                
                fi
            
            done

            if [[ "$USE_KUBERNETES" ]]; then

                kubernetes_database_init upgrade;

            else 

                echo "Running database triggers"
                docker exec --env "PAIRS=${HOLLAEX_CONFIGMAP_PAIRS}" ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX[0]}_1 node tools/dbs/runTriggers.js > /dev/null;
            
            fi

        elif [[ "$IS_PAIR_NAME_PASSED" ]]; then

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "ENVIRONMENT_USER_HOLLAEX_CORE_" $i > /dev/null ; then

                    export CONFIGMAP_FILE_PATH=$i

                fi

            done

            IFS=',' read -ra CUSTOM_PAIRS_TO_ADD <<< "$PASSED_PAIR_NAME"

            for j in ${CUSTOM_PAIRS_TO_ADD[@]}; do

                for i in ${CONFIG_FILE_PATH[@]}; do
                    source $i
                done;

                if [[ $(echo $j | grep $HOLLAEX_CONFIGMAP_PAIRS) ]]; then

                    echo "Error: Pair $j is already exists on your exchange."
                    exit 1;

                fi
                
                PAIR_NAME=$j
                PAIR_BASE=$(echo $PAIR_NAME | cut -f1 -d '-')
                PAIR_2=$(echo $PAIR_NAME | cut -f2 -d '-')
                MIN_SIZE=0.00001
                MAX_SIZE=10000000
                MIN_PRICE=0.000001
                MAX_PRICE=1000000
                INCREMENT_SIZE=0.001
                INCREMENT_PRICE=0.001
                PAIR_ACTIVE=true
                TAKER_FEES=$(join_array_to_json $(for ((i=1;i<=$HOLLAEX_CONFIGMAP_USER_LEVEL_NUMBER;i++)); do echo -n "$i " ; done;))
                MAKER_FEES=$(join_array_to_json $(for ((i=1;i<=$HOLLAEX_CONFIGMAP_USER_LEVEL_NUMBER;i++)); do echo -n "$i " ; done;))
                
                add_pair_exec;
                   
            done

        else 

            printf "\033[93mWarning: Adding new pair requires full restart of the exchange!\033[39m\n"
            echo "Please double confirm that you are good to proceed"
            
            add_pair_input;

            add_pair_exec;
        
        fi

    elif [[ "$REMOVE_TRADING_PAIR" ]]; then

        printf "\033[93mWarning: Removing new pair requires full restart of the exchange!\033[39m\n"
        echo "Please double confirm that you are good to proceed"

        if [[ "$IS_PAIR_NAME_PASSED" ]]; then

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "ENVIRONMENT_USER_HOLLAEX_CORE_" $i > /dev/null ; then

                    export CONFIGMAP_FILE_PATH=$i

                fi

            done 

            IFS=',' read -ra CUSTOM_PAIRS_TO_REMOVE <<< "$PASSED_PAIR_NAME"

            for j in ${CUSTOM_PAIRS_TO_REMOVE[@]}; do

                for i in ${CONFIG_FILE_PATH[@]}; do
                    source $i
                done;

                if [[ ! $(echo $HOLLAEX_CONFIGMAP_PAIRS | grep $j) ]]; then

                    echo "Error: Pair $j doesn't exists on your exchange."
                    exit 1;

                fi
                
                PAIR_NAME=$j
                PAIR_BASE=$(echo $PAIR_NAME | cut -f1 -d '-')
                PAIR_2=$(echo $PAIR_NAME | cut -f2 -d '-')
                
                remove_pair_exec;
                   
            done
        else 
        
            remove_pair_input;

            remove_pair_exec;
        
        fi 
    
    # elif [[ "$RECONFIGURE_BASIC_SETTINGS" ]]; then

    #     # Ask for basic necessary settings
    #     launch_basic_settings_input;

    #     echo "Make sure to check your settings files been successfully updated by following your provided values."
    #     echo "Once it's all good, then you can proceed to actually update your exchange by using 'hollaex upgrade' command."
    #     echo "If you also updated activation code for the exchange, make sure to run 'hollaex toolbox --reactivate_exchange' command after 'hollaex upgrade'."

    # elif [[ "$REACTIVATE_EXCHANGE" ]]; then

    #     reactivate_exchange;
    

    elif [[ "$ISSUE_SSL_CERT" ]]; then
        
        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Would you like to continue to issue SSL cert through Let's Encrypt? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]]; then
                echo "Exiting..."
                exit 0;
            fi
        fi

        echo "Issuing SSL..."

        if command docker exec -it $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") certbot --nginx; then
            
            echo "SSL cert has been successfully set."
            echo "All the Let's encrypt related files can be found at ./templates/local/letsencrypt."

            echo "Updating domanin configurations to use HTTPS at user settings file..."

            UPDATED_HOLLAEX_CONFIGMAP_API_HOST=${HOLLAEX_CONFIGMAP_API_HOST//http:/https:}
            UPDATED_HOLLAEX_CONFIGMAP_DOMAIN=${HOLLAEX_CONFIGMAP_DOMAIN//http:/https:}

            ESCAPED_HOLLAEX_CONFIGMAP_API_HOST=${UPDATED_HOLLAEX_CONFIGMAP_API_HOST//\//\\/}
            ESCAPED_HOLLAEX_CONFIGMAP_DOMAIN=${UPDATED_HOLLAEX_CONFIGMAP_DOMAIN//\//\\/}

            for i in ${CONFIG_FILE_PATH[@]}; do
                if command grep -q "ENVIRONMENT_EXCHANGE_NAME" $i > /dev/null ; then
                    CONFIGMAP_FILE_PATH=$i

                    sed -i.bak "s/HOLLAEX_CONFIGMAP_API_HOST=.*/HOLLAEX_CONFIGMAP_API_HOST=$ESCAPED_HOLLAEX_CONFIGMAP_API_HOST/" $CONFIGMAP_FILE_PATH
                    sed -i.bak "s/HOLLAEX_CONFIGMAP_DOMAIN=.*/HOLLAEX_CONFIGMAP_DOMAIN=$ESCAPED_HOLLAEX_CONFIGMAP_DOMAIN/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak
                fi
            done

            if command docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null ; then

                printf "\n\033[93mWarning: You should rebuild and restart your web server to apply SSL configuraion on the web.\033[39m\n\n"
                echo "The web server would malfunction if the server doesn't get rebuild"
                echo "Please run 'hollaex web --restart' to rebuild the image and apply."
                printf "\n"

            fi

            printf "\n\nNote: The SSL certificate issued by Let's Encrypt requires a \033[1mrenewal in every 3 months.\033[0m\n"
            printf "Please make sure to run '\033[1mhollaex toolbox --renew_ssl\033[0m' to renew your SSL certificate before it gets expired.\n"
            printf "\nIt is recommended to \033[1msetup a Cronjob\033[0m to automate the renewal process.\n"

            exit 0;

        else 

            printf "\033[91mFailed to issue SSL certificate by using Certbot. Please confirm your settings and try again.\033[39m\n"
            exit 1;

        fi
 
        
    
    elif [[ "$RENEW_SSL_CERT" ]]; then

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Would you like to continue to renew SSL cert through Let's Encrypt? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]]; then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo "Renewing SSL..."

        if command docker exec -it $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") certbot renew; then
        
            echo "SSL cert has been successfully renewed."
            echo "All Let's encrypt related files can be found at ./templates/local/letsencrypt."

        else 

            printf "\033[91mFailed to issue SSL certificate by using Certbot. Please confirm your settings and try again.\033[39m\n"
            exit 1;

        fi
      

    elif [[ "$UPDATE_REGISTRY_SECRET" ]]; then

        if [[ ! "$USE_KUBERNETES" ]]; then 

            echo "Warning: Docker registry secret update is only available for Kubernetes."
            echo "Please use 'hollaex toolbox --update_registry_secret --kube' command instead."
            exit 1;

        fi

        check_kubernetes_dependencies;
        
        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        echo "Are you sure that you want to update your existing Docker registry secret at this Kubernets cluster? (y/N)"
        read answer 

        if [[ "$answer" = "${answer#[Yy]}" ]] ;then
            echo "Exiting..."
            exit 0;
        fi

        echo "Removing the current Docker registry secret at $ENVIRONMENT_EXCHANGE_NAME namespace."
        kubectl delete secret docker-registry-secret --namespace $ENVIRONMENT_EXCHANGE_NAME

         if [[ "$ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_USERNAME" ]] && [[ "$ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_PASSWORD" ]] && [[ "$ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_EMAIL" ]]; then

            echo "Docker registry credentials are detected at your configmap file."

            echo "*********************************************"
            echo "Docker Registry Host: $ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_HOST"
            echo "Docker Registry Email: $ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_EMAIL"
            echo "Docker Registery Username: $ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_USERNAME"
            echo "Docker Registry Password: $(echo ${ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_PASSWORD//?/◼︎}$(echo $ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_PASSWORD | grep -o '....$'))"
            echo "*********************************************"
            echo "You can either proceed with this values, or set it again manually by yourself."
            echo "Do you want to proceed with this values? (Y/n)"
            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then

                echo "Proceeding to a from to re-fill up the credentials."
                MANUAL_DOCKER_REGISTRY_SECRET_UPDATE=true

            fi
        
        fi

        create_kubernetes_docker_registry_secret;
    
    elif [[ "$SET_ACTIVATION_CODE" ]]; then
        
        if [[ "$USE_KUBERNETES" ]]; then 

            check_kubernetes_dependencies;
        
            echo "*********************************************"
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            echo "Are you sure that you want to update your activation code for the exchange on this Kubernets cluster? (y/N)"
            read answer 

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

            update_activation_code_input;

            update_activation_code_exec;

            echo "Your activation code has been successfully updated!"
            echo "Make sure to run 'hollaex restart --kube' to fully apply it."


        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_dependencies;

            echo "Are you sure that you want to update your activation code for the exchange on this machine? (y/N)"
            read answer 

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

            update_activation_code_input;

            update_activation_code_exec;

            echo "Your activation code has been successfully updated!"
            echo "Make sure to run 'hollaex restart' to fully apply it."

        fi

    elif [[ "$CHECK_CONSTANTS" ]]; then

        function toolbox_set_constants_confirm_message() {

            echo "This command would check and update the missing database constants, based on your settings files."
            echo "The missing value could be caused by an upgrade or an error at exchange initialization."
            echo "Do you want to proceed? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        }

        if [[ "$USE_KUBERNETES" ]]; then 

            toolbox_set_constants_confirm_message;

            echo "Generating Kubernetes Configmap."
            generate_kubernetes_configmap;

            echo "Generating Kubernetes Secret."
            generate_kubernetes_secret;

             echo "Applying configmap on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml
            
            echo "Applying secret on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

            check_constants_exec;
            
        elif [[ ! "$USE_KUBERNETES" ]]; then 
        
            toolbox_set_constants_confirm_message; 

            toolbox_set_config_confirm_message;
            
            generate_local_env;

            check_constants_exec;

        fi


    elif [[ "$SET_CONFIG" ]]; then

        function toolbox_set_config_confirm_message() {

            echo "Warning: This command is not recommended for most of users in most of use cases."
            echo "This command would completely override your database to update values with local settings."
            echo "Are you sure you want to update database-stored constatns with your local configmap values? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        }

        if [[ "$USE_KUBERNETES" ]]; then 

            toolbox_set_config_confirm_message;

            echo "Generating Kubernetes Configmap."
            generate_kubernetes_configmap;

            echo "Generating Kubernetes Secret."
            generate_kubernetes_secret;

             echo "Applying configmap on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml
            
            echo "Applying secret on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

            set_config_exec;
            
        elif [[ ! "$USE_KUBERNETES" ]]; then 
        
            check_docker_compose_dependencies; 

            toolbox_set_config_confirm_message;
            
            generate_local_env;

            set_config_exec;

        fi

    elif [[ "$set_security" ]]; then

        function toolbox_set_security_confirm_message() {

            echo "Warning: This command would override security values* values of your exchange with new ones provided."
            echo "*Security values: Allowed domains, Allowed Admin IPs, reCaptcha Access & Secret keys."
            echo "Do you want to continue? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        }

        if [[ "$USE_KUBERNETES" ]]; then 

            toolbox_set_security_confirm_message;

            set_security_input;

            echo "Generating Kubernetes Configmap."
            generate_kubernetes_configmap;

            echo "Generating Kubernetes Secret."
            generate_kubernetes_secret;

             echo "Applying configmap on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml
            
            echo "Applying secret on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml
            
            set_security_exec;
            

        elif [[ ! "$USE_KUBERNETES" ]]; then 
        
            check_docker_compose_dependencies; 

            toolbox_set_security_confirm_message;

            set_security_input;

            set_security_exec;

        fi



    elif [[ "$CONNECT_DATABASE" ]]; then

        if ! command psql --version > /dev/null 2>&1; then

            printf "\033[91mHollaEx CLI failed to detect postgresql-client at your computer.\033[39m\n"
            echo "Please install it first, before proceeding."
            exit 1;
        
        fi

        if [[ "$USE_KUBERNETES" ]]; then 

            check_kubernetes_dependencies;

            if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1 && command kubectl get pods -n $ENVIRONMENT_EXCHANGE_NAME -l app=$ENVIRONMENT_EXCHANGE_NAME-db > /dev/null 2>&1; then

                echo "Successfully detected the PostgreSQL DB created by HollaEx CLI."
                echo "Opening kube-proxy tunnel for database connection..."

                kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-db" -o name | sed 's/pod\///' | head -n 1) 5432:5432 &
                sleep 5;
                
                echo "Opening local proxy on 5432 port of your machine..."
                export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
                export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
                export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
                export PGHOST=localhost

                echo "Opening postgresql-client shell..."
                psql 

                echo "Killing the opened proxy tunnel..."
                kill $(ps -ef | grep "kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME" | awk '{print $2}' | head -n 1)

                exit 0;
            
            else

                echo "Failed to detect PostgreSQL database at your Kubernetes which created by HollaEx CLI."
                echo "If you setup PostgreSQL database in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_dependencies;

            if command docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-db > /dev/null 2>&1; then

                echo "Successfully detected the PostgreSQL DB created by HollaEx CLI."

                echo "Opening postgresql-client shell..."
                export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
                export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
                export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
                export PGHOST=localhost

                psql 

                exit 0;

            else

                echo "Failed to detect PostgreSQL database at your machine which created by HollaEx CLI."
                echo "If you setup PostgreSQL database in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        fi

    elif [[ "$CONNECT_REDIS" ]]; then

        if ! command rdcli --version > /dev/null 2>&1; then

            printf "\033[91mHollaEx CLI failed to detect redis-cli at your computer.\033[39m\n"
            echo "Please install it first, before proceeding."
            exit 1;
        
        fi

        if [[ "$USE_KUBERNETES" ]]; then 

            check_kubernetes_dependencies;

            if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1 && command kubectl get pods -n $ENVIRONMENT_EXCHANGE_NAME -l app=$ENVIRONMENT_EXCHANGE_NAME-redis > /dev/null 2>&1; then

                echo "Successfully detected the Redis created by HollaEx CLI."
                echo "Opening kube-proxy tunnel for Redis connection..."

                kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-redis" -o name | sed 's/pod\///' | head -n 1) 6379:6379 &
                sleep 5;
                
                echo "Opening local proxy on 6379 port of your machine..."
                export REDISCLI_AUTH=$HOLLAEX_SECRET_REDIS_PASSWORD

                echo "Opening redis-client shell..."
                redis-cli 

                echo "Killing the opened proxy tunnel..."
                kill $(ps -ef | grep "kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME" | awk '{print $2}' | head -n 1)

                exit 0;
            
            else

                echo "Failed to detect Redis at your Kubernetes which created by HollaEx CLI."
                echo "If you setup Redis in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_dependencies;

            if command docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-redis > /dev/null 2>&1; then

                echo "Successfully detected the Redis created by HollaEx CLI."

                echo "Opening redis-cli shell..."
                export REDISCLI_AUTH=$HOLLAEX_SECRET_REDIS_PASSWORD

                redis-cli 

                exit 0;

            else

                echo "Failed to detect Redis at your machine which created by HollaEx CLI."
                echo "If you setup Redis in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        fi

    elif [[ "$CONNECT_INFLUXDB" ]]; then

        if ! command influx --version > /dev/null 2>&1; then

            printf "\033[91mHollaEx CLI failed to detect influx-cli at your computer.\033[39m\n"
            echo "Please install it first, before proceeding."
            exit 1;
        
        fi

        if [[ "$USE_KUBERNETES" ]]; then 

            check_kubernetes_dependencies;

            if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1 && command kubectl get pods -n $ENVIRONMENT_EXCHANGE_NAME -l app=$ENVIRONMENT_EXCHANGE_NAME-influxdb > /dev/null 2>&1; then

                echo "Successfully detected the InfluxDB created by HollaEx CLI."
                echo "Opening kube-proxy tunnel for InfluxDB connection..."
                
                echo "Opening local proxy on 8086 port of your machine..."
                kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-influxdb" -o name | sed 's/pod\///' | head -n 1) 8086:8086 &
                sleep 5;

                echo "Opening influx-cli shell..."
                influx -database $HOLLAEX_SECRET_INFLUX_DB -username $HOLLAEX_SECRET_INFLUX_USER -password $HOLLAEX_SECRET_INFLUX_PASSWORD

                echo "Killing the opened proxy tunnel..."
                kill $(ps -ef | grep "kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME" | awk '{print $2}' | head -n 1)

                exit 0;
            
            else

                echo "Failed to detect InfluxDB at your Kubernetes which created by HollaEx CLI."
                echo "If you setup InfluxDB in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_dependencies;

            if command docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-influxdb > /dev/null 2>&1; then

                echo "Successfully detected the influx-cli created by HollaEx CLI."

                echo "Opening influx-cli shell..."
                influx -database $HOLLAEX_SECRET_INFLUX_DB -username $HOLLAEX_SECRET_INFLUX_USER -password $HOLLAEX_SECRET_INFLUX_PASSWORD

                exit 0;

            else

                echo "Failed to detect InfluxDB at your machine which created by HollaEx CLI."
                echo "If you setup InfluxDB in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        fi
    
    elif [[ "$INSTALL_CLI_ENABLE" ]]; then

        if [[ ! "$INSTALL_CLI_TARGET" ]]; then

            echo "Error: You must specify version of the CLI to downgrade."
            echo "eg. 'hollaex toolbox --install_cli 1.8.5'."

            exit 1;

        fi

        echo "Are you sure you want to install HollaEx CLI v$INSTALL_CLI_TARGET? (y/N)"
        read answer

        if [[ "$answer" = "${answer#[Yy]}" ]]; then
            echo "Exiting..."
            exit 0;
        fi
 
        bash $SCRIPTPATH/install.sh $INSTALL_CLI_TARGET

    elif [[ "$INFLUXDB_MIGRATION" ]]; then
    
        if [[ "$USE_KUBERNETES" ]]; then 

            check_kubernetes_dependencies;

            if ! command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then

                echo "*********************************************"
                printf "\033[91mError: HollaEx CLI failed to detect the exchange on your machine.\033[39m\n"
                printf "\033[91mThis command could only works after the exchange get setup.\033[39m\n\n"
                echo "Exiting..."
                echo "*********************************************"
                exit 1;

            fi

            echo "Running InfluxDB migrations"
            kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- node tools/dbs/createInflux.js
            kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- node tools/dbs/migrateInflux.js
            kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- node tools/dbs/initializeInflux.js
        
            echo "Restarting the exchange..."
            kubectl delete pods --namespace $ENVIRONMENT_EXCHANGE_NAME -l role=$ENVIRONMENT_EXCHANGE_NAME


        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_dependencies;

            if ! command docker ps -a | grep local_$ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then

                echo "*********************************************"
                printf "\033[91mError: HollaEx CLI failed to detect the exchange on your machine.\033[39m\n"
                printf "\033[91mThis command could only works after the exchange get setup.\033[39m\n\n"
                echo "Exiting..."
                echo "*********************************************"
                exit 1;

            fi

            IFS=',' read -ra CONTAINER_PREFIX <<< "-${ENVIRONMENT_EXCHANGE_RUN_MODE}"

            echo "Running InfluxDB migrations"
            docker exec ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX[0]}_1 node tools/dbs/createInflux.js
            docker exec ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX[0]}_1 node tools/dbs/migrateInflux.js
            docker exec ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX[0]}_1 node tools/dbs/initializeInflux.js

            echo "Restarting containers to apply database changes."
            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml restart

        fi
        
    fi

elif [[ "$1" == "cloud" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kit_repo)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLOUD_CUSTOM_KIT_REPO="${1:-https://github.com/bitholla/hollaex-kit.git}"
                echo "Your Custom HollaEx Kit Git Repository : $HOLLAEX_CLOUD_CUSTOM_KIT_REPO."
                shift; continue
                ;;
            --kit_branch)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLOUD_CUSTOM_KIT_BRANCH="${1:-master}"
                echo "Your Custom HollaEx Kit Git Branch : $HOLLAEX_CLOUD_CUSTOM_KIT_BRANCH."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --start)
                HOLLAEX_CLOUD_INPUT=true
                HOLLAEX_CLOUD_START=true
                shift; continue
                ;;
            --stop)
                HOLLAEX_CLOUD_INPUT=true
                HOLLAEX_CLOUD_STOP=true
                shift; continue
                ;;
            --restart)
                HOLLAEX_CLOUD_INPUT=true
                HOLLAEX_CLOUD_RESTART=true
                shift; continue
                ;;
            --upgrade)
                HOLLAEX_CLOUD_INPUT=true
                HOLLAEX_CLOUD_UPGRADE=true
                shift; continue
                ;;
            --terminate)
                HOLLAEX_CLOUD_INPUT=true
                HOLLAEX_CLOUD_TERMINATE=true
                shift; continue
                ;;
            # Build related
            --user_image_registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE=$1
                echo "Target hollaex docker registry : $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! "$USE_KUBERNETES" ]]; then

         if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi
    
    elif [[ "$USE_KUBERNETES" ]]; then

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

    fi

    if [[ ! "$HOLLAEX_CLOUD_INPUT" ]]; then 

        print_usage

        echo -e "\033[91mError: You haven't specified any action for the 'hollaex cloud' command.\033[39m"
        echo -e "Please check the command list above and try it again.\n"

        exit 1;

    fi 
    
    hollaex_login_token_validate_and_issue;

    # # # FIGURE OUT THE EXCHANGE ID # # #
    HOLLAEX_CLOUD_GET_EXCHANGE_INFO_REQUEST=$(curl -s -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN"\
          --request GET \
          https://$ENVIRONMENT_BRIDGE_TARGET_SERVER/v1/exchange)

    HOLLAEX_CLOUD_GET_EXCHANGE_NAME_LIST=$(echo $HOLLAEX_CLOUD_GET_EXCHANGE_INFO_REQUEST | jq -r '.data[].name')

    j=0
    for i in ${HOLLAEX_CLOUD_GET_EXCHANGE_NAME_LIST[@]}; do 

        if [[ "$i" == "$HOLLAEX_CONFIGMAP_API_NAME" ]]; then

            EXCHANGE_ARRAY_ORDER=$j

        fi

        ((j++))

    done

    HOLLAEX_CLOUD_EXCHANGE_ID=$(echo $HOLLAEX_CLOUD_GET_EXCHANGE_INFO_REQUEST | jq -r ".data[$EXCHANGE_ARRAY_ORDER].id")
    
    # # # END # # # 

    if [[ "$HOLLAEX_CLOUD_START" ]]; then 

        echo -e "\nSending a request to start the stopped exchange on the HollaCloud..."

        # HOLLAEX_CLOUD_START_API_REQUEST=$(curl -s -o /dev/null -w "%{http_code}" -H "Content-Type: application/json" \
        # -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN" \
        # --request POST \
        # --data "{\"exchange_id\": ${HOLLAEX_CLOUD_EXCHANGE_ID}, \"command\": \"start\", \"data\": { \"exchange_name\": \"$HOLLAEX_CONFIGMAP_API_NAME\", \"agent\": \"CLI v$(cat $SCRIPTPATH/version)\" }}" \
        # https://$ENVIRONMENT_BRIDGE_TARGET_SERVER/v1/exchange/cloud) 

        HOLLAEX_CLOUD_START_API_REQUEST=$(curl -s -w "&%{http_code}" -H "Content-Type: application/json" \
        -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN" \
        --request POST \
        --data "{\"exchange_id\": ${HOLLAEX_CLOUD_EXCHANGE_ID}, \"command\": \"start\", \"data\": { \"exchange_name\": \"$HOLLAEX_CONFIGMAP_API_NAME\", \"agent\": \"CLI v$(cat $SCRIPTPATH/version)\" }}" \
        https://$ENVIRONMENT_BRIDGE_TARGET_SERVER/v1/exchange/cloud) 

        HOLLAEX_CLOUD_START_API_REQUEST_RESPONSE_PARSE=$(echo $HOLLAEX_CLOUD_START_API_REQUEST | cut -f1 -d "&" | jq -r '.message')
        HOLLAEX_CLOUD_START_API_REQUEST_HTTP_CODE=$(echo $HOLLAEX_CLOUD_START_API_REQUEST | cut -f2 -d "&")

        
        if [[ "$HOLLAEX_CLOUD_START_API_REQUEST_HTTP_CODE" == "200" ]]; then 

            echo -e "\n\033[92mSuccessfully sent the request to the HollaCloud to start your exchange.\033[39m\n"
            echo "The job would take around 10~20 minutes."
            echo -e "We will inform you through the email once it's done!\n"

            exit 0;
        
        else 
            
            echo -e "\n\033[91mFailed to send the request to the server.\033[39m"
            echo -e "$HOLLAEX_CLOUD_START_API_REQUEST_RESPONSE_PARSE\n"
            echo -e "Please review the logs, and try it again.\n"

            exit 1;

        fi

    elif [[ "$HOLLAEX_CLOUD_STOP" ]]; then 

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to stop the $HOLLAEX_CONFIGMAP_API_NAME on the HollaCloud? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo -e "\nSending a request to stop the running exchange on the HollaCloud..."

        HOLLAEX_CLOUD_STOP_API_REQUEST=$(curl -s -w "&%{http_code}" -H "Content-Type: application/json" \
        -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN" \
        --request POST \
        --data "{\"exchange_id\": ${HOLLAEX_CLOUD_EXCHANGE_ID}, \"command\": \"stop\", \"data\": { \"exchange_name\": \"$HOLLAEX_CONFIGMAP_API_NAME\", \"agent\": \"CLI v$(cat $SCRIPTPATH/version)\" }}" \
        https://$ENVIRONMENT_BRIDGE_TARGET_SERVER/v1/exchange/cloud) 

        HOLLAEX_CLOUD_STOP_API_REQUEST_RESPONSE_PARSE=$(echo $HOLLAEX_CLOUD_STOP_API_REQUEST | cut -f1 -d "&" | jq -r '.message')
        HOLLAEX_CLOUD_STOP_API_REQUEST_HTTP_CODE=$(echo $HOLLAEX_CLOUD_STOP_API_REQUEST | cut -f2 -d "&")
        
        if [[ "$HOLLAEX_CLOUD_STOP_API_REQUEST_HTTP_CODE" == "200" ]]; then 

            echo -e "\n\033[92mSuccessfully sent the request to the HollaCloud to stop your exchange.\033[39m\n"
            echo "The job would take around 10~20 minutes."
            echo -e "We will inform you through the email once it's done!\n"

            exit 0;
        
        else 

            echo -e "\n\033[91mFailed to send the request to the server.\033[39m"
            echo -e "$HOLLAEX_CLOUD_STOP_API_REQUEST_RESPONSE_PARSE\n"
            echo "Please review the logs, and try it again."

            exit 1;

        fi
    
    elif [[ "$HOLLAEX_CLOUD_RESTART" ]]; then 

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to restart the $HOLLAEX_CONFIGMAP_API_NAME on the HollaCloud? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo -e "\nSending a request to restart the running exchange on the HollaCloud..."

        HOLLAEX_CLOUD_RESTART_API_REQUEST=$(curl -s -w "&%{http_code}" -H "Content-Type: application/json" \
        -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN" \
        --request POST \
        --data "{\"exchange_id\": ${HOLLAEX_CLOUD_EXCHANGE_ID}, \"command\": \"restart\", \"data\": { \"exchange_name\": \"$HOLLAEX_CONFIGMAP_API_NAME\", \"agent\": \"CLI v$(cat $SCRIPTPATH/version)\" }}" \
        https://$ENVIRONMENT_BRIDGE_TARGET_SERVER/v1/exchange/cloud) 

        HOLLAEX_CLOUD_RESTART_API_REQUEST_RESPONSE_PARSE=$(echo $HOLLAEX_CLOUD_RESTART_API_REQUEST | cut -f1 -d "&" | jq -r '.message')
        HOLLAEX_CLOUD_RESTART_API_REQUEST_HTTP_CODE=$(echo $HOLLAEX_CLOUD_RESTART_API_REQUEST | cut -f2 -d "&")
        
        if [[ "$HOLLAEX_CLOUD_RESTART_API_REQUEST_HTTP_CODE" == "200" ]]; then 

            echo -e "\n\033[92mSuccessfully sent the request to the HollaCloud to restart your exchange.\033[39m\n"
            echo "The job would take around 10~20 minutes."
            echo -e "We will inform you through the email once it's done!\n"

            exit 0;
        
        else 

            echo -e "\n\033[91mFailed to send the request to the server.\033[39m"
            echo -e "$HOLLAEX_CLOUD_RESTART_API_REQUEST_RESPONSE_PARSE\n"
            echo "Please review the logs, and try it again."

            exit 1;

        fi

    elif [[ "$HOLLAEX_CLOUD_UPGRADE" ]]; then 

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Warning: The upgrade would cause a downtime on your exchange."
            echo "Are you sure you want to upgrade the $HOLLAEX_CONFIGMAP_API_NAME on the HollaCloud? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo -e "\nSending a request to upgrade the running exchange on the HollaCloud..."

        echo -e "\n# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"
        echo "Your HollaEx Kit Git repository: ${HOLLAEX_CLOUD_CUSTOM_KIT_REPO:-'https://github.com/bitholla/hollaex-kit.git'}"
        echo "Your HollaEx Kit Git branch: ${HOLLAEX_CLOUD_CUSTOM_KIT_BRANCH:-'master'}"
        echo -e "# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"

        HOLLAEX_CLOUD_UPGRADE_API_REQUEST=$(curl -s -w "&%{http_code}" -H "Content-Type: application/json" \
        -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN" \
        --request POST \
        --data "{\"exchange_id\": ${HOLLAEX_CLOUD_EXCHANGE_ID}, \"command\": \"upgrade\", \"data\": { \"kit_repo\": \"$HOLLAEX_CLOUD_CUSTOM_KIT_REPO\", \"kit_branch\": \"$HOLLAEX_CLOUD_CUSTOM_KIT_BRANCH\", \"exchange_name\": \"$HOLLAEX_CONFIGMAP_API_NAME\", \"agent\": \"CLI v$(cat $SCRIPTPATH/version)\"}}" \
        https://$ENVIRONMENT_BRIDGE_TARGET_SERVER/v1/exchange/cloud) 

        HOLLAEX_CLOUD_UPGRADE_API_REQUEST_RESPONSE_PARSE=$(echo $HOLLAEX_CLOUD_UPGRADE_API_REQUEST | cut -f1 -d "&" | jq -r '.message')
        HOLLAEX_CLOUD_UPGRADE_API_REQUEST_HTTP_CODE=$(echo $HOLLAEX_CLOUD_UPGRADE_API_REQUEST | cut -f2 -d "&")
        
        if [[ "$HOLLAEX_CLOUD_UPGRADE_API_REQUEST_HTTP_CODE" == "200" ]]; then 

            echo -e "\n\033[92mSuccessfully sent the request to the HollaCloud to stop your exchange.\033[39m\n"
            echo "The job would take around 20~30 minutes."
            echo -e "We will inform you through the email once it's done!\n"

            exit 0;
        
        else 

            echo -e "\n\033[91mFailed to send the request to the server.\033[39m"
            echo -e "$HOLLAEX_CLOUD_UPGRADE_API_REQUEST_RESPONSE_PARSE\n"
            echo "Please review the logs, and try it again."

            exit 1;

        fi

    elif [[ "$HOLLAEX_CLOUD_TERMINATE" ]]; then 

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Warning: The termination could not be undo."
            echo "Are you sure you want to TERMINATE the $HOLLAEX_CONFIGMAP_API_NAME on the HollaCloud? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo -e "\nSending a request to TERMINATE the running exchange on the HollaCloud..."
        echo "Warning: This can't be undo."

        HOLLAEX_CLOUD_TERMINATE_API_REQUEST=$(curl -s -w "&%{http_code}" -H "Content-Type: application/json" \
        -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN" \
        --request POST \
        --data "{\"exchange_id\": ${HOLLAEX_CLOUD_EXCHANGE_ID}, \"command\": \"terminate\", \"data\": { \"exchange_name\": \"$HOLLAEX_CONFIGMAP_API_NAME\", \"agent\": \"CLI v$(cat $SCRIPTPATH/version)\" }}" \
        https://$ENVIRONMENT_BRIDGE_TARGET_SERVER/v1/exchange/cloud) 

        HOLLAEX_CLOUD_TERMINATE_API_REQUEST_RESPONSE_PARSE=$(echo $HOLLAEX_CLOUD_TERMINATE_API_REQUEST | cut -f1 -d "&" | jq -r '.message')
        HOLLAEX_CLOUD_TERMINATE_API_REQUEST_HTTP_CODE=$(echo $HOLLAEX_CLOUD_TERMINATE_API_REQUEST | cut -f2 -d "&")
        
        if [[ "$HOLLAEX_CLOUD_TERMINATE_API_REQUEST_HTTP_CODE" == "200" ]]; then 

            echo -e "\n\033[92mSuccessfully sent the request to the HollaCloud to terminate your exchange.\033[39m\n"
            echo "The job would take around 20~30 minutes."
            echo -e "We will inform you through the email once it's done!\n"

            exit 0;
        
        else 

            echo -e "\n\033[91mFailed to send the request to the server.\033[39m"
            echo -e "$HOLLAEX_CLOUD_TERMINATE_API_REQUEST_RESPONSE_PARSE\n"
            echo -e "Please review the logs, and try it again.\n"

            exit 1;

        fi

    fi

    exit 0;

elif [[ "$1" == "status" ]]; then

     while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
     done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi
    
    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        kubectl get pods --namespace $ENVIRONMENT_EXCHANGE_NAME

    fi
    
    if [[ ! "$USE_KUBERNETES" ]]; then

        if [[ -z $(docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME) ]]; then

            printf "\033[91m\nFailed to detect HollaEx on this machine. Please try it again.\033[39m\n"

        else 

            docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME

        fi

    fi

    printf "\nCalling the exchange health page ($HOLLAEX_CONFIGMAP_API_HOST/v1/health) ...\n"

    if command curl $HOLLAEX_CONFIGMAP_API_HOST/v1/health; then 

        printf "\n\033[92mSuccessfully reached to the exchange health page.\033[39m\n"

    else 

        printf "\033[91m\nExchange health page is not responding. Please check the exchange is up.\033[39m\n"

    fi

    exit 0;

elif [[ "$1" == "logs" ]]; then

     while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --target)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_LOGS_TARGET=$1
                echo "Displaying Logs from $1..."
                shift; continue
                ;;
            # --lines and --line does same thing.
            --lines)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_LOGS_TARGET_LINE=$1
                shift; continue
                ;;
            --line)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_LOGS_TARGET_LINE=$1
                shift; continue
                ;;
           --export)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                echo "Exporting the result as a file."
                HOLLAEX_LOGS_EXPORT=true
                HOLLAEX_LOGS_EXPORT_PATH=$1
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
     done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi
    
    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    function hollaex_log_target_whitelist() {

        local whitelist=("api" "stream" "engine" "db" "redis" "influxdb" "plugins-controller")

        if ! command printf '%s\n' ${whitelist[@]} | grep $HOLLAEX_LOGS_TARGET > /dev/null; then
        
            printf "\033[91mError: Invalid target $HOLLAEX_LOGS_TARGET.\033[39m\n"
            echo "Command 'hollaex logs' only supports '${whitelist[@]}' as log target."
            echo "Pleases try it again."

            exit 1;

        fi
    }
    
    if [[ "$HOLLAEX_LOGS_TARGET" ]]; then

        hollaex_log_target_whitelist;
    
    fi

    if [[ -d "$HOLLAEX_LOGS_EXPORT_PATH" ]]; then

        export HOLLAEX_LOGS_EXPORT_PATH="${HOLLAEX_LOGS_EXPORT_PATH}/hollaex-logs-$(date +%s).log"

    fi

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        function show_kubernetes_logs_simple() {

            hollaex version

            # Printing general system information
            echo "Client System OS Type: $OSTYPE"
            echo "Client System Shell Type: $SHELL"
            echo "Client System Shell Version: $(${SHELL} --version)"

            printf "\nKubernetes Version: $(kubectl version)\n\n"
            echo "Helm Version: $(helm version)"

            printf "\n#########################################################################\n"

            if [[ "$HOLLAEX_LOGS_TARGET" ]]; then

                local POD_ID=$(kubectl get pods --namespace $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME-*-$HOLLAEX_LOGS_TARGET | cut -f1 -d " ")

            else 
                
                local POD_ID=$(kubectl get pods --namespace $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME | cut -f1 -d " ")
            
            fi

            for i in ${POD_ID[@]}; do

                printf "\nPod : $i\n"

                    if [[ $(kubectl logs $i --namespace $ENVIRONMENT_EXCHANGE_NAME --tail 10) ]]; then

                            kubectl logs $i --namespace $ENVIRONMENT_EXCHANGE_NAME --tail ${HOLLAEX_LOGS_TARGET_LINE:-100}

                    else 

                        echo "There are no logs for Pod : $i."

                    fi

                printf "\n"

            done;
        
        }

        if [[ "$HOLLAEX_LOGS_EXPORT" == true ]]; then

            show_kubernetes_logs_simple &> "${HOLLAEX_LOGS_EXPORT_PATH}"

        else 

            show_kubernetes_logs_simple
        
        fi


        printf "\n"
        echo "Displayed (Saved) last ${HOLLAEX_LOGS_TARGET_LINE:-100} lines of logs from pod(s)."

        if [[ ! "$HOLLAEX_LOGS_TARGET" ]]; then
            
            echo "To see logs from specific pod(s), Please run 'hollaex logs --kube --target <NAME_OF_COMPONENT> --lines <LINES_OF_LOGS>'."
            echo "For example, 'hollaex logs --kube --target api --lines 20'."
        
        fi

        if [[ "$HOLLAEX_LOGS_EXPORT" == true ]]; then

            printf "\nYou can find the exported logs file at ${HOLLAEX_LOGS_EXPORT_PATH}.\n"
            exit 0;

        fi

    fi
    
    if [[ ! "$USE_KUBERNETES" ]]; then

        if [[ -z $(docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME) ]]; then

            printf "\033[91m\nFailed to detect $ENVIRONMENT_EXCHANGE_NAME on this machine. Please try it again.\033[39m\n"

        else 

            function show_docker_logs_simple() {

                hollaex version

                # Printing general system information
                echo "System OS Type: $OSTYPE"
                echo "System Shell Type: $SHELL"
                echo "System Shell Version: $(${SHELL} --version)"

                printf "\n#########################################################################\n"

                if [[ "$HOLLAEX_LOGS_TARGET" ]]; then

                    local CONTAINER_ID=$(docker ps -a --format "{{.Names}}" | grep $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME-.*-$HOLLAEX_LOGS_TARGET)
                    echo $CONTAINER_ID

                else 
                
                    local CONTAINER_ID=$(docker ps -a --format "{{.Names}}" | grep $ENVIRONMENT_EXCHANGE_NAME)

                fi

                for i in ${CONTAINER_ID[@]}; do

                    printf "\nContainer : $i\n"

                    if [[ $(docker logs $i --tail 10) ]]; then

                            docker logs $i --tail ${HOLLAEX_LOGS_TARGET_LINE:-100}

                    else 

                        echo "There are no logs for container : $i."

                    fi

                    printf "\n"

                done;
            
            }

            if [[ "$HOLLAEX_LOGS_EXPORT" == true ]]; then

                show_docker_logs_simple &> "${HOLLAEX_LOGS_EXPORT_PATH}"

            else 

                show_docker_logs_simple
            
            fi

            printf "\n"
            echo "Displayed (Exported) last ${HOLLAEX_LOGS_TARGET_LINE:-100} lines of logs from container(s)."

            if [[ ! "$HOLLAEX_LOGS_TARGET" ]]; then

                echo "To see logs from specific container(s), Please run 'hollaex logs --target <NAME_OF_COMPONENT> --lines <LINES_OF_LOGS>'."
                echo "For example, 'hollaex logs --target api --lines 20'."
            
            fi

            if [[ "$HOLLAEX_LOGS_EXPORT" == true ]]; then

                printf "\nYou can find the exported logs file at ${HOLLAEX_LOGS_EXPORT_PATH}.\n"
                exit 0;

            fi

        fi

    fi

    exit 0;
 

elif [[ "$1" == "version" ]]; then

if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

    HOLLAEX_CLI_INIT_PATH=$(pwd)
    CONFIG_FILE_PATH=$(pwd)/settings/*
    TEMPLATE_GENERATE_PATH=$(pwd)/templates
    INIT_PATH_CHECK=$(pwd)/.hollaex

fi

if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

    CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
    TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
    INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
    
fi
    
source $SCRIPTPATH/tools_generator.sh
     
/bin/cat << EOF

:tt1   ;tti          LCC:1CC1         ,11tffttt            :tt;  ;tfi.tt1 ,,,
t@@8   f@@0  ,;ii;.  8@@;L@@f .:i1i:. ;@@@CLCGC;ii; ,iii.  t@@L,C@@L,.CCf,0@@;,
t@@8LLf0@@G,C@@G0@8L.0@@;L@@t.C80L0@8i:@@8tt;  :8@@1G@@1.  t@@0@@8:  ,8888@@@8G
t@@8CCC0@@CC@@L  G@@fG@@;L@@t,fCCfG@@L:@@@LLi    C@@@8,    t@@@C8@0: ,@@G.G@@,
t@@8   L@@G1@@0;;8@@i0@@;L@@fC@@Li0@@f:@@@iii11:i8@G@@C,   t@@L :0@@1,@@0 G@@1;
iGGL   tGGf ;LG00Gf: CGG:tGG1:LGGCLCG1:GGG0000fiGGL 1GGf.  iCC1  .LGG1CGf :LG0G,


HollaEx CLI : v$(cat $SCRIPTPATH/version).
HollaEx Kit : $(if [[ -f "$INIT_PATH_CHECK" ]]; then 
    echo "v$(cat $HOLLAEX_CLI_INIT_PATH/version)."
else
    echo -e "\033[91mNot in the Kit directory.\033[39m"
fi)

Made with <3 by bitHolla Inc.

EOF

else

    printf "\nInvalid Command. Please try it again.\n"
    print_usage;

    exit 1;

fi

exit 0;


