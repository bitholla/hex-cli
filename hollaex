#!/bin/bash 

SCRIPTPATH="$HOME/.hollaex-cli"

#### HollaEx CLI Settings ####

RUN_WITH_VERIFY=true 

LOCAL_DEPLOYMENT_MODE='all'

GENERATE_PASSWORDS=false

DOCKER_COMPOSE_NAME_PREFIX='local'

INIT_PATH_CHECK=$(pwd)/.hollaex

# Setting the mode to hollaex network operation
if [[ "$1" == "network" ]]; then 

    export HOLLAEX_NETWORK_OPERATION=true

fi

if [[ "$1" == "network" ]] && [[ "$2" == "--setup" ]]; then
    
    export HOLLAEX_NETWORK_SETUP=true

fi 

if [[ ! -f "$INIT_PATH_CHECK" ]] && [[ ! "$HOLLAEX_NETWORK_OPERATION" ]]; then 

    echo -e "\n\033[91mFailed to detect the HollaEx Kit."
    echo -e "Every HollaEx commands should be run at the HollaEx Kit path.\033[39m" 
    echo -e "Please check your current path and try it again.\n"
    echo -e "To download the HollaEx Kit, Please run 'git clone https://github.com/bitholla/hollaex-kit.git'.\n"
    exit 1;

fi 

if [[ "$HOLLAEX_NETWORK_OPERATION" ]] && [[ ! "$HOLLAEX_NETWORK_SETUP" ]]; then 

    INIT_PATH_CHECK=$(pwd)/.hollaex-network

    if [[ ! -f "$INIT_PATH_CHECK" ]]; then

        echo -e "\n\033[91mFailed to detect the HollaEx Network Home."
        echo -e "Every HollaEx commands should be run at the HollaEx Network Home Patch.\033[39m" 
        echo -e "Please check your current path and try it again.\n"
        exit 1;

    fi 

fi

if [[ ! "$HOLLAEX_NETWORK_OPERATION" ]]; then 

    source $(pwd)/.hollaex

    if [[ "$HOLLAEX_CONFIGMAP_NETWORK_URL" ]]; then 

        export hollaexAPIURL=$HOLLAEX_CONFIGMAP_NETWORK_URL

    elif [[ ! "$HOLLAEX_CONFIGMAP_NETWORK_URL" ]] && [[ "$ENVIRONMENT_HOLLAEX_KIT_NETWORK" == "testnet" ]]; then 

        export hollaexAPIURL='https://api.testnet.hollaex.network'

    else

        export hollaexAPIURL='https://api.hollaex.network'

    fi

    source $SCRIPTPATH/version_range

fi

err_msg() { echo "$@" ;} >&2
err_msg_a() { err_msg "-a option argument required" ;}
err_msg_l() { err_msg "--long option argument required" ;}

function print_usage() {
/bin/cat << EOF

Usage : 
    hollaex [ server ] [ web ] [ init ] [ prod ] [ import ] [ export ] [ dash ] [ pull ] [ build ] [ dev ] [ toolbox ] [ status ] [ logs ] [ version ] [ discord ] [ bug-report ] (--flags)

General Flags (Except for 'hollaex init', 'hollaex import'):
    --path, Manually pointing HollaEx Kit path. Should be always absolute path.
    --kube, Set HollaEx CLI to target Kubernetes. Make sure to setup your local kubectl before using it.
    --skip, Run command without user's double confirmation.

Options:
    import: Import settings files generated by using HollaEx Dashboard (dash.hollaex.com).
        --path, Path of file or directory where settings files are stored.
        --with_aws_s3 <BUCKET_NAME>, Import settings files from the remote AWS S3 bucket.

    export: Export settings files to the target location.
        --path, Path of the directory to export settings files.
        --with_aws_s3 <BUCKET_NAME>, Export settings files to the remote AWS S3 bucket.
    
    dash: Interaction with HollaEx Dashboard.
        --login: Log in with HollaEx Dashboard account.
        --logout Log out and remove my bound account.

    init: Initialize the HollaEx Kit by setting up the target network, sign up as an admin, and claim a new exchange name.

    pull: Pull the exchange data from the HollaEx Dashboard.

    prod: Bring up the exchange to production. Including public domain setup and SSL configuraiton.

    build: Build the Docker image for running HollaEx Kit, includes user custom configurations.
        --version, Specify base HollaEx Core version for build.

    server: Run and Manage HollaEx Exchange Server.
        --setup: Setup the exchange for the first launch.
        --start: Start the exchange which already been configured by 'hollaex setup' command.
            --tag, Tag name of the new image to apply.
            --ignore_settings, Ignore local settings files changes and not applying it on the server.
        --restart: Restart the existing exchange.
            --tag, Tag name of the new image to apply.
            --ignore_settings, Ignore local settings files changes and not applying it on the server.
        --stop: Stop the exchagne which already been running.
        --upgrade: Upgrade the exchange to new version.
            --version, Version number of HollaEx Core to upgrade.
            --user_image_registry, Specify Docker registry and version (tag) for the user HollaEx Core image.
            --ignore_compatibility_check, Ignore Kit and Core compatibility check before an upgrade.
            --ignore_settings, Ignore local settings files changes and not applying it on the server.
            --api_only, Rolling Upgrade API Pods only for Kubernetes.
        --terminate: Terminate the existing exchange. THIS COMMAND WILL COMPLETELY REMOVE YOUR EXCHANGE AND CAN'T BE UNDO.
      
    web: Run web server for the exchange.
        --setup, Setup the web server for the first launch.
        --start, Start the web server 
        --stop, Stop the web server.
        --restart, Restart the web server while applying new changes (If it's available).
        --build, Build the web server docker image. This command would not affect the existing web server before restart.
        --terminate, Terminate the web server. THIS COMMAND WILL COMPLETELY REMOVE YOUR WEB CLIENT AND CAN'T BE UNDO.

    trade: Open my exchange's web trading page.

    toolbox: Toolbox for advanced features which could be helpful for your exchange operations.
        --backup, Run the full backup with 'pg_dump' for exchange's PostgreSQL database.
        --restore, Apply the database dump to the database.
        --set_backup_cronjob, Set the Kubernetes Cronjob for periodical database backup.
        --flush_redis, Run the full flush of Redis stored data.
        --issue_ssl, Issue SSL certificate on local Nginx by using Let's Encrypt.
        --renew_ssl, Renew SSL certificate on local Nginx by using Let's Encrypt.
        --update_registry_secret, Update existing docker registry secret for Kubernetes.
        --set_config, Update constants configured on the exchange database.
        --set_security, Override security values at admin panel for the exchange.
        --set_activation_code, Set or update activation code for the exchange.
        --connect_database, Direct connection to PostgreSQL Database via postgresql-client.
        --connect_redis, Direct connection to Redis via redis-client.
        --install_cli, Install specific version of HollaEx CLI.
        --influxdb_migration, Migrate InfluxDB data to a new InfluxDB.
        --reset_hmac_token, Reset the exchange API key (HMAC Token).
        --enable_maintenance_mode, Maintenance mode. Giving HTTP 503 for non-whitelisted IPs.
        --whitelist-ip, List of whitelist IPs for the maintenance mode. Comma separated, no spaces.
        --disable_maintenance_mode, Disabling maintenance mode.

    dev: Running an exchange in a dev mode.
        --setup, Setup an exchange in a dev mode.
        --start, Starting an exchange in a dev mode.
        --stop, Stopping an exchange in a dev mode.
        --restart, Restarting an exchange in a dev mode.
        --terminate, Terminating an exchange in a dev mode.
        --database_init, Running a database initialization job for a dev mode exchange.

    cloud: Operate the exchange running on the HollaCloud.
        --start, Start the stopped exchange exists on the HollaCloud. 
        --stop, Stop the running exchange on the HollaCloud.
        --restart, Restart the running exchange on the HollaCloud.
        --upgrade, Upgrade the running exchange on the HollaCloud with the latest version of HollaEx Kit.
        --terminate, Terminate the existing exchange on the HollaCloud. THIS COMMAND WILL COMPLETELY REMOVE YOUR EXCHANGE AND CAN'T BE UNDO.

    status: Show the exchange server status.

    logs: Show overview of logs from the exchange server. 

    mode: Mode selector between the testnet and mainnet. Only use it for testing purposes.
        --testnet, Setting the mode to testnet.
        --mainnet, Setitng the mode to mainnet (default).

    discord: Open (join) HollaEx Official Discord Channel.
    
    forum: Open Official HollaEx Forum.

    xht-market: Open Official HollaEx Exchange's XHT trading market page.

    bug-report: Report a bug you found on HollaEx GitHub.

    version: Print out current installed version of HollaEx CLI.

EOF
}

function dev_print_usage() {
/bin/cat << EOF

# All 'hollaex dev' commands should be run at HollaEx Core directory.

Usage : 
    hollaex [ dev ] (--flags)

General Flags :
    --skip, Run command without user's double confirmation.

Options:
    --command: Run Docker-Compose commands. (up, down, stop, --build)

    --database_init: Run database initialization scripts.

EOF
}

function print_network_usage() {
/bin/cat << EOF

# All 'hollaex network' commands should be run at HollaEx Network Home.

Usage : 
    hollaex network [ setup ] [ start ] [ stop ] [ restart ] [ upgrade ] [ terminate ] [ add_coin / add_trading_pair ] [ change_coin_owner / change_trading_pair_owner ] [ activate_coin / activate_trading_pair ] (--flags)

General Flags :
    --skip, Run command without user's double confirmation.
    --kube, Set HollaEx CLI to target Kubernetes. Make sure to setup your local kubectl before using it.

EOF
}

if [[ "$1" == "dev" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --command)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_DEV_MANUAL_COMMAND=true
                LOCAL_COMMAND=$1
                echo "Your docker-compose command : $LOCAL_COMMAND."
                shift; continue
                ;;
            --server)
                HOLLAEX_DEV_TARGET="server"
                shift; continue
                ;;
            --web)
                HOLLAEX_DEV_TARGET="web"
                shift; continue
                ;;
            --setup)
                HOLLAEX_DEV_SETUP=true
                shift; continue
                ;;
            --start)
                HOLLAEX_DEV_START=true
                LOCAL_COMMAND=start
                shift; continue
                ;;
            --stop)
 
                HOLLAEX_DEV_STOP=true
                LOCAL_COMMAND=stop
                shift; continue
                ;;
            --restart)

                HOLLAEX_DEV_RESTART=true
    
                shift; continue
                ;;
            --terminate)

                HOLLAEX_DEV_TERMINATE=true
                LOCAL_COMMAND=down
                shift; continue
                ;;
            --database_init)
                LOCAL_DATABASE_INIT=true
                echo 'Local database initialization enabled.'
                shift; continue
                ;;
            --test)
                LOCAL_CODE_TEST=true
                echo 'Local mocha code test mode enabled.'
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo 'Skipping the command confirmation.'
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                dev_print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    IS_DEVELOP=true

    HOLLAEX_CLI_INIT_PATH=$(pwd)
    CONFIG_FILE_PATH=$(pwd)/settings/*
    TEMPLATE_GENERATE_PATH=$(pwd)/templates
    INIT_PATH_CHECK=$(pwd)/.hollaex

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    
    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

            export SECRET_FILE_PATH=$i

        fi

    done

    if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
        mkdir $TEMPLATE_GENERATE_PATH/local;
    fi

    if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
        mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
    fi

    if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
        mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
    fi
    
    # Running database jobs for local db.
    if [[ ! "$LOCAL_COMMAND" ]] && [[ "$LOCAL_DATABASE_INIT" == true ]]; then
    
        local_database_init start;

        docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml restart

        exit 0;

    fi

    # Gives warning if the target has not been specified.
    if [[ ! "$HOLLAEX_DEV_TARGET" ]]; then

        echo -e "\nWarning: You didn't specify the dev command target!"
        echo "You should specify the targer by using '--server' or '--web'."

        echo -e "\nAutomatically setting up the target as '--server'...\n"

        export HOLLAEX_DEV_TARGET=server

    fi 

    if [[ "$HOLLAEX_DEV_TARGET" == "server" ]]; then 

        # if [[ "$HOLLAEX_DEV_SETUP" ]]; then 

        # #     hollaex_setup_initialization;

        # # fi

        # if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then
    
        #     if [[ "$HOLLAEX_DEV_FOR_CORE" ]]; then
                
        #         generate_local_docker_compose_for_core_dev;

        #     else    

        #         generate_local_docker_compose_for_dev;

        #     fi

        # fi

        generate_nginx_upstream;

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then
            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else
            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        if [[ "$HOLLAEX_DEV_SETUP" ]]; then

            CONTINUE_WITH_PRECONFIGURED_VALUES=false         

            BUILD_HOLLAEX_CORE_VERSION=$HOLLAEX_CONFIGMAP_KIT_VERSION
            BUILD_HOLLAEX_CORE_BRANCH=$(git --git-dir $HOLLAEX_CLI_INIT_PATH/.git rev-parse --abbrev-ref HEAD)
            BUILD_HOLLAEX_CORE_DATE="$(echo $(date +%y%m%d%H%M))"

            BUILD_HOLLAEX_CORE_IMAGE_TAG="$(cat $HOLLAEX_CLI_INIT_PATH/server/package.json | jq -r '.version')-${BUILD_HOLLAEX_CORE_BRANCH}-${BUILD_HOLLAEX_CORE_DATE}"
            export ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE=$BUILD_HOLLAEX_CORE_IMAGE_TAG

            override_docker_image_version;

            export ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION=$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE

            build_user_hollaex_core;

            hollaex_setup_initialization;

            if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then
    
                if [[ "$HOLLAEX_DEV_FOR_CORE" ]]; then
                    
                    generate_local_docker_compose_for_core_dev;

                else    

                    generate_local_docker_compose_for_dev;

                fi

            fi
                        
            #Generating random values for passwords and update config file to contain it;
            update_random_values_to_config;

            # Randomly generates backend passwords
            if [[ ! "$HOLLAEX_SECRET_REDIS_PASSWORD" ]] || [[ ! "$HOLLAEX_SECRET_PUBSUB_PASSWORD" ]] || [[ ! "$HOLLAEX_SECRET_DB_PASSWORD" ]] ; then
            
                generate_backend_passwords;

            fi

            for i in ${CONFIG_FILE_PATH[@]}; do
                source $i
            done;

            load_config_variables;

            generate_local_env;

            # Regenerating docker compose file with the new image tag just defined above.
            if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then
        
                if [[ "$HOLLAEX_DEV_FOR_CORE" ]]; then
                    
                    generate_local_docker_compose_for_core_dev;

                else    

                    generate_local_docker_compose_for_dev;

                fi

            fi

            docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml up -d  
            
            echo "Installing npm packages for /plugins"
            docker exec ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server-api_1 bash -c '
                cd /app/plugins && \
                npm install --loglevel=error && \
                for d in ./*/ ; do (cd "$d" && npm install --loglevel=error); done'

            hollaex dev --database_init
        
            docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml restart

            hollaex_setup_finalization;

            docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml restart
            
            
        elif [[ "$HOLLAEX_DEV_RESTART" ]]; then

            docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml stop
            docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml up -d

            if [[ ! "$HOLLAEX_DEV_SETUP" ]]; then

                echo "Installing npm packages for /plugins"
                docker exec ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server-api_1 bash -c '
                    cd /app/plugins && \
                    npm install --loglevel=error && \
                    for d in ./*/ ; do (cd "$d" && npm install --loglevel=error); done'
            fi 

        else 

            docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml $LOCAL_COMMAND

        fi

    # WEB
    elif [[ "$HOLLAEX_DEV_TARGET" == "web" ]]; then 

        generate_hollaex_web_local_env

        cd web
        
        if [[ "$HOLLAEX_DEV_SETUP" ]]; then
            
            npm install
            npm run start

        elif [[ "$HOLLAEX_DEV_START" ]]; then

            npm run start

        else 

            echo -e "\nError: Invalid Command."
            echo -e "Supported commands for the web: '--setup', '--start'.\n"

        fi

    fi

    exit 0;

elif [[ "$1" == "network" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --setup)
                export HOLLAEX_NETWORK_SETUP=true
                hollaex setup ${@:2}
                exit 0;
                shift; continue
                ;;
            --start)
                export HOLLAEX_NETWORK_START=true
                hollaex start ${@:2}
                exit 0;
                shift; continue
                ;;
            --stop)
                export HOLLAEX_NETWORK_STOP=true
                hollaex stop ${@:2}
                exit 0;
                shift; continue
                ;;
            --restart)
                export HOLLAEX_NETWORK_RESTART=true
                hollaex restart ${@:2}
                exit 0;
                shift; continue
                ;;
            --upgrade)
                export HOLLAEX_NETWORK_UPGRADE=true
                hollaex apply ${@:2}
                exit 0;
                shift; continue
                ;;
            --terminate)
                export HOLLAEX_NETWORK_TERMINATE=true
                hollaex terminate ${@:2}
                exit 0;
                shift; continue
                ;;
            --prod)
                export HOLLAEX_NETWORK_PROD=true
                hollaex prod ${@:2}
                exit 0;
                shift; continue
                ;;
             --status)
                export HOLLAEX_NETWORK_STATUS=true
                hollaex status ${@:2}
                exit 0;
                shift; continue
                ;;
            --add_coin)
                ADD_COIN=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to add new coin on your existing HollaEx Network."
                shift; continue
                ;;
            --add_trading_pair)
                ADD_TRADING_PAIR=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to add new trading pair on your existing HollaEx Network."
                shift; continue
                ;;
            --remove_coin)
                REMOVE_COIN=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to remove coin on your existing HollaEx Network."
                shift; continue
                ;;
            --remove_trading_pair)
                REMOVE_TRADING_PAIR=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to remove trading pair on your existing HollaEx Network."
                shift; continue
                ;;
            --change_coin_owner)
                CHANGE_COIN_OWNER=true
                TOOLBOX_ENABLE=true
                shift; continue
                ;;
            --change_trading_pair_owner)
                CHANGE_PAIR_OWNER=true
                TOOLBOX_ENABLE=true
                shift; continue
                ;;
            --activate_coin)
                ACTIVATE_COIN=true
                TOOLBOX_ENABLE=true
                shift; continue
                ;;
            --activate_trading_pair)
                ACTIVATE_PAIR=true
                TOOLBOX_ENABLE=true
                shift; continue
                ;;
            --is_hollaex_setup)
                IS_HOLLAEX_SETUP=true
                shift; continue
                ;;
            --backup)
                HOLLAEX_NETWORK_BACKUP=true
                hollaex toolbox --backup --network ${@:2}
                exit 0;
                shift; continue
                ;;
            --restore)
                HOLLAEX_NETWORK_RESTORE=true
                hollaex toolbox --restore ${@:2}
                exit 0;
                shift; continue
                ;;
            --tag)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE=$1
                echo "Target Docker Image tag: $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo 'Skipping the command confirmation.'
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_network_usage;
                exit 1;
                shift; continue
                ;;
        esac
        shift
    done

    source $SCRIPTPATH/tools_generator.sh

    HOLLAEX_CLI_INIT_PATH=$(pwd)
    CONFIG_FILE_PATH=$(pwd)/settings/*
    TEMPLATE_GENERATE_PATH=$(pwd)/templates
    INIT_PATH_CHECK=$(pwd)/.hollaex-network

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    if [[ "$ADD_COIN" ]]; then

        if [[ "$IS_HOLLAEX_SETUP" ]]; then

            echo "Adding user custom currencies on the exchange..."

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "ENVIRONMENT_USER_HOLLAEX_CORE_" $i > /dev/null ; then

                    export CONFIGMAP_FILE_PATH=$i

                fi

            done

            IFS=',' read -ra CUSTOM_CURRENCIES_TO_ADD <<< "$HOLLAEX_CONFIGMAP_CURRENCIES"

            for j in ${CUSTOM_CURRENCIES_TO_ADD[@]}; do

                if command grep -q $j $CONFIGMAP_FILE_PATH > /dev/null; then

                    export COIN_CODE=$j
                    export VALUE_IMPORTED_FROM_CONFIGMAP=true

                    if command grep -q "ENVIRONMENT_ADD_COIN_$(echo $j | tr a-z A-Z)_" $CONFIGMAP_FILE_PATH > /dev/null ; then

                        printf "\033[92mCoin configurations for $j has been detected at user's configmap file!\033[39m\n"
                        echo "Proceeding to add..."

                        add_coin_exec;
                    
                    else 

                        printf "\033[91mError: Coin configurations for $j doesn't exists at user's configmap file.\033[39m\n"
                        echo "Skipping to add..."

                    fi
                
                fi
            
            done

            if [[ "$USE_KUBERNETES" ]]; then

                kubernetes_database_init upgrade;

            else 

                echo "Running database triggers"
                docker exec --env "CURRENCIES=${HOLLAEX_CONFIGMAP_CURRENCIES}" ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX[0]}_1 node tools/dbs/runTriggers.js > /dev/null;
            
            fi
             
        elif [[ "$IS_COIN_CODE_PASSED" ]]; then

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "ENVIRONMENT_USER_HOLLAEX_CORE_" $i > /dev/null ; then

                    export CONFIGMAP_FILE_PATH=$i

                fi

            done

            IFS=',' read -ra CUSTOM_CURRENCIES_TO_ADD <<< "$PASSED_COIN_CODE"

            for j in ${CUSTOM_CURRENCIES_TO_ADD[@]}; do
                
                for i in ${CONFIG_FILE_PATH[@]}; do
                    source $i
                done;

                if [[ $(echo $j | grep $HOLLAEX_CONFIGMAP_CURRENCIES) ]]; then

                    echo "Error: Coin $j is already exists on your exchange."
                    exit 1;

                fi
                
                COIN_CODE=$j
                COIN_FULLNAME=$(echo $j | tr a-z A-Z)
                COIN_ALLOW_DEPOSIT=true
                COIN_ALLOW_WITHDRAWAL=true
                COIN_WITHDRAWAL_FEE=0.01
                COIN_MIN=0.01
                COIN_MAX=10000
                COIN_INCREMENT_UNIT=0.001
                COIN_ACTIVE=true
                
                add_coin_exec;
                   
            done

        else 

            printf "\033[93mWarning: Adding new coin requires full restart of the exchange!\033[39m\n"
            echo "Please double confirm that you are good to proceed"
            
            add_coin_input;

            add_coin_exec;
        
        fi
        
    elif [[ "$REMOVE_COIN" ]]; then

        printf "\033[93mWarning: Removing new coin requires full restart of the exchange!\033[39m\n"
        echo "Please double confirm that you are good to proceed"

        if [[ "$IS_COIN_CODE_PASSED" ]]; then

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "ENVIRONMENT_USER_HOLLAEX_CORE_" $i > /dev/null ; then

                    export CONFIGMAP_FILE_PATH=$i

                fi

            done

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "ENVIRONMENT_USER_HOLLAEX_CORE_" $i > /dev/null ; then

                    export CONFIGMAP_FILE_PATH=$i

                fi

            done

            IFS=',' read -ra CUSTOM_CURRENCIES_TO_REMOVE <<< "$PASSED_COIN_CODE"

            for j in ${CUSTOM_CURRENCIES_TO_REMOVE[@]}; do

                for i in ${CONFIG_FILE_PATH[@]}; do
                    source $i
                done;

                if [[ ! $(echo $HOLLAEX_CONFIGMAP_CURRENCIES | grep $j) ]]; then

                    echo "Error: Coin $j doesn't exists on your exchange."
                    exit 1;

                fi
                
                COIN_CODE=$j

                remove_coin_exec;
                   
            done

        else 
            
            remove_coin_input;

            remove_coin_exec;
        
        fi
    
    elif [[ "$ADD_TRADING_PAIR" ]]; then

        if [[ "$IS_HOLLAEX_SETUP" ]]; then

            echo "Adding user custom trading pairs on the exchange..."

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "ENVIRONMENT_USER_HOLLAEX_CORE_" $i > /dev/null ; then

                    export CONFIGMAP_FILE_PATH=$i

                fi

            done

            IFS=',' read -ra CUSTOM_PAIRS_TO_ADD <<< "$HOLLAEX_CONFIGMAP_PAIRS"

            for j in ${CUSTOM_PAIRS_TO_ADD[@]}; do

                if command grep -q $j $CONFIGMAP_FILE_PATH > /dev/null; then

                    export PAIR_CODE=$j
                    export PAIR_BASE=$(echo $j | cut -f1 -d "-")
                    export PAIR_2=$(echo $j | cut -f2 -d "-")
                    export PAIR_PREFIX=$(echo $PAIR_BASE | tr a-z A-Z)_$(echo $PAIR_2 | tr a-z A-Z)
     
                    export VALUE_IMPORTED_FROM_CONFIGMAP=true

                    if command grep -q "ENVIRONMENT_ADD_PAIR_$(echo $PAIR_PREFIX)_" $CONFIGMAP_FILE_PATH > /dev/null ; then

                        printf "\033[92mTrading pair configurations for $j has been detected at user's configmap file!\033[39m\n"
                        echo "Proceeding to add..."

                        add_pair_exec;
                    
                    else 

                        printf "\033[91mError: Trading pair configurations for $j doesn't exists at user's configmap file.\033[39m\n"
                        echo "Skipping to add..."
                    
                    fi
                
                fi
            
            done

            if [[ "$USE_KUBERNETES" ]]; then

                kubernetes_database_init upgrade;

            else 

                echo "Running database triggers"
                docker exec --env "PAIRS=${HOLLAEX_CONFIGMAP_PAIRS}" ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX[0]}_1 node tools/dbs/runTriggers.js > /dev/null;
            
            fi

        elif [[ "$IS_PAIR_CODE_PASSED" ]]; then

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "ENVIRONMENT_USER_HOLLAEX_CORE_" $i > /dev/null ; then

                    export CONFIGMAP_FILE_PATH=$i

                fi

            done

            IFS=',' read -ra CUSTOM_PAIRS_TO_ADD <<< "$PASSED_PAIR_CODE"

            for j in ${CUSTOM_PAIRS_TO_ADD[@]}; do

                for i in ${CONFIG_FILE_PATH[@]}; do
                    source $i
                done;

                if [[ $(echo $j | grep $HOLLAEX_CONFIGMAP_PAIRS) ]]; then

                    echo "Error: Pair $j is already exists on your exchange."
                    exit 1;

                fi
                
                PAIR_CODE=$j
                PAIR_BASE=$(echo $PAIR_CODE | cut -f1 -d '-')
                PAIR_2=$(echo $PAIR_CODE | cut -f2 -d '-')
                MIN_SIZE=0.00001
                MAX_SIZE=10000000
                MIN_PRICE=0.000001
                MAX_PRICE=1000000
                INCREMENT_SIZE=0.001
                INCREMENT_PRICE=0.001
                PAIR_ACTIVE=true
                TAKER_FEES=$(join_array_to_json $(for ((i=1;i<=$HOLLAEX_CONFIGMAP_USER_LEVEL_NUMBER;i++)); do echo -n "$i " ; done;))
                MAKER_FEES=$(join_array_to_json $(for ((i=1;i<=$HOLLAEX_CONFIGMAP_USER_LEVEL_NUMBER;i++)); do echo -n "$i " ; done;))
                
                add_pair_exec;
                   
            done

        else 

            printf "\033[93mWarning: Adding new pair requires full restart of the exchange!\033[39m\n"
            echo "Please double confirm that you are good to proceed"
            
            add_pair_input;

            add_pair_exec;
        
        fi

    elif [[ "$REMOVE_TRADING_PAIR" ]]; then

        printf "\033[93mWarning: Removing new pair requires full restart of the exchange!\033[39m\n"
        echo "Please double confirm that you are good to proceed"

        if [[ "$IS_PAIR_CODE_PASSED" ]]; then

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "ENVIRONMENT_USER_HOLLAEX_CORE_" $i > /dev/null ; then

                    export CONFIGMAP_FILE_PATH=$i

                fi

            done 

            IFS=',' read -ra CUSTOM_PAIRS_TO_REMOVE <<< "$PASSED_PAIR_CODE"

            for j in ${CUSTOM_PAIRS_TO_REMOVE[@]}; do

                for i in ${CONFIG_FILE_PATH[@]}; do
                    source $i
                done;

                if [[ ! $(echo $HOLLAEX_CONFIGMAP_PAIRS | grep $j) ]]; then

                    echo "Error: Pair $j doesn't exists on your exchange."
                    exit 1;

                fi
                
                PAIR_CODE=$j
                PAIR_BASE=$(echo $PAIR_CODE | cut -f1 -d '-')
                PAIR_2=$(echo $PAIR_CODE | cut -f2 -d '-')
                
                remove_pair_exec;
                   
            done
        else 
        
            remove_pair_input;

            remove_pair_exec;
        
        fi 

    elif [[ "$CHANGE_COIN_OWNER" ]]; then
            
        change_coin_owner_input;

        change_coin_owner_exec;
    
    elif [[ "$CHANGE_PAIR_OWNER" ]]; then

        change_pair_owner_input;

        change_pair_owner_exec;

    elif [[ "$ACTIVATE_COIN" ]]; then

        activate_coin_input;

        activate_coin_exec;
    
    elif [[ "$ACTIVATE_PAIR" ]]; then

        activate_pair_input;

        activate_pair_exec;

    else 

        print_network_usage;

        exit 1;

    fi

    exit 0;

elif [[ "$1" == "init" ]]; then

    HOLLAEX_CLI_INIT_PATH=$(pwd)
    CONFIG_FILE_PATH=$(pwd)/settings/*
    TEMPLATE_GENERATE_PATH=$(pwd)/templates
    INIT_PATH_CHECK=$(pwd)/.hollaex
    TEMP_CONFIG_FILE=$(pwd)/settings/temp

    source $SCRIPTPATH/tools_generator.sh

    hollaex_setup_existing_settings_values_check;

    # if [[ -f "$TEMP_CONFIG_FILE" ]]; then 
        
    #     source $(pwd)/settings/configmap
    #     source $(pwd)/settings/temp

    #     echo -e "\n\033[93mWarning: HollaEx CLI has detected your existing exchange information.\033[39m\n"
    #     echo "Network: $HOLLAEX_CONFIGMAP_NETWORK_URL"
    #     echo "Network Exchange ID: $HOLLAEX_CONFIGMAP_ADMIN_NETWORK_ID"
    #     echo "Exchange Name: $ENVIRONMENT_EXCHANGE_NAME"
    #     echo "Admin Email: $HOLLAEX_CONFIGMAP_ADMIN_EMAIL"
    #     echo "Admin Password: $(echo ${HOLLAEX_CONFIGMAP_ADMIN_PASSWORD//?/◼︎}$(echo $HOLLAEX_CONFIGMAP_ADMIN_PASSWORD | grep -o '....$'))"

    #     echo -e "\nDo you want to continue with the existing information? (Y/n)"
    #     read answer

    #     if [[ ! "$answer" = "${answer#[Nn]}" ]]; then

    #         echo "Proceeding to the initialization wizard..."
        
    #     else 

    #         echo "Skipping the initialization wizard..."
    #         exit 0
                    
    #     fi 

    # fi 

    printf "\n\033[1mSelect the network\033[0m\n\n"

    echo -e "Before you continue, You need to \033[1mselect the network\033[0m that you want to use with the exchange."
    echo -e "HollaEx Kit by default, will be connected to the official \033[1mmainnet\033[0m HollaEx Network (\033[1mapi.hollaex.network\033[0m)." 
    echo -e "You can also run HollaEx Kit with official \033[1mtestnet\033[0m HollaEx Network for testing purpose (\033[1mapi.testnet.hollaex.network\033[0m)."
    echo -e "If you want to connect to a different custom network, you can type the URL.\n"
    # echo -e "Do you want to want to continue with the official HollaEx Network? (Y/n)\n"
    # read answer

    flag=1

    list=(
    "1) $(echo -e '\033[1mMainnet\033[0m') HollaEx Network"
    "2) Testnet HollaEx Network"
    "3) Custom HollaEx Network
    "
    )

    message()
    {
        echo
        printf "%s\n" "${list[@]}"
        read -p "Please select the network: " networkOption
        echo
    }
    message


    while [[ $flag = '1' ]]  
    do
    {
        case $networkOption in
            1)
                export hollaexAPIURL=https://api.hollaex.network
                export networkType="mainnet"
                flag=0
                ;;
            2)
                export hollaexAPIURL=https://api.testnet.hollaex.network
                export networkType="testnet"
                flag=0
                ;;
            3)  
                export networkType="custom"
                echo "***************************************************************"
                printf "\nPlease type the URL of your custom network including 'http' or 'https'. (Example: https://api.hollaex.network)\n"
                read hollaexAPIURL

                while true;
                    do if [[ ! "$hollaexAPIURL" == *"http"* ]]; then
                        printf "\nPlease confirm that you typed in a correct url, including 'http' or 'https'.\n"
                        echo  "Custom Network API URL: "
                        read hollaexAPIURL
                    else 
                        break;
                    fi
                done
                flag=0
                ;;
            *)
                echo "Error: Invalid Option. Please select it again."
                flag=1
                message
                
                ;;
        esac
    }
    done

    if [[ "$hollaexAPIURL" == *"localhost"* ]]; then 

        export HOLLAEX_INIT_LOCALHOST_MODE_INTERNAL_URL="http://hollaex-network-nginx"
        export hollaexAPIURLEscaped=${HOLLAEX_INIT_LOCALHOST_MODE_INTERNAL_URL//\//\\/}

        export HOLLAEX_NETWORK_LOCALHOST_MODE=true

    else
    
        export hollaexAPIURLEscaped=${hollaexAPIURL//\//\\/}

    fi

    # Network URL health check
    while true;
        do if command curl $hollaexAPIURL/v2/health; then
            printf "\n\033[92mSuccessfully reached to the network health page.\033[39m\n"
            break;
        else 
            printf "\033[91m\nNetwork health page is not responding.\033[39m\n"
            echo "Please try it again after you check the URL."
            exit 1;
        fi
    done

    printf "\n"
    echo "${hollaexAPIURL} ✔"
    printf "\n"

    if [[ $networkType == "mainnet" ]]; then 

        echo "***************************************************************"
        echo -e "All HollaEx Kit connected to the Mainnet HollaEx Network require to have an account on HollaEx Dashboard.\n"
        echo -e "If you already have an account, please proceed to login."
        echo -e "For registration, please check out https://dash.hollaex.com."

        echo -e "\nDo you have an account on HollaEx Dashboard? (y/N)"

        read answer

        if [[ "$answer" = "${answer#[Yy]}" ]]; then


            echo -e "Please sign up on HollaEx Dashboard through https://dash.hollaex.com/signup.\n"

            if [[ "$OSTYPE" == *"darwin"* ]]; then 

                open https://dash.hollaex.com/signup
            
            else 

                if ! command xdg-open https://dash.hollaex.com/signup > /dev/null 2>&1; then 

                    echo "Error: Your system does not support xdg-open compatible browser."
                    echo "Please open HollaEx Dashboard (https://dash.hollaex.com/signup) by yourself, and continue to sign-up."

                fi 

            fi

            echo -e "\nOnce the registration and the DIY exchange setup are completed, please press C to continue."
            read answer

            while true;

                do if [[ "$answer" = "${answer#[Cc]}" ]]; then
                
                    echo -e "\nOnce the registration is completed, please press C to continue."
                    read answer

                else

                    break;

                fi
            
            done
               
        fi 

        while true;
            do if ! command hollaex login; then 
                
                rm -f $(pwd)/.token

            else 

                if ! command hollaex pull --skip; then 

                    exit 1;
                
                fi 

                break;
            
            fi 

        done 

    else

        printf "\n\033[1mCreate Admin\033[0m\n\n"
        echo -e "Please type your email address and password that you are going to use for your admin account.\n"
        echo "Email: "
        read hollaexAdminEmail
        echo "Password: "
        read -s hollaexAdminPassword

        while true;
            do if [[ ! "$hollaexAdminEmail" == *"@"* ]]; then 
                printf "\nInvalid email address. Please type it again.\n"
                echo "Email: "
                read hollaexAdminEmail
            else
                break;
            fi
        done

        printf "\n\033[1mCreate Exchange\033[0m\n\n"

        echo -e "Please type in the name of your new exchange."
        printf "\033[2m- Alphanumeric, Dash (-), Underscore Only (_). No space or special character allowed.\033[22m\n" 
        read hollaexExchangeName

        while true;
            do if [[ ! "$hollaexExchangeName" =~ ^[A-Za-z0-9_-]+$ ]]; then 
                printf "\nInvalid Exchange Name. Make sure to input Alphanumeric, Dash (-), Underscore Only (_).\n"
                echo "New Exchange Name: "
                read hollaexExchangeName
            else
                break;
            fi
        done

        printf "\n"
        echo "$hollaexExchangeName ✔"
        printf "\n"

        HOLLAEX_INIT_REQUEST=$(curl -s -H "Content-Type: application/json" \
            -w ";%{http_code}" \
            --request POST \
            --data "{\"email\": \"${hollaexAdminEmail}\", \"password\": \"${hollaexAdminPassword}\", \"exchange_name\": \"${hollaexExchangeName}\"}" \
            $hollaexAPIURL/v2/network/exchange)

        # echo $HOLLAEX_INIT_REQUEST

        HOLLAEX_INIT_REQUEST_RESPONSE=$(echo $HOLLAEX_INIT_REQUEST | cut -f1 -d ";")
        HOLLAEX_INIT_REQUEST_HTTP_CODE=$(echo $HOLLAEX_INIT_REQUEST | cut -f2 -d ";")

        # Creating an admin account with exchange
        if [[ ! "$HOLLAEX_INIT_REQUEST_HTTP_CODE" == "200" ]]; then
        
            echo $HOLLAEX_INIT_REQUEST_RESPONSE | jq -r '.message'

            echo -e "\nError: Failed to create an account on HollaEx Network."
            echo "Please review the logs and try it again."
            exit 1;
        
        fi

        export HOLLAEX_SECRET_API_KEY=$(echo $HOLLAEX_INIT_REQUEST_RESPONSE | jq -r '.token.apiKey')
        export HOLLAEX_SECRET_API_SECRET=$(echo $HOLLAEX_INIT_REQUEST_RESPONSE | jq -r '.token.secret')
        export HOLLAEX_SECRET_ACTIVATION_CODE=$(echo $HOLLAEX_INIT_REQUEST_RESPONSE | jq -r '.exchange.activation_code')    
        export HOLLAEX_CONFIGMAP_ADMIN_NETWORK_ID=$(echo $HOLLAEX_INIT_REQUEST_RESPONSE | jq -r '.user.id')

        # Update settings files with provided values
        for i in ${CONFIG_FILE_PATH[@]}; do
            if command grep -q "ENVIRONMENT_EXCHANGE_NAME" $i > /dev/null ; then
                CONFIGMAP_FILE_PATH=$i
                sed -i.bak "s/ENVIRONMENT_EXCHANGE_NAME=.*/ENVIRONMENT_EXCHANGE_NAME=$hollaexExchangeName/" $CONFIGMAP_FILE_PATH
                sed -i.bak "s/HOLLAEX_CONFIGMAP_API_NAME=.*/HOLLAEX_CONFIGMAP_API_NAME=$hollaexExchangeName/" $CONFIGMAP_FILE_PATH
                sed -i.bak "s/HOLLAEX_CONFIGMAP_NETWORK_URL=.*/HOLLAEX_CONFIGMAP_NETWORK_URL=$hollaexAPIURLEscaped/" $CONFIGMAP_FILE_PATH

                rm $CONFIGMAP_FILE_PATH.bak
            fi
            if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE" $i > /dev/null ; then
                SECRET_FILE_PATH=$i
                sed -i.bak "s/HOLLAEX_SECRET_ACTIVATION_CODE=.*/HOLLAEX_SECRET_ACTIVATION_CODE=$HOLLAEX_SECRET_ACTIVATION_CODE/" $SECRET_FILE_PATH
                sed -i.bak "s/HOLLAEX_SECRET_API_KEY=.*/HOLLAEX_SECRET_API_KEY=$HOLLAEX_SECRET_API_KEY/" $SECRET_FILE_PATH
                sed -i.bak "s/HOLLAEX_SECRET_API_SECRET=.*/HOLLAEX_SECRET_API_SECRET=$HOLLAEX_SECRET_API_SECRET/" $SECRET_FILE_PATH
                rm $SECRET_FILE_PATH.bak
            fi
        done

        # Store Network ID, Admin email and password to a temporary file
        echo "HOLLAEX_CONFIGMAP_ADMIN_NETWORK_ID=$HOLLAEX_CONFIGMAP_ADMIN_NETWORK_ID" > $(pwd)/settings/temp
        echo "HOLLAEX_CONFIGMAP_ADMIN_EMAIL=$hollaexAdminEmail" >> $(pwd)/settings/temp
        echo "HOLLAEX_CONFIGMAP_ADMIN_PASSWORD=$hollaexAdminPassword" >> $(pwd)/settings/temp

        echo -e "\n\033[92mSuccessfully initialized the exchange $hollaexExchangeName and the account $hollaexAdminEmail.\033[39m"
    
    fi 

    echo "HOLLAEX_CONFIGMAP_NETWORK_URL=$hollaexAPIURL" > $INIT_PATH_CHECK

    if [[ ! "$HOLLAEX_IS_SETUP" ]]; then 
        
        echo "Please run 'hollaex server --setup' command to set up the exchange."
    
    fi 

    echo -e "\nHave fun!"

    exit 0;

elif [[ "$1" == "server" ]]; then
    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --setup)
                hollaex setup ${@:2}
                break
                ;;
            --start)
                hollaex start ${@:2}
                break
                ;;
            --stop)
                hollaex stop ${@:2}
                break   
                ;;
            --restart)
                hollaex restart ${@:2}
                break   
                ;;
            --scale)
                hollaex scale ${@:2}
                break   
                ;;
            --upgrade)
                hollaex upgrade ${@:2}
                break
                ;;
            --build)
                hollaex build ${@:2}
                break
                ;;
            --apply)
                hollaex apply ${@:2}
                break
                ;;
            --terminate)
                hollaex terminate ${@:2}
                break
                ;;
            --*) 
                print_usage;
                err_msg "Invalid option: $1"
                exit 1;
                ;;
        esac
        shift
    done

    
elif [[ "$1" == "setup" ]]; then
    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_DOCKER_IMAGE_REGISTRY_OVERRIDE=$1
                echo "Target hollaex docker registry : $ENVIRONMENT_DOCKER_IMAGE_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --force)
                export HOLLAEX_SETUP_FORCE=true
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --tag)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE=$1
                echo "Target Docker Image tag: $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE."
                shift; continue
                ;;
            --arch)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                if [[ "$1" == "amd64" ]] || [[ "$1" == "arm64v8" ]] || [[ "$1" == "s390x" ]]; then
                    export ENVIORNMENT_HOLLAEX_CPU_ARCH=$1
                    echo "Target CPU Arch: $ENVIORNMENT_HOLLAEX_CPU_ARCH."
                else 
                    echo -e "\n\033[91mError: Not supported CPU arch!\033[39m"
                    echo "Supported Arches: amd64, arm64v8, s390x."
                    echo -e "Please try it again with the supported arch name.\n"
                    exit 1;
                fi
                shift; continue
                ;;
            --*) 
                print_usage;
                err_msg "Invalid option: $1"
                exit 1;
                ;;
        esac
        shift
    done

    export HOLLAEX_IS_SETUP=true

    if [[ "$HOLLAEX_SETUP_FORCE" ]]; then

        export HOLLAEX_SETUP_FORCE=true

    fi

    source $SCRIPTPATH/tools_generator.sh

    # HollaEx Network Home folder initialization.
    if [[ "$HOLLAEX_NETWORK_SETUP" ]]; then 
        
        INIT_PATH_CHECK=$(pwd)/.hollaex-network

        if [[ -f "$INIT_PATH_CHECK" ]]; then 

            echo "Successfully detected the existing HollaEx Network Home folder."
            echo "Proceeding without creating a new Network Home."
            echo "Your Hollaex Network Home folder: $(pwd)/hollaex-network-home."
        
        else

            echo -e "\n### HollaEx Network Setup Initialization ###\n"

            echo "Generating the HollaEx Network Home folder under your current directory..."
            echo -e "Your HollaEx Network Home folder will be created at: $(pwd)/hollaex-network-home\n"

            if [[ -d "$(pwd)/hollaex-network-home" ]]; then 

                echo "Error: The folder already exists at $(pwd)/hollaex-network-home."
                echo "Please move to another directory, or remove the existing folder if it's not being used."
                exit 1;

            fi 

            mkdir $(pwd)/hollaex-network-home
            cd $(pwd)/hollaex-network-home

            echo "Current directory is: $(pwd)."

            mkdir settings
            touch settings/configmap
            touch settings/secret
            mkdir templates
            touch .hollaex-network

            # Settings up the initial envs for HollaEx Network.
            hollaex_network_setup_initial_envs;

            CONFIG_FILE_PATH=$(pwd)/settings/*
            CONFIGMAP_FILE_PATH=$(pwd)/settings/configmap
            SECRET_FILE_PATH=$(pwd)/settings/secret

            export ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_HOST=docker.io

            echo "Warning: You need to login with your Docker Hub account to proceed."
            docker_registry_login

            if [[ ! "$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE" ]]; then 

                if [[ -z "$(check_latest_hollaex_network_docker_tag)" ]] ; then 

                    echo -e "\n\033[91mError: Unable to get the latest HollaEx Network Docker image.\033[39m"
                    echo -e "Please confirm that you provided correct Docker Hub credentials, and try again.\n"
                    
                    cd ..
                    rm -r hollaex-network-home

                    exit 1;

                else 

                    echo "Latest HollaEx Network Version: v$(check_latest_hollaex_network_docker_tag)."

                fi

                sed -i.bak "s/ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION=.*/ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION=$(check_latest_hollaex_network_docker_tag)/" $CONFIGMAP_FILE_PATH


            else 

                echo "Passed HollaEx Network Version: v$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE."
                sed -i.bak "s/ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION=.*/ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION=$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE/" $CONFIGMAP_FILE_PATH

            fi 

            rm $CONFIGMAP_FILE_PATH.bak
            echo "Your HollaEx Network Home folder is all set and ready."
        
        fi

    else 

        hollaex_setup_existing_exchange_check;

        if [[ ! "$RUN_WITH_VERIFY" == false ]]; then 

            hollaex_setup_initialization;
        
        else

            echo -e "\nWarning: Skipping the exchange initialization steps."
            echo -e "Please make sure that what you are doing exactly with the '--skip' flag.\n"

        fi 

    fi  

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMP_CONFIG_FILE=$(pwd)/settings/temp
        TEMPLATE_GENERATE_PATH=$(pwd)/templates

        if [[ "$HOLLAEX_NETWORK_SETUP" ]]; then 
            INIT_PATH_CHECK=$(pwd)/.hollaex-network
        else
            INIT_PATH_CHECK=$(pwd)/.hollaex
        fi 

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMP_CONFIG_FILE=$HOLLAEX_CLI_INIT_PATH/settings/temp
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        if [[ "$HOLLAEX_NETWORK_SETUP" ]]; then 
            INIT_PATH_CHECK=$(pwd)/.hollaex-network
        else
            INIT_PATH_CHECK=$(pwd)/.hollaex
        fi 
        
    fi
    
    

    system_dependencies_check;

    check_docker_daemon_status;

    if [[ ! "$HOLLAEX_NETWORK_SETUP" ]]; then 

        if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]]; then 

            # Check Kit version compatibility range.
            check_kit_version_compatibility_range;
        
        fi 

        for i in ${CONFIG_FILE_PATH[@]}; do
            source $i
        done;

        for i in ${CONFIG_FILE_PATH[@]}; do

            if command grep -q "HOLLAEX_CONFIGMAP_API_NAME=" $i > /dev/null ; then

                export CONFIGMAP_FILE_PATH=$i

            fi

        done

        for i in ${CONFIG_FILE_PATH[@]}; do

            if command grep -q "HOLLAEX_SECRET_DB_PASSWORD=" $i > /dev/null ; then

                export SECRET_FILE_PATH=$i

            fi

        done

        # PRESET env for user initial setup config value selection
        CONTINUE_WITH_PRECONFIGURED_VALUES=false 

        # hollaex_setup_initialization;

        for i in ${CONFIG_FILE_PATH[@]}; do
            source $i
        done;

        if [[ "$ENVIORNMENT_HOLLAEX_CPU_ARCH" ]]; then 

            if [[ "$USE_KUBERNETES" ]]; then

                hollaex build --registry ${ENVIRONMENT_DOCKER_IMAGE_REGISTRY_OVERRIDE:-$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY} --kube --is_hollaex_setup --arch $ENVIORNMENT_HOLLAEX_CPU_ARCH

            else 

                hollaex build --registry ${ENVIRONMENT_DOCKER_IMAGE_REGISTRY_OVERRIDE:-$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY} --is_hollaex_setup --arch $ENVIORNMENT_HOLLAEX_CPU_ARCH

            fi

        else 

            if [[ "$USE_KUBERNETES" ]]; then

                hollaex build --registry ${ENVIRONMENT_DOCKER_IMAGE_REGISTRY_OVERRIDE:-$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY} --kube --is_hollaex_setup 

            else 

                hollaex build --registry ${ENVIRONMENT_DOCKER_IMAGE_REGISTRY_OVERRIDE:-$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY} --is_hollaex_setup 

            fi

        fi

    fi 

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    # Randomly generates backend passwords
    if [[ ! "$HOLLAEX_SECRET_REDIS_PASSWORD" ]] || [[ ! "$HOLLAEX_SECRET_PUBSUB_PASSWORD" ]] || [[ ! "$HOLLAEX_SECRET_DB_PASSWORD" ]] ; then
    
        generate_backend_passwords;

    fi
    
    #Generating random values for passwords and update config file to contain it;
    update_random_values_to_config;

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    load_config_variables;

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        #Creating kubernetes_config directory for generating config for Kubernetes.

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME"  ]] ; then
            printf "\033[91mError: Please define exchange name and Docker image version on config file before running HollaEx CLI.\033[39m\n"
            print_usage
            exit 1;
        fi

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to launch $HOLLAEX_CONFIGMAP_API_NAME v$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION ($HOLLAEX_CONFIGMAP_API_HOST) on this cluster? (Y/n)"

            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi
        
        echo "Creating namespace on Kubernetes."
        kubectl create ns $ENVIRONMENT_EXCHANGE_NAME
        
        create_kubernetes_docker_registry_secret;

        if [[ "$HOLLAEX_NETWORK_SETUP" ]]; then

            generate_hollaex_network_kubernetes_env_coins
            generate_hollaex_network_kubernetes_env_pairs

            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/${ENVIRONMENT_EXCHANGE_NAME}-env-coins.yaml
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/${ENVIRONMENT_EXCHANGE_NAME}-env-pairs.yaml

            run_and_upgrade_hollaex_network_on_kubernetes

        else 

            run_and_upgrade_hollaex_on_kubernetes

        fi 

        if [[ "$ENVIRONMENT_KUBERNETES_S3_BACKUP_CRONJOB_ACCESSKEY" ]] && [[ "$ENVIRONMENT_KUBERNETES_S3_BACKUP_CRONJOB_SECRETKEY" ]]; then

            echo "Installing PostgreSQL database backup Cronjob..."
            hollaex toolbox --set_backup_cronjob --kube --skip

        fi 

        if [[ "$HOLLAEX_NETWORK_SETUP" ]]; then

            hollaex_network_setup_finalization;

            # hollaex_ascii_network_is_up

        else 

            hollaex_setup_finalization;

            # hollaex_ascii_exchange_is_up



        fi 

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"  
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        if [[ "$HOLLAEX_CONFIGMAP_NETWORK_URL" == *"hollaex-network-nginx"* ]]; then 

            echo "Hollaex Network URL: $HOLLAEX_CONFIGMAP_NETWORK_URL"
            export HOLLAEX_NETWORK_LOCALHOST_MODE=true

        fi

        
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then

            cp -r $HOME/.hollaex-cli/local/nginx $TEMPLATE_GENERATE_PATH/local/nginx

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi

        echo "Generating docker-compose file"

        if [[ "$HOLLAEX_NETWORK_SETUP" ]]; then

            generate_local_docker_compose_for_network

        else 

            generate_local_docker_compose

        fi 

        generate_local_env

        if [[ "$HOLLAEX_NETWORK_SETUP" ]]; then

            generate_nginx_upstream_for_network
        
        else 

            generate_nginx_upstream

        fi 

        apply_nginx_user_defined_values

        # Update the nginx if the Kit got a separated domain for the API.
        if [[ ! "$HOLLAEX_CONFIGMAP_API_HOST" == "$HOLLAEX_CONFIGMAP_DOMAIN/api"]]; then

            apply_nginx_separated_kit_domains_values;
        
        fi

        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d; then
            
            sleep 5
            
            IFS=',' read -ra CONTAINER_PREFIX <<< "-${ENVIRONMENT_EXCHANGE_RUN_MODE}"

            # Confirm that the local API server is up.
            while ! [[ $(docker inspect -f "{{.Name}} {{.State.Status}}" ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX}_1) == *"running"* ]] ;
                do echo "Waiting for the containers to get fully initialized..."
                sleep 5;
            done;

            if [[ "$HOLLAEX_NETWORK_SETUP" ]]; then

                local_hollaex_network_database_init start;

            else 

                local_database_init start;

            fi

            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml restart

            if [[ "$HOLLAEX_NETWORK_SETUP" ]]; then

                hollaex_network_setup_finalization;

            else 

                hollaex_setup_finalization;

            fi 

            # Drop temp settings file for setup
            if [[ -f $TEMP_CONFIG_FILE ]]; then 

                rm $TEMP_CONFIG_FILE
            
            fi

        else 

            echo "Error: Failed to start the HollaEx server."
            echo "Please check the logs and try it again."
            
            exit 1

        fi

    fi 

    exit 0;

elif [[ "$1" == "import" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_IMPORT_PATH_INPUT=$@
                shift; continue
                ;;
            --with_aws_s3)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                TARGET_AWS_S3_BUCKET=$1
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    # HOLLAEX_IMPORT_PATH_INPUT=$@
    IFS=' ' read -ra HOLLAEX_IMPORT_PATH <<< "$HOLLAEX_IMPORT_PATH_INPUT"    #Convert string to array

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! -d "$HOLLAEX_CLI_INIT_PATH/.old" ]]; then

        mkdir $HOLLAEX_CLI_INIT_PATH/.old

    fi

# Storing current CURRENCIES and PARIS
cat > $HOLLAEX_CLI_INIT_PATH/.old/old-currencies-and-pairs <<EOL

OLD_CURRENCIES=$(echo $HOLLAEX_CONFIGMAP_CURRENCIES)
OLD_PAIRS=$(echo $HOLLAEX_CONFIGMAP_PAIRS)

EOL

    if [[ "$TARGET_AWS_S3_BUCKET" ]]; then 

        if [[ "$ENVIRONMENT_EXCHANGE_NAME" == "hollaex" ]] && [[ "$HOLLAEX_CONFIGMAP_API_NAME" == "my-hollaex-exchange" ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME" ]] ; then

            echo "Error: Your haven't typed the exchange name yet."
            echo "Please type the registered exchange name."
            echo "The name will be used to point the AWS S3 folder."
            read exchangeName
            exchangeNameParsed=$(echo $exchangeName | tr -dc '[:alnum:]\n\r' | tr '[:upper:]' '[:lower:]' | tr -d ' ')
            
            echo "Your exchange name: $exchangeNameParsed."
            echo "Do you want to proceed with this name? (Y/n)"
            read answer 

            while true;
                do if [[ ! "$answer" = "${answer#[Nn]}" ]]; then 
                    echo "Please type the registered exchange name."
                    read exchangeName
                    exchangeNameParsed=$(echo $exchangeName | tr -dc '[:alnum:]\n\r' | tr '[:upper:]' '[:lower:]' | tr -d ' ')
                    
                    echo "Your exchange name: $exchangeNameParsed."
                    echo "Do you want to proceed with this name? (Y/n)"
                    read answer
                else
                    break;
                fi
            done

            export ENVIRONMENT_EXCHANGE_NAME=$exchangeNameParsed

        fi 

        mkdir -p $HOLLAEX_CLI_INIT_PATH/.settings-temp

        echo "Pulling the settings files from s3://$TARGET_AWS_S3_BUCKET/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME AWS S3 bucket."
        if ! command aws s3 cp --recursive s3://$TARGET_AWS_S3_BUCKET/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME/ $HOLLAEX_CLI_INIT_PATH/.settings-temp; then

            echo "Error: Failed to pull the settings files from s3://$TARGET_AWS_S3_BUCKET/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME."
            echo "Please check the error logs and try again."

            exit 1;

        fi 

        export HOLLAEX_IMPORT_PATH=$HOLLAEX_CLI_INIT_PATH/.settings-temp

    fi 

    if [[ "${HOLLAEX_IMPORT_PATH[@]}" == *"json"* ]]; then

         # Returns error If 'jq' doesn't exists.
        if ! command jq --version > /dev/null 2>&1; then

            printf "\033[91mError: 'jq' (https://stedolan.github.io/jq/) has not been detected on your system.\033[39m\n"
            echo "HollaEx CLI requires 'jq' to handle certain functionalities."
            echo "Please install it first and try again."

            printf "\nFor Ubuntu (Debian) users: 'apt-get install -y jq'\n"
            printf "For macOS users with Homebrew: 'brew install jq'\n\n"

            exit 1;

        fi

        echo "Converting imported file to HollaEx CLI settings file format..."

        for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_CONFIGMAP_API_NAME=" $i > /dev/null ; then

            export CONFIGMAP_FILE_PATH=$i

        fi

        done

        for i in ${CONFIG_FILE_PATH[@]}; do

            if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

                export SECRET_FILE_PATH=$i

            fi

        done
        
        BITHOLLA_USER_EXCHANGE_LIST=$(cat $HOLLAEX_IMPORT_PATH)

        # SAVING USER ACTIVATION CODE.
        export EXCHANGE_USER_ACTIVATION_CODE=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[0].activation_code";);
        sed -i.bak "s/HOLLAEX_SECRET_ACTIVATION_CODE=.*/HOLLAEX_SECRET_ACTIVATION_CODE=${EXCHANGE_USER_ACTIVATION_CODE}/" $SECRET_FILE_PATH;
        rm $SECRET_FILE_PATH.bak

        BITHOLLA_USER_EXCHANGE_ORDER=0

        hollaex_pull_and_apply_exchange_data;

        apply_coins_config_to_settings_file;

        apply_pairs_config_to_settings_file;

        if command grep -q "ENVIRONMENT_ADD_COIN_${COIN_PREFIX}_COIN" $CONFIGMAP_FILE_PATH > /dev/null && command grep -q "ENVIRONMENT_ADD_PAIR_${PAIR_PREFIX}" $CONFIGMAP_FILE_PATH > /dev/null; then

            IS_IMPORT_SUCCESS=true

        else 

            IS_IMPORT_SUCCESS=false

        fi

    else 

        rm $CONFIG_FILE_PATH

        for i in ${HOLLAEX_IMPORT_PATH[@]}; do

            if [[ -d "$i" ]]; then
                
                if command cp $i/* $IMPORT_FILE_PATH; then

                    IS_IMPORT_SUCCESS=true
                
                else 

                    IS_IMPORT_SUCCESS=false
                
                fi

            elif [[ -f "$i" ]]; then

                if command cp $i $IMPORT_FILE_PATH; then

                    IS_IMPORT_SUCCESS=true
                
                else 

                    IS_IMPORT_SUCCESS=false
                
                fi
            
            fi

        done;

        if [[ -d "$HOLLAEX_IMPORT_PATH" ]]; then
            
            if command cp $HOLLAEX_IMPORT_PATH/* $IMPORT_FILE_PATH; then

                IS_IMPORT_SUCCESS=true
            
            fi

        elif [[ -f "$HOLLAEX_IMPORT_PATH" ]]; then

            if command cp $HOLLAEX_IMPORT_PATH $IMPORT_FILE_PATH; then

                IS_IMPORT_SUCCESS=true
            
            fi
        
        fi

    fi

    if [[ "$IS_IMPORT_SUCCESS" == true ]]; then 

        printf "\033[92mYour settings files has been imported into your HollaEx Kit!\033[39m\n"
        echo "If you are trying to run a brand-new exchange, proceed to run 'hollaex setup'."
        echo "If you are already running the exchange, and trying to apply reconfigured files, run 'hollaex restart'."

    else 

        printf "\033[91m\nFailed to import your files into HollaEx Kit.\033[39m\n"
        echo "Please confirm that you passed the correct path of your settings files (or directory), and try again."

        exit 1;
    
    fi

    if [[ -d "$HOLLAEX_CLI_INIT_PATH/.settings-temp" ]]; then

        rm -r $HOLLAEX_CLI_INIT_PATH/.settings-temp

    fi 

elif [[ "$1" == "export" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_EXPORT_PATH_INPUT=$@
                shift; continue
                ;;
            --with_aws_s3)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                TARGET_AWS_S3_BUCKET=$1
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    # HOLLAEX_IMPORT_PATH_INPUT=$@
    IFS=' ' read -ra HOLLAEX_EXPORT_PATH <<< "$HOLLAEX_EXPORT_PATH_INPUT"    #Convert string to array

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! -d "$HOLLAEX_CLI_INIT_PATH/.old" ]]; then

        mkdir $HOLLAEX_CLI_INIT_PATH/.old

    fi


    if [[ "$TARGET_AWS_S3_BUCKET" ]]; then 

        if [[ "$ENVIRONMENT_EXCHANGE_NAME" == "hollaex" ]] && [[ "$HOLLAEX_CONFIGMAP_API_NAME" == "my-hollaex-exchange" ]]; then

            echo "Error: Your haven't typed the exchange name yet."
            echo "Please type the registered exchange name."
            echo "The name will be used to point the AWS S3 folder."
            read exchangeName
            exchangeNameParsed=$(echo $exchangeName | tr -dc '[:alnum:]\n\r' | tr '[:upper:]' '[:lower:]' | tr -d ' ')
            
            echo "Your exchange name: $exchangeNameParsed."
            echo "Do you want to proceed with this name? (Y/n)"
            read answer 

            while true;
                do if [[ ! "$answer" = "${answer#[Nn]}" ]]; then 
                    echo "Please type the registered exchange name."
                    read exchangeName
                    exchangeNameParsed=$(echo $exchangeName | tr -dc '[:alnum:]\n\r' | tr '[:upper:]' '[:lower:]' | tr -d ' ')
                    
                    echo "Your exchange name: $exchangeNameParsed."
                    echo "Do you want to proceed with this name? (Y/n)"
                    read answer
                else
                    break;
                fi
            done

            export ENVIRONMENT_EXCHANGE_NAME=$exchangeNameParsed

        fi 

        echo "Pushing the settings files to s3://$TARGET_AWS_S3_BUCKET/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME AWS S3 bucket."
        if ! command aws s3 cp --recursive $HOLLAEX_CLI_INIT_PATH/settings s3://$TARGET_AWS_S3_BUCKET/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME; then

            echo "Error: Failed to push the settings files to s3://$TARGET_AWS_S3_BUCKET/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME."
            echo "Please check the error logs and try again."

            exit 1;

        fi 

    elif [[ "$HOLLAEX_EXPORT_PATH_INPUT" ]]; then

        echo "Exporting HollaEx Kit settings files to $HOLLAEX_EXPORT_PATH_INPUT/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME."

        mkdir -p $HOLLAEX_EXPORT_PATH_INPUT/hollaex-kit-settings
        mkdir -p $HOLLAEX_EXPORT_PATH_INPUT/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME
        
        cp $HOLLAEX_CLI_INIT_PATH/settings/* $HOLLAEX_EXPORT_PATH_INPUT/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME

    fi 

    printf "\033[92mYour settings files has been exported successfully!\033[39m\n"

elif [[ "$1" == "dash" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --login)
                hollaex login ${@:2}
                break
                ;;
            --logout)
                hollaex logout ${@:2}
                break
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

elif [[ "$1" == "login" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --renew)
                HOLLAEX_LOGIN_RENEW=true
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    

    # Returns error If 'jq' doesn't exists.
    if ! command jq --version > /dev/null 2>&1; then

        printf "\033[91mError: 'jq' (https://stedolan.github.io/jq/) has not been detected on your system.\033[39m\n"
        echo "HollaEx CLI requires 'jq' to handle certain functionalities."
        echo "Please install it first and try again."

        printf "\nFor Ubuntu (Debian) users: 'apt-get install -y jq'\n"
        printf "For macOS users with Homebrew: 'brew install jq'\n\n"

        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

            export SECRET_FILE_PATH=$i

        fi

    done

    for i in ${CONFIG_FILE_PATH[@]}; do

        source $i

    done;

    source $SCRIPTPATH/tools_generator.sh

    hollaex_login_token_validate_and_issue;

    export BITHOLLA_ACCOUNT_TOKEN=$(cat $HOLLAEX_CLI_INIT_PATH/.token)

    BITHOLLA_USER_EXCHANGE_LIST=$(curl -s -H "Content-Type: application/json" -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN"\
        --request GET \
        $hollaexAPIURL/v2/exchange \
       | jq '.')
    
    BITHOLLA_USER_EXCHANGE_COUNT=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r '.count')

    # Exit with error if user doesn't have any exchange on the account.
    if [[ "$BITHOLLA_USER_EXCHANGE_COUNT" == "0" ]]; then

        printf "\n\033[91mError: You don't have any exchange on your account.\033[39m\n"
        echo "Please go to the HollaEx Dashboard (dash.hollaex.com), and do an exchange configuration first."
        
        exit 1;

    fi

    # Subtracting 1 from total count due to the array starts from 0, not from 1.
    BITHOLLA_USER_EXCHANGE_COUNT=$((BITHOLLA_USER_EXCHANGE_COUNT-1))

    printf "\n"

    if (( $BITHOLLA_USER_EXCHANGE_COUNT > 0 )); then 

        function hollaex_login_select_exchange() {

            printf "Please pick the \033[1mexchange number\033[0m you want to bind.\n\n"

            for ((i=0;i<=BITHOLLA_USER_EXCHANGE_COUNT;i++)); do 

            printf "Exchange number : \033[1m$((i+1))\033[0m\n";

            echo "Name:" $(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].name");
            echo "Activation Code:" $(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].activation_code");
            printf "\n"

            EXCHANGE_NAME_TEMP=EXCHANGE_NAME_${i}
            EXCHANGE_ACTIVATION_CODE_TEMP=EXCHANGE_ACTIVATION_CODE_${i}

            export $(echo $EXCHANGE_NAME_TEMP)=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].name";);
            export $(echo $EXCHANGE_ACTIVATION_CODE_TEMP)=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].activation_code";);

            done;

            printf "Input the exchange number: "
            read answer

            while true;
                do if [[ ! "${answer}" =~ ^[0-9]+$ ]]; then 
                    printf "\033[91m\nError: The input always should be numberic.\033[39m\n"
                    echo "Please pick the exchange number you want to bind."
                    read answer
                else
                    break;
                fi
            done

            answer=$((answer-1))

            printf "\n"
            SELECTED_EXCHANGE_NAME=EXCHANGE_NAME_${answer}
            SELECTED_EXCHANGE_ACTIVATION_CODE=EXCHANGE_ACTIVATION_CODE_${answer}

            if [[ ! "${!SELECTED_EXCHANGE_NAME}" ]] || [[ ! "${!SELECTED_EXCHANGE_ACTIVATION_CODE}" ]]; then

                printf "\033[91m\nError: Failed to read the data from the selected exchange.\033[39m\n"
                printf "Please make sure that you selected the correct number, and try again.\n\n"
                hollaex_login_select_exchange;

            fi
            
            echo -e "\033[1mYour Exchange name: ${!SELECTED_EXCHANGE_NAME}\033[0m"
            echo -e "\033[1mYour Activation code: ${!SELECTED_EXCHANGE_ACTIVATION_CODE}\033[0m"
            echo "Do you want to continue? (Y/n)"
            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then

                hollaex_login_select_exchange;

            fi
        }

        hollaex_login_select_exchange;

    else 

        export SELECTED_EXCHANGE_NAME=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[0].name";);
        export SELECTED_EXCHANGE_ACTIVATION_CODE=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[0].activation_code";);

        echo -e "\033[1mYour Exchange name: ${SELECTED_EXCHANGE_NAME}\033[0m"
        echo -e "\033[1mYour Activation code: ${SELECTED_EXCHANGE_ACTIVATION_CODE}\033[0m"

    fi 

    if [[ ! "$SELECTED_EXCHANGE_ACTIVATION_CODE" ]]; then

        export SELECTED_EXCHANGE_ACTIVATION_CODE=${!SELECTED_EXCHANGE_ACTIVATION_CODE}

    fi


    if command sed -i.bak "s/HOLLAEX_SECRET_ACTIVATION_CODE=.*/HOLLAEX_SECRET_ACTIVATION_CODE=${SELECTED_EXCHANGE_ACTIVATION_CODE}/" $SECRET_FILE_PATH; then

        rm $SECRET_FILE_PATH.bak

        printf "\n\033[92mSuccessfully bound the selected exchange to HollaEx Kit.\033[39m\n"

    else

        printf "\033[91mFailed to bind selected exchange to HollaEx Kit.\033[39m\n"
        echo "Please review the error and try again."
        exit 1;

    fi
    
    # hollaexAPIURL=$hollaexAPIURL
    # hollaex_login_form;

    if [[ "$HOLLAEX_SECRET_API_KEY" ]] && [[ "$HOLLAEX_SECRET_API_SECRET" ]]; then 

        echo -e "\n\033[92mHollaEx CLI detected that the HollaEx Network security token is already set on the settings file.\033[39m\n"

        echo "API Key: $HOLLAEX_SECRET_API_KEY"
        echo "Secret Key: $(echo ${HOLLAEX_SECRET_API_SECRET//?/◼︎}$(echo $HOLLAEX_SECRET_API_SECRET | grep -o '....$'))"
        
        echo -e "\nSkipping to issue a security token..."

    elif [[ "$HOLLAEX_LOGIN_RENEW" ]]; then 

        echo "Skipping to issue (revoke) the HMAC security token, since it's a --renew mode."

    else 

        get_hmac_token;

    fi

elif [[ "$1" == "logout" ]]; then

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    

    printf "\nAre you sure you want to \033[1mlogout\033[0m from HollaEx? (y/N)\n"
    printf "This command \033[1mwould not affect\033[0m your exchange data.\n"
    read answer

    if [[ "$answer" = "${answer#[Yy]}" ]]; then
        echo "Exiting..."
        exit 0;
    fi

    # Removing the login token
    if [[ -f "$HOLLAEX_CLI_INIT_PATH/.token" ]]; then

        rm $HOLLAEX_CLI_INIT_PATH/.token
    
    else 

        printf "\n\033[93mThere was no login data to revoke.\033[39m\n"
    
    fi

    printf "\nPlease run 'hollaex login' if you want to login back.\n"
    printf "Bye!\n\n"

elif [[ "$1" == "pull" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --renew)
                HOLLAEX_LOGIN_RENEW=true
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    

    # Returns error If 'jq' doesn't exists.
    if ! command jq --version > /dev/null 2>&1; then

        printf "\033[91mError: 'jq' (https://stedolan.github.io/jq/) has not been detected on your system.\033[39m\n"
        echo "HollaEx CLI requires 'jq' to handle certain functionalities."
        echo "Please install it first and try again."

        printf "\nFor Ubuntu (Debian) users: 'apt-get install -y jq'\n"
        printf "For macOS users with Homebrew: 'brew install jq'\n\n"

        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_CONFIGMAP_API_NAME=" $i > /dev/null ; then

            export CONFIGMAP_FILE_PATH=$i

        fi

    done

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

            export SECRET_FILE_PATH=$i

        fi

    done

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! "$HOLLAEX_SECRET_ACTIVATION_CODE" ]]; then

        printf "\033[91mFailed to read pre-bound Activation code.\033[39m\n"
        echo "'hollaex pull' works only after you successfully logged in."
        echo "Please run 'hollaex login' to sign in first."
        exit 1;
    
    fi

    if [[ "$RUN_WITH_VERIFY" == true ]]; then 

        printf "\nCurrent bound activation code: \033[92m$HOLLAEX_SECRET_ACTIVATION_CODE\033[39m\n\n"
        echo "This command will override the current Exchange settings at '/settings' folder of your HollaEx Kit."
        echo "Are you sure you want to pull the exchange settings from HollaEx Dashboard? (y/N)"
        read answer

        if [[ "$answer" = "${answer#[Yy]}" ]]; then
            echo "Exiting..."
            exit 0;
        fi
    
    fi 

    if [[ ! -f "$HOLLAEX_CLI_INIT_PATH/.token" ]]; then


        printf "\033[91mError: An access token has not been detected.\033[39m\n"
        printf "Please login with your HollaEx account to issue an access token.\n\n"
        hollaex login --renew

    fi

    if [[ -f "$HOLLAEX_CLI_INIT_PATH/.token" ]]; then

        export BITHOLLA_ACCOUNT_TOKEN=$(cat $HOLLAEX_CLI_INIT_PATH/.token)

    fi 

    BITHOLLA_USER_TOKEN_EXPIRY_CHECK=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN"\
            --request GET \
            $hollaexAPIURL/v2/exchange)


    BITHOLLA_USER_EXCHANGE_LIST=$(curl -s -H "Content-Type: application/json" -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN"\
        --request GET \
        $hollaexAPIURL/v2/exchange \
       | jq '.')

    if [[ ! "$BITHOLLA_USER_TOKEN_EXPIRY_CHECK" ]] || [[ ! "$BITHOLLA_USER_TOKEN_EXPIRY_CHECK" == "200" ]]; then

        printf "\033[91mFailed to pull the exchange data from HollaEx.\033[39m\n\n"
        printf "\033[91mError: Your access token has been expired!\033[39m\n"
        printf "Please login again with your HollaEx account to issue a new access token.\n\n"

        if ! command hollaex login --renew; then 

            exit 1;

        else
        
            export BITHOLLA_ACCOUNT_TOKEN=$(cat $HOLLAEX_CLI_INIT_PATH/.token)

            export BITHOLLA_USER_EXCHANGE_LIST=$(curl -s -H "Content-Type: application/json" -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN"\
                --request GET \
                $hollaexAPIURL/v2/exchange \
            | jq '.')

        fi

    else 

        # printf "\n\033[92mSuccessfully authenticated on HollaEx Server.\033[39m\n"
        printf "Proceeding to pull data from HollaEx...\n"

    fi

    BITHOLLA_USER_EXCHANGE_COUNT=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r '.count')

    BITHOLLA_USER_EXCHANGE_COUNT=$((BITHOLLA_USER_EXCHANGE_COUNT-1))

    for ((i=0;i<=BITHOLLA_USER_EXCHANGE_COUNT;i++)); do 

        if [[ $(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].activation_code") == "$HOLLAEX_SECRET_ACTIVATION_CODE" ]]; then

            export BITHOLLA_USER_EXCHANGE_ORDER=$i
        
        fi

    done;

    if [[ $(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$BITHOLLA_USER_EXCHANGE_ORDER].is_completed") == false ]]; then

        BITHOLLA_USER_EXCHANGE_UPDATED_DATE=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$BITHOLLA_USER_EXCHANGE_ORDER].updated_at" | cut -f1 -d "T" | tr -d '-')
        BITHOLLA_DASH_1_3_RELEASE_DATE=20200219

        printf "\n\033[91mError: Your exchange is not fully configured at HollaEx Dashboard.\033[39m\n"
        printf "Please finalize the exchange setup at HollaEx Dashboard (https://dash.hollaex.com), and try agian.\n\n"

        if (($BITHOLLA_DASH_1_3_RELEASE_DATE > $BITHOLLA_USER_EXCHANGE_UPDATED_DATE)); then

            printf "\033[1mFor the HollaEx users who updated the exchange before Feb 19th, 2020.\033[0m\n"
            printf "You should \033[1mgo through the exchange setup once more\033[0m to update your exchange status.\n"
            printf "You don't need to update any vaules on the dashboard if it's not required.\n\n"

        fi

        exit 1;

    fi

    # Avoid running cloud exchange as DIY
    if [[ "$HOLLAEX_IS_SETUP" ]] && [[ ! "$HOLLAEX_SETUP_FORCE" ]]; then 

        if [[ $(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$BITHOLLA_USER_EXCHANGE_ORDER].type") == "Cloud" ]]; then

            printf "\n\033[91mError: Your exchange is not a DIY exchange!\033[39m\n"
            printf "To manage cloud exchange, you should visit https://dash.hollaex.com.\n\n"
            printf "Note: If you are trying to run your cloud exchange as DIY for development purpose, you should create a new exchange for that.\n\n"
        
            printf "If you fully understand what you are doing, you can use 'hollaex setup --force' flag to run a force setup.\n"
            echo -e "Warning: Force proceed would potentially break your exchange settings!\n"

            exit 1;

        fi

    fi
    
    # Avoid running multiple setup
    if [[ "$HOLLAEX_IS_SETUP" ]] && [[ ! "$HOLLAEX_SETUP_FORCE" ]]; then 

        if [[ $(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$BITHOLLA_USER_EXCHANGE_ORDER].is_setup") == true ]]; then

            printf "\n\033[91mError: Your exchange has been already setup!\033[39m\n"
            printf "You can't run 'hollaex setup' multiple times for the same exchange.\n\n"
            printf "Please create a new exchange at https://dash.hollaex.com, and try it again.\n\n"

            printf "If you fully understand what you are doing, you can use 'hollaex setup --force' flag to run a force setup.\n"
            echo -e "Warning: Force proceed would potentially break your exchange settings!\n"

            exit 1;

        fi

    fi 

    hollaex_pull_and_apply_exchange_data;

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    if [[ ! "$HOLLAEX_CONFIGMAP_API_NAME" == "my-hollaex-exchange" ]] && [[ ! -z "$HOLLAEX_CONFIGMAP_API_NAME" ]]; then

        printf "\n\033[92mSuccessfully pulled and applied your exchange data to Hollaex Kit!\033[39m\n\n"

        if [[ ! "$RUN_WITH_VERIFY" ]]; then

            echo "You can now proceed to run 'hollaex setup' to initialize your brand-new exchange."
            printf "If you already have existing exchange, Please run 'hollaex restart' to apply new configurations.\n"
            
        fi

    else

        printf "\033[91mError: Failed to pull and apply data from HollaEx.\033[39m\n"
        echo "Please review the logs and try it again."
        exit 1;

    fi


elif [[ "$1" == "start" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --mode)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_DEPLOYMENT_MODE=$1
                echo "Your DEPLOYMENT MODE setup : $LOCAL_DEPLOYMENT_MODE."
                shift; continue
                ;;
            --http_port)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_LOCAL_NGINX_HTTP_PORT_UPDATE=$1
                echo "Your new local HTTP port : $ENVIRONMENT_LOCAL_NGINX_HTTP_PORT_UPDATE."
                shift; continue
                ;;
            --https_port)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_LOCAL_NGINX_HTTPS_PORT_UPDATE=$1
                echo "Your new local HTTPS port : $ENVIRONMENT_LOCAL_NGINX_HTTPS_PORT_UPDATE."
                shift; continue
                ;;
            --ignore_settings)
                IGNORE_SETTINGS=true
                echo "HollaEx CLI will ignore local settings update on restart."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi


    

    source $SCRIPTPATH/tools_generator.sh

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    # Update random secrets if env generation is enabled.
    if [[ ! "$IGNORE_SETTINGS" ]]; then 

        #Regenerate random secrets
        update_random_values_to_config;

    fi

     # Override user HollaEx Core tag if the flag is available.
    if [[ "$HOLLAEX_CORE_USER_APPLY_TAG" ]]; then
        
        override_user_docker_tag;

    fi

    load_config_variables;

    if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]]; then 

        if [[ ! "$HOLLAEX_NETWORK_START" ]]; then 

            # Check Kit version compatibility range.
            check_kit_version_compatibility_range;
        
        fi 
    
    fi 

    if [[ "$IGNORE_SETTINGS" ]]; then

        export ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE=false 
        
    fi 

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME"  ]] ; then
            printf "\033[91mError: Please define exchange name and Docker image version on config file before running HollaEx CLI.\033[39m\n"
            print_usage
            exit 1;
        fi

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        #Generating and updating settings

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE" == true ]]; then

            echo "Generating Kubernetes Configmap"
            generate_kubernetes_configmap;

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE" == true ]]; then

            echo "Generating Kubernetes Secret"
            generate_kubernetes_secret;

        fi


        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_INGRESS_ENABLE" == true ]]; then

            echo "Generating Kubernetes Ingress"
            generate_kubernetes_ingress;

        fi

        if [[ ! "$IGNORE_SETTINGS" ]]; then 

            echo "Applying configmap on the namespace"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml

            echo "Applying secret on the namespace"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml
        
        fi 

        # For scaling up exisitng Exchange on Kubernetes
        if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then

            echo "Scaling up containers on the cluster..."
            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-redis --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-db --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

            if [[ "$HOLLAEX_NETWORK_START" ]]; then 

                kubectl scale statefulset/$ENVIRONMENT_EXCHANGE_NAME-influxdb --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

                kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-job --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

                helm_dynamic_trading_paris scaleup

            else 

                kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-plugins --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

            fi 

            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-api --replicas=${ENVIRONMENT_KUBERNETES_API_SERVER_REPLICAS:-1} --namespace $ENVIRONMENT_EXCHANGE_NAME

            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-stream --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

            if [[ "$HOLLAEX_NETWORK_START" ]]; then 

                kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-job --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

            fi 

            echo "Applying Ingress rules..."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

            echo "All done!"
            echo "Containers successfully scaled up"

            if [[ "$HOLLAEX_NETWORK_START" ]]; then 

                hollaex_ascii_network_is_up;

            else 

                hollaex_ascii_exchange_is_up;
            
            fi 

            exit 0;

        else 

            echo "HollaEx CLI failed to detect existing exchange running on this Kubernetes."
            echo "Please review your settings files and targeted Kubernetes."

            exit 1;

        fi

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        # Exit HollaEx CLI If docker_compose 
        if [[ ! "$ENVIRONMENT_EXCHANGE_RUN_MODE" ]]; then

            echo "Your ENVIRONMENT_EXCHANGE_RUN_MODE value is missing! Please reconfirm your settings files."
            exit 1;

        fi 

        # Update ports for local network 
        if [[ "$ENVIRONMENT_LOCAL_NGINX_HTTP_PORT_UPDATE" ]] || [[ "$ENVIRONMENT_LOCAL_NGINX_HTTPS_PORT_UPDATE" ]]; then 

            export ENVIRONMENT_LOCAL_NGINX_HTTP_PORT=${ENVIRONMENT_LOCAL_NGINX_HTTP_PORT_UPDATE:-8081}
            export ENVIRONMENT_LOCAL_NGINX_HTTPS_PORT=${ENVIRONMENT_LOCAL_NGINX_HTTPS_PORT_UPDATE:-8082}

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "HOLLAEX_CONFIGMAP_API_NAME=" $i > /dev/null ; then

                    export CONFIGMAP_FILE_PATH=$i

                fi

            done

            sed -i.bak "s/ENVIRONMENT_LOCAL_NGINX_HTTP_PORT=.*/ENVIRONMENT_LOCAL_NGINX_HTTP_PORT=${ENVIRONMENT_LOCAL_NGINX_HTTP_PORT}/" $CONFIGMAP_FILE_PATH;
            sed -i.bak "s/ENVIRONMENT_LOCAL_NGINX_HTTPS_PORT=.*/ENVIRONMENT_LOCAL_NGINX_HTTPS_PORT=${ENVIRONMENT_LOCAL_NGINX_HTTPS_PORT}/" $CONFIGMAP_FILE_PATH;
            rm $CONFIGMAP_FILE_PATH.bak

        fi 

        if [[ "$HOLLAEX_CONFIGMAP_NETWORK_URL" == *"hollaex-network-nginx"* ]]; then 

            echo "Hollaex Network URL: $HOLLAEX_CONFIGMAP_NETWORK_URL"
            export HOLLAEX_NETWORK_LOCALHOST_MODE=true

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi
        
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE" == true ]]; then

            echo "Generating env file for docker"
            generate_local_env;

        fi  
        
        # Generating docker-compose yaml for exchange
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then
        
            echo "Generating docker-compose file"

            if [[ "$HOLLAEX_NETWORK_START" ]]; then 

                generate_local_docker_compose_for_network

            else

                generate_local_docker_compose

            fi 

        fi
        
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_NGINX_UPSTREAM" == true ]]; then

            echo "Generating Nginx upstream conf"
            
            if [[ "$HOLLAEX_NETWORK_START" ]]; then

                generate_nginx_upstream_for_network
            
            else 

                generate_nginx_upstream

            fi 
        
        fi

        # Update nginx.conf to apply user own domains
        echo "Updating nginx conf file based on user settings"
        apply_nginx_user_defined_values;
        
        # Update the nginx if the Kit got a separated domain for the API.
        if [[ ! "$HOLLAEX_CONFIGMAP_API_HOST" == "$HOLLAEX_CONFIGMAP_DOMAIN/api"]]; then

            apply_nginx_separated_kit_domains_values;
        
        fi

        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d; then

            if [[ "$HOLLAEX_NETWORK_START" ]]; then 

                hollaex_ascii_network_is_up;

            else 

                hollaex_ascii_exchange_is_up;
            
            fi 
        
        else 

            printf "\033[91mFailed to start exchange! Please review your settings and try again.\033[39m\n"
            exit 1;
        
        fi

    fi

    exit 0;

elif [[ "$1" == "scale" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --target)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_SCALE_TARGET=$1
                echo "Scaling Target: $HOLLAEX_SCALE_TARGET."
                shift; continue
                ;;
            --replicas)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_SCALE_TARGET_REPLICAS=$1
                echo "Target Replicas: $HOLLAEX_SCALE_TARGET_REPLICAS."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    export ENVIRONMENT_HOLLAEX_SCALEING=true

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    

     source $SCRIPTPATH/tools_generator.sh

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    load_config_variables;

    if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]]; then 

        # Check Kit version compatibility range.
        check_kit_version_compatibility_range;
    
    fi 

    if [[ "$IGNORE_SETTINGS" ]]; then

        export ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE=false 
        
    fi 

     # Target filtering

    SUPPORTED_TARGETS=("api" "stream")

    if [[ "$HOLLAEX_SCALE_TARGET" ]]; then

        if ! command printf '%s\n' ${SUPPORTED_TARGETS[@]} | grep $HOLLAEX_SCALE_TARGET > /dev/null; then

            echo "Error: The specified target $HOLLAEX_SCALE_TARGET is not supported for scaling."
            echo "Supported targets: ${SUPPORTED_TARGETS[@]}."
            echo "Please try it again."

            exit 1;

        fi 

        export HOLLAEX_SCALE_TARGET_CONVERTED="${ENVIRONMENT_EXCHANGE_NAME}-server-${HOLLAEX_SCALE_TARGET}"

    else

        echo "Error: You must specify the target server for scaling with '--target' flag."
        echo "Please try it again."

        exit 1;

    fi

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME"  ]] ; then
            printf "\033[91mError: Please define exchange name and Docker image version on config file before running HollaEx CLI.\033[39m\n"
            print_usage
            exit 1;
        fi

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        # For scaling up exisitng Exchange on Kubernetes
        if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then

            echo "Scaling up containers on the cluster..."
            kubectl scale deployment/$HOLLAEX_SCALE_TARGET_CONVERTED --replicas=$HOLLAEX_SCALE_TARGET_REPLICAS --namespace $ENVIRONMENT_EXCHANGE_NAME
            
            export HOLLAEX_SCALE_TARGET_REPLICAS_SETTINGS="ENVIRONMENT_KUBERNETES_$(echo $HOLLAEX_SCALE_TARGET | tr '[:lower:]' '[:upper:]')_SERVER_REPLICAS"

            for i in ${CONFIG_FILE_PATH[@]}; do

                # Update exchange name
                if command grep -q "ENVIRONMENT_EXCHANGE_NAME" $i > /dev/null ; then
                    CONFIGMAP_FILE_PATH=$i
                    sed -i.bak "s/$HOLLAEX_SCALE_TARGET_REPLICAS_SETTINGS=.*/$HOLLAEX_SCALE_TARGET_REPLICAS_SETTINGS=$HOLLAEX_SCALE_TARGET_REPLICAS/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak
                fi
                
            done

            printf "\033[92m\nTarget $HOLLAEX_SCALE_TARGET has been successfully scaled to $HOLLAEX_SCALE_TARGET_REPLICAS.\033[39m\n"

            exit 0;

        else 

            printf "\033[91mFailed to scale the target $HOLLAEX_SCALE_TARGET! Please review your settings and try again.\033[39m\n"
            exit 1;

        fi

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        # Exit HollaEx CLI If docker_compose 
        if [[ ! "$ENVIRONMENT_EXCHANGE_RUN_MODE" ]]; then

            echo "Your ENVIRONMENT_EXCHANGE_RUN_MODE value is missing! Please reconfirm your settings files."
            exit 1;

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi

        # Checking that the existing docker-compose file got the host port bound specifications.
        if command cat $TEMPLATE_GENERATE_PATH/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml | grep -e "10010" -e "10080" > /dev/null 2>&1; then
            
            echo "Generating docker-compose file"
            generate_local_docker_compose

        fi

        # Running docker-compose scale command.
        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d --no-recreate --scale $HOLLAEX_SCALE_TARGET_CONVERTED=$HOLLAEX_SCALE_TARGET_REPLICAS; then
            
            # Nginx Reload
            docker exec -it $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload

            printf "\033[92m\nTarget $HOLLAEX_SCALE_TARGET has been successfully scaled to $HOLLAEX_SCALE_TARGET_REPLICAS.\033[39m\n"
        
        else 

            printf "\033[91mFailed to scale the target $HOLLAEX_SCALE_TARGET! Please review your settings and try again.\033[39m\n"
            exit 1;
        
        fi

    fi

    exit 0;

elif [[ "$1" == "prod" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi


    

    # for i in ${CONFIG_FILE_PATH[@]}; do
    #     source $i
    # done;
    
    source $SCRIPTPATH/tools_generator.sh
    # load_config_variables;

    if [[ "$RUN_WITH_VERIFY" == true ]]; then

        
        printf "\nPreparing the exchange for production deployment\n\n"

        echo -e "This command is going to apply \033[1mproduction domain\033[0m to your exchange."
        echo -e "Before you proceed make sure you have your own exchange domain. (Required)"
        echo -e "\033[1mAre you ready to proceed? (Y/n)\033[0m"

        read answer

        if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
            echo "Exiting..."
            exit 0;
        fi

    fi

    function hollaex_prod_domain_questions() {

        # Web Domain
        echo "***************************************************************"
        echo "Exchange Web Domain"
        printf "\033[2m- Enter the full domain of your exchange website, without 'http' or 'https'.\033[22m\n"
        read answer
        
        while true;
            do if [[ "$answer" == *"http"* ]]; then
                printf "\nValue should be an URL without 'http' or 'https'.\n\n"
                echo  "Exchange Web Domain: "
                read answer
                local INPUT_HOLLAEX_CONFIGMAP_DOMAIN="${answer}"
            elif [[ -z "$answer" ]]; then
                printf "\nThe value should not be empty!\n"
                echo  "Exchange Web Domain: "
                read answer
                local INPUT_HOLLAEX_CONFIGMAP_DOMAIN="${answer}"
            else
                break;
            fi
        done

        export INPUT_HOLLAEX_CONFIGMAP_DOMAIN="${answer}"
        export INPUT_HOLLAEX_CONFIGMAP_DOMAIN_WITH_HTTP="http://${answer}"
        local PARSED_INPUT_HOLLAEX_CONFIGMAP_DOMAIN=${INPUT_HOLLAEX_CONFIGMAP_DOMAIN_WITH_HTTP//\//\\/}

        printf "\n"
        echo "${INPUT_HOLLAEX_CONFIGMAP_DOMAIN} ✔"
        printf "\n"

        #Automatically mark the API url as api.<MY_DOMAIN>
        export INPUT_HOLLAEX_CONFIGMAP_API_HOST="api.${INPUT_HOLLAEX_CONFIGMAP_DOMAIN}"
        local INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTP="http://${INPUT_HOLLAEX_CONFIGMAP_API_HOST}"
        local PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST=${INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTP//\//\\/}

        printf "Since you selected the Exchange Web domain as: \033[1m$INPUT_HOLLAEX_CONFIGMAP_DOMAIN,\033[0m\n"
        printf "Your Exchange Server \033[1mAPI domain\033[0m would be: \033[1m$INPUT_HOLLAEX_CONFIGMAP_API_HOST\033[0m.\n"
        printf "Type \033[1m'Y'\033[0m to continute, or \033[1m'N'\033[0m to modify the Exchange Server API domain. (Y/n)\n"
        read answer

        if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
        
            # API Domain
            echo "***************************************************************"
            echo "Exchange Server API Domain"
            printf "\033[2m- Enter the full domain of your exchange API server, without 'http' or 'https'.\033[22m\n"
            read answer

            while true;
                do if [[ "$answer" == *"http"* ]]; then
                    printf "\nValue should be an URL without 'http' or 'https'.\n"
                    echo  "Exchange API Domain: "
                    read answer
                    local INPUT_HOLLAEX_CONFIGMAP_API_HOST="${answer}"
                elif [[ -z "$answer" ]]; then
                    printf "\nThe value should not be empty!\n\n"
                    echo  "Exchange API Domain: "
                    read answer
                    local INPUT_HOLLAEX_CONFIGMAP_API_HOST="${answer}"
                else
                    break;
                fi
            done

            export INPUT_HOLLAEX_CONFIGMAP_API_HOST="${answer}"

            printf "\n"
            echo "${INPUT_HOLLAEX_CONFIGMAP_API_HOST} ✔"
            printf "\n"

            local INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTP="http://${answer}"
            local PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST=${INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTP//\//\\/}

        fi 

        export HOLLAEX_CONFIGMAP_DOMAIN=$INPUT_HOLLAEX_CONFIGMAP_DOMAIN
        export HOLLAEX_CONFIGMAP_API_HOST=$INPUT_HOLLAEX_CONFIGMAP_API_HOST

        printf "\nYour Exchange Web Domain: \033[92m$INPUT_HOLLAEX_CONFIGMAP_DOMAIN\033[39m"
        printf "\nYour Exchange API Domain: \033[92m$INPUT_HOLLAEX_CONFIGMAP_API_HOST\033[39m\n"
        echo "Type 'Y' to proceed (Y/n)"
        read answer

        if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
    
            hollaex_prod_domain_questions;

        else 

            echo "Updating user settings file based on the provided values..."

            for i in ${CONFIG_FILE_PATH[@]}; do

                # Update exchange name
                if command grep -q "ENVIRONMENT_EXCHANGE_NAME" $i > /dev/null ; then
                    CONFIGMAP_FILE_PATH=$i
                    sed -i.bak "s/HOLLAEX_CONFIGMAP_DOMAIN=.*/HOLLAEX_CONFIGMAP_DOMAIN=$PARSED_INPUT_HOLLAEX_CONFIGMAP_DOMAIN/" $CONFIGMAP_FILE_PATH
                    sed -i.bak "s/HOLLAEX_CONFIGMAP_API_HOST=.*/HOLLAEX_CONFIGMAP_API_HOST=$PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak
                fi
                
            done
        
        fi

    }

    function hollaex_network_prod_domain_questions() {

    
        # API Domain
        echo "***************************************************************"
        echo "Exchange Server API Domain"
        printf "\033[2m- Enter the full domain of your exchange API server, without 'http' or 'https'.\033[22m\n"
        read answer

        while true;
            do if [[ "$answer" == *"http"* ]]; then
                printf "\nValue should be an URL without 'http' or 'https'.\n"
                echo  "Exchange API Domain: "
                read answer
                local INPUT_HOLLAEX_CONFIGMAP_API_HOST="${answer}"
            elif [[ -z "$answer" ]]; then
                printf "\nThe value should not be empty!\n\n"
                echo  "Exchange API Domain: "
                read answer
                local INPUT_HOLLAEX_CONFIGMAP_API_HOST="${answer}"
            else
                break;
            fi
        done

        export INPUT_HOLLAEX_CONFIGMAP_API_HOST="${answer}"

        printf "\n"
        echo "${INPUT_HOLLAEX_CONFIGMAP_API_HOST} ✔"
        printf "\n"

        local INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTP="http://${answer}"
        local PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST=${INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTP//\//\\/}

        export HOLLAEX_CONFIGMAP_API_HOST=$INPUT_HOLLAEX_CONFIGMAP_API_HOST

        printf "\nYour HollaEx Network API Domain: \033[92m$INPUT_HOLLAEX_CONFIGMAP_API_HOST\033[39m\n"
        echo "Type 'Y' to proceed (Y/n)"
        read answer

        if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
    
            hollaex_network_prod_domain_questions;

        else 

            echo "Updating user settings file based on the provided values..."

            for i in ${CONFIG_FILE_PATH[@]}; do

                # Update exchange name
                if command grep -q "ENVIRONMENT_EXCHANGE_NAME" $i > /dev/null ; then
                    CONFIGMAP_FILE_PATH=$i
                    sed -i.bak "s/HOLLAEX_CONFIGMAP_API_HOST=.*/HOLLAEX_CONFIGMAP_API_HOST=$PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak
                fi
                
            done
        
        fi

    }

    # Asking for domains questions for production.
    if [[ "$HOLLAEX_NETWORK_PROD" ]]; then 

        hollaex_network_prod_domain_questions
    
    else 

        hollaex_prod_domain_questions;
    
    fi 

    #Checking the domains are reachable
    function hollaex_prod_check_domains_reachability() {
        
        if command nslookup $INPUT_HOLLAEX_CONFIGMAP_DOMAIN > /dev/null; then

            WEB_URL_NSLOOKUP_CHECK=$(nslookup $INPUT_HOLLAEX_CONFIGMAP_DOMAIN)

            # Catching exception
            if [[ "$WEB_URL_NSLOOKUP_CHECK" == *"an't find"* ]]; then 

                export HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY=false

            else 

                printf "\n\033[92mSuccessfully resolved the exchange web URL ($INPUT_HOLLAEX_CONFIGMAP_DOMAIN).\033[39m\n"
                HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY=true

            fi

        else 

            HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY=false
        
        fi

        if command nslookup $INPUT_HOLLAEX_CONFIGMAP_API_HOST > /dev/null; then

            API_URL_NSLOOKUP_CHECK=$(nslookup $INPUT_HOLLAEX_CONFIGMAP_API_HOST)
            
            # Catching exception
            if [[ "$API_URL_NSLOOKUP_CHECK" == *"an't find"* ]]; then 

                HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY=false

            else 

                printf "\n\033[92mSuccessfully resolved the exchange API URL ($INPUT_HOLLAEX_CONFIGMAP_API_HOST).\033[39m\n"
                HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY=true

            fi 

        else

            HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY=false
        
        fi

        if [[ "$HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY" == "false" ]] || [[ "$HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY" == "false" ]]; then

            # Announcing the domain configuration how-to.
            SYSTEM_PUBLIC_IP=$(curl -s ifconfig.me)

            if [[ ! "$SYSTEM_PUBLIC_IP" ]]; then
                printf "\n\033[91mError: Failed to get the system public IP automatically.\033[39m\n"
                echo "You should check it by yourself."
                SYSTEM_PUBLIC_IP="<YOUR_PUBLIC_IP>"
            fi

            printf "\n\nYour Public IP: $SYSTEM_PUBLIC_IP.\n\n"

            if [[ "$HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY" == "false" ]]; then

                printf "\n\033[93mThe domain DNS setup is required for $INPUT_HOLLAEX_CONFIGMAP_DOMAIN.\033[39m\n"
                printf "\nPlease set an \033[1mA RECORD\033[0m for \033[1m$INPUT_HOLLAEX_CONFIGMAP_DOMAIN to point $SYSTEM_PUBLIC_IP\033[0m.\n"
                printf "It is recommended to set the \033[1mTTL shorter\033[0m to apply DNS rule faster.\n\n"
                read -p "Press enter once you configured the DNS."
            fi

            if [[ "$HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY" == "false" ]]; then

                printf "\n\033[93mThe domain DNS setup is required for $INPUT_HOLLAEX_CONFIGMAP_API_HOST.\033[39m\n"
                printf "\nPlease set an \033[1mA RECORD\033[0m for \033[1m$INPUT_HOLLAEX_CONFIGMAP_API_HOST to point $SYSTEM_PUBLIC_IP\033[0m.\n"
                printf "It is recommended to set the \033[1mTTL shorter\033[0m to apply DNS rule faster.\n\n"
                read -p "Press enter once you configured the DNS."

            fi

            printf "\n\033[93mChecking the DNS reachability...\033[39m\n"
            echo "Info: You could always quit the DNS checking loop with 'Crtl + C'."
            hollaex_prod_check_domains_reachability;

        fi
    }

    #Checking the domains are reachable
    function hollaex_network_prod_check_domains_reachability() {
        

        if command nslookup $INPUT_HOLLAEX_CONFIGMAP_API_HOST > /dev/null; then

            printf "\n\033[92mSuccessfully resolved the exchange API URL ($INPUT_HOLLAEX_CONFIGMAP_API_HOST).\033[39m\n"
            HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY=true

        else

            HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY=false
        
        fi

        if [[ "$HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY" == "false" ]]; then

            # Announcing the domain configuration how-to.
            SYSTEM_PUBLIC_IP=$(curl -s ifconfig.me)

            if [[ ! "$SYSTEM_PUBLIC_IP" ]]; then
                printf "\n\033[91mError: Failed to get the system public IP automatically.\033[39m\n"
                echo "You should check it by yourself."
                SYSTEM_PUBLIC_IP="<YOUR_PUBLIC_IP>"
            fi

            printf "\n\nYour Public IP: $SYSTEM_PUBLIC_IP.\n\n"

            if [[ "$HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY" == "false" ]]; then

                printf "\n\033[93mThe domain DNS setup is required for $INPUT_HOLLAEX_CONFIGMAP_API_HOST.\033[39m\n"
                printf "\nPlease set an \033[1mA RECORD\033[0m for \033[1m$INPUT_HOLLAEX_CONFIGMAP_API_HOST to point $SYSTEM_PUBLIC_IP\033[0m.\n"
                printf "It is recommended to set the \033[1mTTL shorter\033[0m to apply DNS rule faster.\n\n"
                read -p "Press enter once you configured the DNS."

            fi

            printf "\n\033[93mChecking the DNS reachability...\033[39m\n"
            echo "Info: You could always quit the DNS checking loop with 'Crtl + C'."
            hollaex_network_prod_check_domains_reachability;

        fi
    }

    if [[ "$HOLLAEX_NETWORK_PROD" ]]; then 

        hollaex_network_prod_check_domains_reachability;

    else 

        hollaex_prod_check_domains_reachability;

    fi 
    
    if [[ ! "$USE_KUBERNETES" ]]; then 

        apply_nginx_user_defined_values;

        # Update the nginx if the Kit got a separated domain for the API.
        if [[ ! "$HOLLAEX_CONFIGMAP_API_HOST" == "$HOLLAEX_CONFIGMAP_DOMAIN/api"]]; then

            apply_nginx_separated_kit_domains_values;
        
        fi

    fi 

    printf "\n"

    if [[ ! "$USE_KUBERNETES" ]]; then
    
        echo "Do you want to issue SSL cert for your exchange? (Y/n)"
        echo "If you are going to use an external load balancer with SSL, Please type 'N'."

    elif [[ "$USE_KUBERNETES" ]]; then

        echo "HollaEx CLI natively supports issuing SSL cert through 'cert-manager' and Let's encrypt."
        echo "Please make sure to install latest 'cert-manager' on your Kubernetes cluster."
        echo "Official document is available for installation. (cert-manager.io/docs/installation/kubernetes)"

        printf "\n"

        echo "Do you want to set up cert-manager issuer name for SSL? (Y/n)"
        echo "If you are going to use an external load balancer with SSL, Please type 'N'."

    fi
    
    read answer 

    printf "\n"

    if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
    
        echo "Skipping to issue SSL cert..."
        printf "\n\n\033[93mInfo: You could also issue SSL cert later by running 'hollaex toolbox --issue_ssl' command.\033[39m\n"

    else 

        if [[ "$USE_KUBERNETES" ]]; then
        
            echo "The 'cert-manager' requires an issuer name to reach SSL ACME service."
            echo "Please provide your cert-manager issuer name."
            read answer

            echo "Updating the issuer name on user's settings file..."
            for i in ${CONFIG_FILE_PATH[@]}; do

                # Update exchange name
                if command grep -q "HOLLAEX_CONFIGMAP_API_NAME" $i > /dev/null ; then
                CONFIGMAP_FILE_PATH=$i
                sed -i.bak "s/ENVIRONMENT_KUBERNETES_INGRESS_CERT_MANAGER_ISSUER=.*/ENVIRONMENT_KUBERNETES_INGRESS_CERT_MANAGER_ISSUER=$answer/" $CONFIGMAP_FILE_PATH
                rm $CONFIGMAP_FILE_PATH.bak
                fi
                
            done

            printf "\n"
            echo "$answer ✔"
            printf "\n"

        elif [[ ! "$USE_KUBERNETES" ]]; then

            echo "HollaEx CLI natively supports issuing SSL cert through 'certbot' and Let's encrypt."
            echo "Running 'certbot' now..."
            printf "\n"
            while true;
                do if command hollaex toolbox --issue_ssl --skip; then

                    if [[ ! "$HOLLAEX_NETWORK_PROD" ]]; then 

                        echo "Do you want to issue more SSL cert for different domain? (Y/n)"
                        read answer

                        if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then

                            echo "Skipping..."
                            break;

                        else 

                            hollaex toolbox --issue_ssl --skip;
                            break;

                        fi
                    
                    else 

                        echo "Successfully issued the SSL certificate for your domain."

                    fi 
                
                else 

                    printf "\033[91mFailed to issue SSL certificate by using Certbot. Please confirm your settings and try again.\033[39m\n"
                    exit 1;

                fi

            done;

            
        fi

        if [[ "$USE_KUBERNETES" ]]; then 

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "HOLLAEX_CONFIGMAP_API_NAME" $i > /dev/null ; then
                    CONFIGMAP_FILE_PATH=$i
                fi 
            
            done

            echo "Do you want to enable cert-manager based SSL for API server? (Y/n)"
            read answer

             if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
            
                echo "Skipping to enable SSL for API server..."

                 if command grep -q "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER" $CONFIGMAP_FILE_PATH > /dev/null ; then
            
                    echo "Updating the existing ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER value..."
                    sed -i.bak "s/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=.*/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=false/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak

                else 

                    echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER is missing on your settings file. Adding it now..."
                    echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=false" >> $CONFIGMAP_FILE_PATH

                fi

            else 

                export ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=true

                if command grep -q "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER" $CONFIGMAP_FILE_PATH > /dev/null ; then
            
                    echo "Updating the existing ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER value..."
                    sed -i.bak "s/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=.*/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=true/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak

                else 

                    echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER is missing on your settings file. Adding it now..."
                    echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=true" >> $CONFIGMAP_FILE_PATH

                fi

                printf "\n"
                echo "✔"
                printf "\n"
            
            fi 

            if [[ ! "$HOLLAEX_NETWORK_PROD" ]]; then 

                echo "Do you want to enable cert-manager based SSL for Web server? (Y/n)"
                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
                
                    echo "Skipping to enable SSL for Web server..."

                    if command grep -q "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB" $CONFIGMAP_FILE_PATH > /dev/null ; then
                
                        echo "Updating the existing ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB value..."
                        sed -i.bak "s/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=.*/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=false/" $CONFIGMAP_FILE_PATH
                        rm $CONFIGMAP_FILE_PATH.bak

                    else 

                        echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB is missing on your settings file. Adding it now..."
                        echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=false" >> $CONFIGMAP_FILE_PATH

                    fi

                else 

                    export ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=true

                    if command grep -q "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB" $CONFIGMAP_FILE_PATH > /dev/null ; then
                
                        echo "Updating the existing ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB value..."
                        sed -i.bak "s/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=.*/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=true/" $CONFIGMAP_FILE_PATH
                        rm $CONFIGMAP_FILE_PATH.bak

                    else 

                        echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB is missing on your settings file. Adding it now..."
                        echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=true" >> $CONFIGMAP_FILE_PATH

                    fi

                    printf "\n"
                    echo "✔"
                    printf "\n"
                
                fi 
            
            fi 
        
        fi

        echo "Updating domains on settings files to use 'https' as a prefix..."

        if [[ ! "$HOLLAEX_NETWORK_PROD" ]]; then 
            
            INPUT_HOLLAEX_CONFIGMAP_DOMAIN_WITH_HTTPS="https://${INPUT_HOLLAEX_CONFIGMAP_DOMAIN}"
            PARSED_INPUT_HOLLAEX_CONFIGMAP_DOMAIN=${INPUT_HOLLAEX_CONFIGMAP_DOMAIN_WITH_HTTPS//\//\\/}
        
        fi 

        INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTPS="https://${INPUT_HOLLAEX_CONFIGMAP_API_HOST}"
        PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST=${INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTPS//\//\\/}

        for i in ${CONFIG_FILE_PATH[@]}; do

            # Update exchange name
            if command grep -q "ENVIRONMENT_EXCHANGE_NAME" $i > /dev/null ; then
                CONFIGMAP_FILE_PATH=$i
                if [[ ! "$HOLLAEX_NETWORK_PROD" ]]; then 
                    sed -i.bak "s/HOLLAEX_CONFIGMAP_DOMAIN=.*/HOLLAEX_CONFIGMAP_DOMAIN=$PARSED_INPUT_HOLLAEX_CONFIGMAP_DOMAIN/" $CONFIGMAP_FILE_PATH
                fi 
                sed -i.bak "s/HOLLAEX_CONFIGMAP_API_HOST=.*/HOLLAEX_CONFIGMAP_API_HOST=$PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST/" $CONFIGMAP_FILE_PATH
                rm $CONFIGMAP_FILE_PATH.bak
            fi
            
        done

    fi

    if [[ "$HOLLAEX_NETWORK_PROD" ]]; then 

        hollaex_network_prod_complete;

    else 

        hollaex_prod_complete;
    
    fi 

    exit 0;


elif [[ "$1" == "stop" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
           --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --mode)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_DEPLOYMENT_MODE=$1
                echo "Your DEPLOYMENT_MODE setup : $LOCAL_DEPLOYMENT_MODE."
                shift; continue
                ;;
            --is_hollaex_setup)
                IS_HOLLAEX_SETUP=true
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done
    
    # Export hollaex-kit directory

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]]; then 

        if [[ ! "$HOLLAEX_NETWORK_STOP" ]]; then 

            # Check Kit version compatibility range.
            check_kit_version_compatibility_range;
        
        fi 
    
    fi 

    if [[ "$USE_KUBERNETES" ]]; then
        

         #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to stop (scale down) $HOLLAEX_CONFIGMAP_API_NAME on this cluster? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo "Scaling down containers on the cluster..."
        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-api --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-stream --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        if [[ ! "$HOLLAEX_NETWORK_STOP" ]]; then 

            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-plugins --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        fi 

        echo "Scaling down backend components..."
        
        if [[ "$HOLLAEX_NETWORK_STOP" ]]; then 

            kubectl scale statefulset/$ENVIRONMENT_EXCHANGE_NAME-influxdb --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-job --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

            helm_dynamic_trading_paris scaledown

        fi 

        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-redis --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-db --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        if [[ "$HOLLAEX_NETWORK_STOP" ]]; then 

            hollaex_ascii_network_has_been_stopped;

        else 

            hollaex_ascii_exchange_has_been_stopped;

        fi 

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi 

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to stop $HOLLAEX_CONFIGMAP_API_NAME running on your machine? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml stop; then

            if [[ "$HOLLAEX_NETWORK_STOP" ]]; then 

                hollaex_ascii_network_has_been_stopped;

            else 

                hollaex_ascii_exchange_has_been_stopped;

            fi

        else 

            printf "\033[91mFailed to stop exchange! Please review your settings and try again.\033[39m\n"
            exit 1;
        
        fi

    fi

    exit 0;

elif [[ "$1" == "restart" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --ignore_settings)
                IGNORE_SETTINGS=true
                echo "HollaEx CLI will ignore local settings update on restart."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --http_port)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_LOCAL_NGINX_HTTP_PORT_UPDATE=$1
                echo "Your new local HTTP port : $ENVIRONMENT_LOCAL_NGINX_HTTP_PORT_UPDATE."
                shift; continue
                ;;
            --https_port)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_LOCAL_NGINX_HTTPS_PORT_UPDATE=$1
                echo "Your new local HTTPS port : $ENVIRONMENT_LOCAL_NGINX_HTTPS_PORT_UPDATE."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --silent)
                HOLLAEX_SILENT=true
                echo "Silent mode is enable. Some of the outputs will not be displayed."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done
    
    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    

    source $SCRIPTPATH/tools_generator.sh

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    # Update random secrets if env generation is enabled.
    if [[ ! "$IGNORE_SETTINGS" ]]; then 

        #Regenerate random secrets
        update_random_values_to_config;

    fi

    # Override user HollaEx Core tag if the flag is available.
    if [[ "$HOLLAEX_CORE_USER_APPLY_TAG" ]]; then
        
        override_user_docker_tag;

    fi

    if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]] && [[ ! "$HOLLAEX_NETWORK_RESTART" ]]; then 

            # Check Kit version compatibility range.
            check_kit_version_compatibility_range;
    
    fi

    if [[ "$IGNORE_SETTINGS" ]]; then

        export ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE=false 

    fi 

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            printf "\033[93mWarning: Exchange service will be unavailable during the restart!\033[39m\n"
            echo "Are you sure you want to restart $HOLLAEX_CONFIGMAP_API_NAME on this cluster? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        if [[ "$HOLLAEX_NETWORK_RESTART" ]]; then 

            hollaex network --stop --skip --kube

            hollaex network --start --skip --kube


        else 

            hollaex server --stop --skip --kube

            hollaex server --start --skip --kube
        
        fi 
    
    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            printf "\033[91mHollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI.\033[39m\n"
            
            exit 1;

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi

        if [[ "$RUN_WITH_VERIFY" == true ]]; then
            
            printf "\033[93mWarning: Exchange service will be unavailable during the restart!\033[39m\n"
            echo "Are you sure you want to restart $HOLLAEX_CONFIGMAP_API_NAME on your machine? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        if [[ "$HOLLAEX_NETWORK_RESTART" ]]; then 

            hollaex network --stop --skip

            if [[ "$ENVIRONMENT_LOCAL_NGINX_HTTP_PORT_UPDATE" ]] || [[ "$ENVIRONMENT_LOCAL_NGINX_HTTPS_PORT_UPDATE" ]]; then 

                hollaex network --start --skip --http_port $ENVIRONMENT_LOCAL_NGINX_HTTP_PORT_UPDATE --https_port $ENVIRONMENT_LOCAL_NGINX_HTTPS_PORT_UPDATE
            
            else 

                hollaex network --start --skip

            fi 


        else 

            hollaex server --stop --skip

            hollaex server --start --skip
        
        fi 

    fi

    exit 0;

elif [[ "$1" == "build" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --is_hollaex_setup)
                IS_HOLLAEX_SETUP=true
                shift; continue
                ;;
            --registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE=$1
                echo "Target hollaex docker registry : $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --arch)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                if [[ "$1" == "amd64" ]] || [[ "$1" == "arm64v8" ]] || [[ "$1" == "s390x" ]]; then
                    export ENVIORNMENT_HOLLAEX_CPU_ARCH=$1
                    echo "Target CPU Arch: $ENVIORNMENT_HOLLAEX_CPU_ARCH."
                else 
                    echo -e "\n\033[91mError: Not supported CPU arch!\033[39m"
                    echo "Supported Arches: amd64, arm64v8, s390x."
                    echo -e "Please try it again with the supported arch name.\n"
                    exit 1;
                fi
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    export ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY=${ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE:-$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY}
    
    if [[ "$ENVIORNMENT_HOLLAEX_CPU_ARCH" ]]; then 

        export ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE="$(cat $HOLLAEX_CLI_INIT_PATH/server/package.json | jq -r '.version')-${ENVIORNMENT_HOLLAEX_CPU_ARCH}"

        ENVIRONMENT_NODE_VERSION=$(cat $HOLLAEX_CLI_INIT_PATH/Dockerfile | grep -e "FROM.*node:" | cut -f2 -d ":")

        # Overriding the base image with the env value
        sed -i.bak "s/FROM .*node.*/FROM ${ENVIORNMENT_HOLLAEX_CPU_ARCH}\/node:${ENVIRONMENT_NODE_VERSION}/" $HOLLAEX_CLI_INIT_PATH/Dockerfile
        rm $HOLLAEX_CLI_INIT_PATH/Dockerfile.bak

    else 

        export ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE="$(cat $HOLLAEX_CLI_INIT_PATH/server/package.json | jq -r '.version')"

    fi     

    export ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-server-${ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE}-$(date +%y%m%d%H%M)"

    build_user_hollaex_core;

    echo -e "\nPlease run 'hollaex apply --registry $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY --tag $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION $(if [[ "$USE_KUBERNETES" ]]; then echo "--kube"; fi)' to apply it on the server."

elif [[ "$1" == "apply" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE=$1
                echo "Target Docker Image Registry: $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --tag)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE=$1
                echo "Target Docker Image tag: $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE."
                shift; continue
                ;;
            --arch)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                if [[ "$1" == "amd64" ]] || [[ "$1" == "arm64v8" ]] || [[ "$1" == "s390x" ]]; then
                    export ENVIORNMENT_HOLLAEX_CPU_ARCH=$1
                    echo "Target CPU Arch: $ENVIORNMENT_HOLLAEX_CPU_ARCH."
                else 
                    echo -e "\n\033[91mError: Not supported CPU arch!\033[39m"
                    echo "Supported Arches: amd64, arm64v8, s390x."
                    echo -e "Please try it again with the supported arch name.\n"
                    exit 1;
                fi
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ "$IGNORE_SETTINGS" ]]; then

        export ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE=false 

    fi 

    ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY=${ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE:-$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY}

    if [[ "$HOLLAEX_NETWORK_UPGRADE" ]]; then 
        
        ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION=$(check_latest_hollaex_network_docker_tag)
        echo "Latest HollaEx Network Version: v$HOLLAEX_CORE_USER_APPLY_TAG."

    else 

        ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION=${ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE:-$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION}

    fi 

    if [[ "$RUN_WITH_VERIFY" == true ]]; then

        printf "\033[93mWarning: Exchange service will be unavailable while applying the new image!\033[39m\n"
        echo "Are you sure you want to apply the $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY:$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION image on your server? (y/N)"

        read answer

        if [[ "$answer" = "${answer#[Yy]}" ]] ;then
            echo "Exiting..."
            exit 0;
        fi

    fi

    export ENVIRONMENT_USER_REGISTRY_OVERRIDE=$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY
    override_user_docker_registry;
    
    export HOLLAEX_CORE_USER_APPLY_TAG=$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION
    override_user_docker_tag;


    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        # Only tries to attempt remove ingress rules from Kubernetes if it exists.
        if command kubectl get ingress -n $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then
        
            echo "Removing $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

        fi
        
        # DROP OLD INGRESS RULES IF IT EXISTS ON THE CLUSTER
        if command kubectl get ingress/$ENVIRONMENT_EXCHANGE_NAME-ingress-api-order -n $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then
        
            kubectl delete -n $ENVIRONMENT_EXCHANGE_NAME ingress/$ENVIRONMENT_EXCHANGE_NAME-ingress-api-order
            kubectl delete -n $ENVIRONMENT_EXCHANGE_NAME ingress/$ENVIRONMENT_EXCHANGE_NAME-ingress-api-admin
            kubectl delete -n $ENVIRONMENT_EXCHANGE_NAME ingress/$ENVIRONMENT_EXCHANGE_NAME-ingress-api-explorer
            kubectl delete -n $ENVIRONMENT_EXCHANGE_NAME ingress/$ENVIRONMENT_EXCHANGE_NAME-ingress-docs

        fi

        if [[ "$HOLLAEX_NETWORK_UPGRADE" ]]; then 

            run_and_upgrade_hollaex_network_on_kubernetes;
        
        else 

            run_and_upgrade_hollaex_on_kubernetes;
    
        fi
        
    else 

        if [[ "$HOLLAEX_NETWORK_UPGRADE" ]]; then 

            hollaex network --restart --skip 

            local_hollaex_network_database_init upgrade

            hollaex network --restart --skip
        
        else 

            hollaex restart --skip 

            local_database_init upgrade

            hollaex restart --skip

        fi

    fi

    if [[ "$HOLLAEX_NETWORK_UPGRADE" ]]; then 

        hollaex_ascii_network_has_been_upgraded;
    
    else 

        hollaex_ascii_exchange_has_been_upgraded;

    fi 

    exit 0


elif [[ "$1" == "upgrade" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE=$1
                echo "Target Docker Image Registry: $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --tag)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE=$1
                echo "Target Docker Image tag: $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --ignore_settings)
                IGNORE_SETTINGS=true
                echo "HollaEx CLI will ignore local settings update on restart."
                shift; continue
                ;;
            --arch)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                if [[ "$1" == "amd64" ]] || [[ "$1" == "arm64v8" ]] || [[ "$1" == "s390x" ]]; then
                    export ENVIORNMENT_HOLLAEX_CPU_ARCH=$1
                    echo "Target CPU Arch: $ENVIORNMENT_HOLLAEX_CPU_ARCH."
                else 
                    echo -e "\n\033[91mError: Not supported CPU arch!\033[39m"
                    echo "Supported Arches: amd64, arm64v8, s390x."
                    echo -e "Please try it again with the supported arch name.\n"
                    exit 1;
                fi
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    

    source $SCRIPTPATH/tools_generator.sh

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    # Update random secrets if env generation is enabled.
    if [[ ! "$IGNORE_SETTINGS" ]]; then 

        #Regenerate random secrets
        update_random_values_to_config;

    fi

    # Update HollaEx CLI to latest if there is newer release available.
    update_hollaex_cli_to_latest;

    if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]]; then

        echo "Checking the version compatibility between the latest HollaEx CLI and your local Kit..."
        if command curl -s -f https://raw.githubusercontent.com/bitholla/hollaex-cli/master/version_range > $SCRIPTPATH/.master_version_range; then 

            source $SCRIPTPATH/.master_version_range
            rm $SCRIPTPATH/.master_version_range

        else 

            printf "\n\033[91mError: Failed to read latest version compatibility range from the server.\n\033[39m"
            echo "Please check your internet connectivity and try it again."
            
            exit 1;

        fi

        # Check Kit version compatibility range.
        check_kit_version_compatibility_range;

    fi

    #hollaex build

    export ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY=${ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE:-$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY}
    
    # Update the Core version to the user specified version, or use a latest compatible one.
    if [[ "$ENVIORNMENT_HOLLAEX_CPU_ARCH" ]]; then 

        export ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE="$(cat $HOLLAEX_CLI_INIT_PATH/server/package.json | jq -r '.version')-${ENVIORNMENT_HOLLAEX_CPU_ARCH}"
    
    else 

        export ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE="$(cat $HOLLAEX_CLI_INIT_PATH/server/package.json | jq -r '.version')"

    fi     

    export ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-server-${ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE}-$(date +%y%m%d%H%M)"
    
    export ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE=$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION

    build_user_hollaex_core;

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    load_config_variables;

    if [[ "$IGNORE_SETTINGS" ]]; then

        export ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE=false 

    fi 

    if [[ "$USE_KUBERNETES" ]]; then

        if [[ "$RUN_WITH_VERIFY" == true ]]; then 

            hollaex apply --tag $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE --kube

        else 

            hollaex apply --tag $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE --kube --skip

        fi

    else

        if [[ "$RUN_WITH_VERIFY" == true ]]; then 

            hollaex apply --tag $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE 

        else 

            hollaex apply --tag $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE --skip

        fi

    fi

elif [[ "$1" == "terminate" ]]; then

     while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
     done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]]; then 

        if [[ ! "$HOLLAEX_NETWORK_TERMINATE" ]]; then 

            # Check Kit version compatibility range.
            check_kit_version_compatibility_range;
        
        fi
    
    fi 

    echo -e "\n# # # # # #  \033[1mW A R N I N G\033[0m  # # # # # #\n"
    echo -e "\033[91mYou are now trying to TERMINATE your exchange!\033[39m"
    echo -e "Terminating the exchange will \033[91mREMOVE\033[39m all of your \033[91mFUNDS, USER DATA, and EVERYTHING.\033[39m"
    echo -e "This action \033[91mCANNOT BE UNDO\033[39m, and will make the exchange \033[91mUNRECOVEREABLE for eternally.\033[39m"
    echo -e "\n# # # # # # # # # # # # # # # # # # # #\n"

    sleep 5

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo -e "\033[91mTHIS IS YOUR LAST CHANCE TO CANCEL IT!\033[39m\n"

            echo "Are you sure you want to terminate $HOLLAEX_CONFIGMAP_API_NAME on this cluster? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

         # Only tries to attempt remove ingress rules from Kubernetes if it exists.
        if command kubectl get ingress -n $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then
        
            echo "Removing $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

        fi

        # DROP OLD INGRESS RULES IF IT EXISTS ON THE CLUSTER
        if command kubectl get ingress/$ENVIRONMENT_EXCHANGE_NAME-ingress-api-order -n $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then
        
            kubectl delete -n $ENVIRONMENT_EXCHANGE_NAME ingress/$ENVIRONMENT_EXCHANGE_NAME-ingress-api-order
            kubectl delete -n $ENVIRONMENT_EXCHANGE_NAME ingress/$ENVIRONMENT_EXCHANGE_NAME-ingress-api-admin
            kubectl delete -n $ENVIRONMENT_EXCHANGE_NAME ingress/$ENVIRONMENT_EXCHANGE_NAME-ingress-api-explorer
            kubectl delete -n $ENVIRONMENT_EXCHANGE_NAME ingress/$ENVIRONMENT_EXCHANGE_NAME-ingress-docs

        fi

        echo "Running a final backup for the exchange database."
        if ! command hollaex toolbox --backup --kube; then 

                printf "\033[91mWarning: HollaEx CLI failed to make a final DB backup!\033[39m\n"

                if [[ "$RUN_WITH_VERIFY" == true ]]; then

                    echo "Do you want to continue without a DB backup? (y/N)"
                    read answer

                    if [[ "$answer" = "${answer#[Yy]}" ]]; then
                        echo "Exiting..."
                        exit 0;
                    fi
                
                fi

                echo "Proceeding without a backup..."
            
        fi

        echo "Removing $HOLLAEX_CONFIGMAP_API_NAME namespace."
        kubectl delete ns $ENVIRONMENT_EXCHANGE_NAME

        if [[ "$HOLLAEX_NETWORK_TERMINATE" ]]; then 

            hollaex_ascii_network_has_been_terminated;

        else 

            hollaex_ascii_exchange_has_been_terminated;

        fi 

        echo "$HOLLAEX_CONFIGMAP_API_NAME ($HOLLAEX_CONFIGMAP_API_HOST) has been successfully terminated."
        echo "If there's an issue, please review the logs and try it again."
        printf "\nBye!\n\n"

        exit 0;

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi


        echo -e "\033[91mTHIS IS YOUR LAST CHANCE TO CANCEL IT!\033[39m\n"

        echo "Are you sure you want to terminate $HOLLAEX_CONFIGMAP_API_NAME on your machine? (y/N)"

        read answer

        if [[ "$answer" = "${answer#[Yy]}" ]] ;then
            echo "Exiting..."
            exit 0;
        fi


        echo "Running a final backup for the database."

        if [[ "$HOLLAEX_NETWORK_BACKUP" ]]; then 

            if command hollaex network --backup --skip; then 

                IS_BACKUP_SUCCESS=true
            
            fi 
        
        else 

            if command hollaex toolbox --backup --skip; then 

                IS_BACKUP_SUCCESS=true

            fi 

        fi 

        if [[ ! "$IS_BACKUP_SUCCESS" ]]; then 

            printf "\033[91mWarning: HollaEx CLI failed to make a final DB backup!\033[39m\n"
            echo "Do you want to continue without a DB backup? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]]; then
                echo "Exiting..."
                exit 0;
            fi

            printf "\033[91mWarning: HollaEx CLI failed to make a final DB backup!\033[39m\n"
            echo "Proceeding without a backup..."

            
        fi

        # Remove web server together if it exists.
        if [[ -f "$TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml" ]] ; then

            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client down 

        fi

        if [[ -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/upstream-web.conf" ]]; then 

            rm $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/upstream-web.conf
        
        fi 

        if [[ "$HOLLAEX_NETWORK_TERMINATE" ]]; then 

            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml down --remove-orphans -v

            hollaex_ascii_network_has_been_terminated;

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "HOLLAEX_CONFIGMAP_API_NAME=" $i > /dev/null ; then

                    export CONFIGMAP_FILE_PATH=$i

                fi

            done

            sed -i.bak "s/HOLLAEX_CONFIGMAP_CURRENCIES=.*/HOLLAEX_CONFIGMAP_CURRENCIES=xht,usdt/" $CONFIGMAP_FILE_PATH;
            sed -i.bak "s/HOLLAEX_CONFIGMAP_PAIRS=.*/HOLLAEX_CONFIGMAP_PAIRS=xht-usdt/" $CONFIGMAP_FILE_PATH;
            rm $CONFIGMAP_FILE_PATH.bak


        else 

            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml down -v

            hollaex_ascii_exchange_has_been_terminated;
        
        fi 


        echo "$HOLLAEX_CONFIGMAP_API_NAME ($HOLLAEX_CONFIGMAP_API_HOST) has been successfully terminated."
        echo "If there's an issue, please review the logs and try it again."
        printf "\nBye!\n\n"

        exit 0;

    fi

elif [[ "$1" == "web" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "Setting target to Kubernetes..."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --setup)
                WEB_CLIENT_SETUP=true
                shift; continue
                ;;
            --start)
                WEB_CLIENT_START=true
                shift; continue
                ;;
            --stop)
                WEB_CLIENT_STOP=true
                shift; continue
                ;;
            --restart)
                WEB_CLIENT_RESTART=true
                shift; continue
                ;;
            --build)
                WEB_CLIENT_REBUILD=true
                shift; continue
                ;;
            --apply)
                WEB_CLIENT_APPLY=true
                shift; continue
                ;;
            --upgrade)
                WEB_CLIENT_UPGRADE=true
                shift; continue
                ;;
            --terminate)
                WEB_CLIENT_TERMINATE=true
                shift; continue
                ;;
            # Build related
            --registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE=$1
                echo "Target hollaex web image registry : $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --tag)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION_OVERRIDE=$1
                echo "Target hollaex web image tag : $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION_OVERRIDE."
                shift; continue
                ;;
            # Scale related
            --scale)
                WEB_CLIENT_SCALE=true
                shift; continue
                ;;
            --replicas)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_WEB_SCALE_TARGET_REPLICAS=$1
                echo "Target Replicas: $HOLLAEX_WEB_SCALE_TARGET_REPLICAS."
                shift; continue
                ;;
            --arch)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                if [[ "$1" == "amd64" ]] || [[ "$1" == "arm64v8" ]] || [[ "$1" == "s390x" ]]; then
                    export ENVIORNMENT_HOLLAEX_CPU_ARCH=$1
                    echo "Target CPU Arch: $ENVIORNMENT_HOLLAEX_CPU_ARCH."
                else 
                    echo -e "\n\033[91mError: Not supported CPU arch!\033[39m"
                    echo "Supported Arches: amd64, arm64v8, s390x."
                    echo -e "Please try it again with the supported arch name.\n"
                    exit 1;
                fi
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi


    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    if [[ "$HOLLAEX_CONFIGMAP_NETWORK_URL" == *"hollaex-network-nginx"* ]]; then 

        echo "Hollaex Network URL: $HOLLAEX_CONFIGMAP_NETWORK_URL"
        export HOLLAEX_NETWORK_LOCALHOST_MODE=true

    fi
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    # Setting web operation enabled command to true.
    ENVIRONMENT_WEB_ENABLE=true

    if [[ ! "$USE_KUBERNETES" ]]; then

         if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi
    
    elif [[ "$USE_KUBERNETES" ]]; then

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

    fi

    if [[ "$ENVIORNMENT_HOLLAEX_CPU_ARCH" ]]; then 

        ENVIRONMENT_WEB_NGINX_VERSION=$(cat $HOLLAEX_CLI_INIT_PATH/web/docker/Dockerfile | grep "FROM.*nginx:" | cut -f2 -d ":")

        # Overriding the base image with the env value
        sed -i.bak "s/FROM .*nginx.*/FROM ${ENVIORNMENT_HOLLAEX_CPU_ARCH}\/nginx:${ENVIRONMENT_WEB_NGINX_VERSION}/" $HOLLAEX_CLI_INIT_PATH/web/docker/Dockerfile

        rm $HOLLAEX_CLI_INIT_PATH/web/docker/Dockerfile.bak

    fi

    # hollaex web --setup
    if [[ "$WEB_CLIENT_SETUP" ]]; then

        export OVERRIDE_THE_WEB_IMAGE_TAG=true

        if [[ "$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE" ]]; then 
        
            export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY=$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE
        
        fi 

        export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-web-$(cat $HOLLAEX_CLI_INIT_PATH/web/package.json | jq -r '.version')-$(date +%y%m%d%H%M)"
        build_user_hollaex_web;

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            #Verify remote Kubernetes cluster is correct.
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to setup the web server on this cluster? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi
            
            # Web server installation status checking.
            if command helm ls | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null 2>&1; then

                printf "\033[91m\nError: You already installed the web server on your Kuberentes cluster!\033[39m\n"
                echo "To start it, Please run 'hollaex web --start --kube' command instead."

                exit 1;
            
            fi

            #Creating kubernetes_config directory for generating config for Kubernetes.
            if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
                mkdir $TEMPLATE_GENERATE_PATH/kubernetes;
                mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
            fi

            echo "Generating web ingress rules for Kubernetes"
            generate_kubernetes_ingress_for_web;

            echo "Applying web ingress rules for Kubernetes"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

            
            # Create docker registry secret on Kubernetes.
            if ! command kubectl get secret docker-registry-secret --namespace $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then

                create_kubernetes_docker_registry_secret;
            
            fi

            # FOR GENERATING NODESELECTOR VALUES
            generate_nodeselector_values ${ENVIRONMENT_KUBERNETES_EXCHANGE_STATELESS_NODESELECTOR:-$ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR} hollaex-stateless

            echo "Running the web server on Kubernetes..."
            if command helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-web \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY" \
                        --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION" \
                        --set stable.replicaCount="${ENVIRONMENT_KUBERNETES_WEB_SERVER_REPLICAS:-1}" \
                        --set autoScaling.hpa.enable="${ENVIRONMENT_KUBERNETES_WEB_HPA_ENABLE:-false}" \
                        --set autoScaling.hpa.avgMemory="${ENVIRONMENT_KUBERNETES_WEB_HPA_AVGMEMORY:-500000000}" \
                        --set autoScaling.hpa.maxReplicas="${ENVIRONMENT_KUBERNETES_WEB_HPA_MAXREPLICAS:-4}" \
                        --set resources.limits.cpu="${ENVIRONMENT_WEB_CPU_LIMITS:-1000m}" \
                        --set resources.limits.memory="${ENVIRONMENT_WEB_MEMORY_LIMITS:-1024Mi}" \
                        --set resources.requests.cpu="${ENVIRONMENT_WEB_CPU_REQUESTS:-2m}" \
                        --set resources.requests.memory="${ENVIRONMENT_WEB_MEMORY_REQUESTS:-100Mi}" \
                        --set envName="$ENVIRONMENT_EXCHANGE_NAME-web-env" \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex-stateless.yaml \
                        -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-web/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-web; then


                echo "Scaling down the web server after the initialization..."
                hollaex web --stop --kube --skip

                hollaex_ascii_web_server_has_been_setup;
            
            else 

                printf "\n\033[91mFailed to setup the web server on the Kubernetes!\033[39m\n"
                echo "Please review the logs and try again."

                helm uninstall $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null;

                exit 1;

            fi

            exit 0;
        
        elif [[ ! "$USE_KUBERNETES" ]]; then

            # Checking docker-compose is installed on this machine.
            check_docker_compose_is_installed;

            # if [[ "$RUN_WITH_VERIFY" == true ]]; then

            #     echo "Are you sure you want to setup the web server on this machine? (Y/n)"

            #     read answer

            #     if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
            #         echo "Exiting..."
            #         exit 0;
            #     fi

            # fi

            echo "Generating web docker-compose file"
            generate_local_docker_compose_for_web

            echo "Generating web .env file"
            generate_hollaex_web_local_env

            # Only generated the separated web.conf file if user got a different domain for the API.
            if [[ ! "$HOLLAEX_CONFIGMAP_API_HOST" == "$HOLLAEX_CONFIGMAP_DOMAIN/api"]]; then 

                if [[ ! -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]]; then

                    echo "Generating web Nginx configuration file"
                    generate_hollaex_web_local_nginx_conf

                fi

            fi

            # if [[ ! -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]] || [[ ! -s "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]]; then

            #     if [[ -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf" ]] && [[ -s "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf" ]]; then

            #         echo "Restoring old web Nginx configuration file"
            #         cp -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf

            #         rm $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf

            #     else

            #         echo "Generating web Nginx configuration file"
            #         generate_hollaex_web_local_nginx_conf
                
            #     fi

            # fi

            echo "Generating web Nginx upstream file"
            generate_nginx_upstream_for_web

            echo "Updating main Nginx.conf based on user settings..."
            apply_nginx_user_defined_values

            # Update the nginx if the Kit got a separated domain for the API.
            if [[ ! "$HOLLAEX_CONFIGMAP_API_HOST" == "$HOLLAEX_CONFIGMAP_DOMAIN/api"]]; then

                apply_nginx_separated_kit_domains_values;
            
            fi

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client up -d; then

                echo "Reloading Nginx..."
                if command docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload; then
                
                    printf "\n\033[92mSuccessfully reloaded the Nginx\033[39m\n"
        
                else

                    printf "\033[93mFailed to reload Nginx. Please make sure to start the exchange API server first.\033[39m\n"
                    echo "The web server could be still reachable through 'http://localhost:8080',"
                    echo "But the allocated domain for the web would not function correctly."

                fi

                hollaex web --stop --skip

                hollaex_ascii_web_server_has_been_setup;

            else 

                printf "\n\033[91mError: Failed to restart the web server.\033[39m\n"
                echo "Please review the logs and try again."
                exit 1;
            
            fi

            exit 0;

        fi

        exit 0;

    fi

    if [[ "$WEB_CLIENT_START" ]]; then

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            #Verify remote Kubernetes cluster is correct.
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            # if [[ "$RUN_WITH_VERIFY" == true ]]; then

            #     echo "Are you sure you want to start (scale up) the web server on this cluster? (Y/n)"

            #     read answer

            #     if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
            #         echo "Exiting..."
            #         exit 0;
            #     fi

            # fi
            
            # Web server installation status checking.
            if ! command helm ls --namespace $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null 2>&1; then

                printf "\033[91mFailed to detect the web server installed on your Kubernetes cluster.\033[39m\n"
                echo "If you haven't launched the web server yet, Please run 'hollaex web --setup --kube' to set it up first."

                exit 1;
            
           fi

            echo "Generating web ingress rules for Kubernetes"
            generate_kubernetes_ingress_for_web;

            echo "Applying web ingress rules for Kubernetes"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml


            if ! command kubectl get secret docker-registry-secret --namespace $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then

                create_kubernetes_docker_registry_secret;
            
            fi

            echo "Starting (Scaling up) the web server on Kubernetes..."
            if command kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-web --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1 ; then

                hollaex_ascii_web_server_is_up;

                hollaex trade
            
            else 

                printf "\033[91mFailed to start the web on your Kubernetes cluster!033[39m\n"
                echo "Please review the logs and try again."

                exit 1;

            fi
        

        elif [[ ! "$USE_KUBERNETES" ]]; then

            if ! command docker images | grep $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY > /dev/null && command docker images | grep $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION > /dev/null; then

                echo "Error: Can't detect built web docker image on this machine!"
                echo "If this is your first time launching the web server, please run 'hollaex web --setup' instead."
                echo "You can also build the image manually by using 'hollaex web --build' command."

                exit 1;
              
            fi

            # Checking docker-compose is installed on this machine.
            check_docker_compose_is_installed;

            # if [[ "$RUN_WITH_VERIFY" == true ]]; then

            #     echo "Are you sure you want to start the web client on this machine? (Y/n)"

            #     read answer

            #     if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
            #         echo "Exiting..."
            #         exit 0;
            #     fi

            # fi

            if ! command docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null 2>&1; then

                printf "\033[91m\nError: Failed to detect stopped web server on this machine.\033[39m\n"
                echo "If you haven't setup the web server yet, Please run 'hollaex web --setup' first."

                exit 1;

            fi

            echo "Generating web docker-compose file"
            generate_local_docker_compose_for_web

            # if [[ ! -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]] || [[ ! -s "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]]; then

            #     if [[ -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf" ]] && [[ -s "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf" ]]; then

            #         echo "Restoring old web Nginx configuration file"
            #         cp -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf

            #         rm $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf

            #     else

            #         echo "Generating web Nginx configuration file"
            #         generate_hollaex_web_local_nginx_conf
                
            #     fi

            # fi

            echo "Updating main Nginx.conf based on user settings..."
            apply_nginx_user_defined_values

            # Update the nginx if the Kit got a separated domain for the API.
            if [[ ! "$HOLLAEX_CONFIGMAP_API_HOST" == "$HOLLAEX_CONFIGMAP_DOMAIN/api"]]; then

                apply_nginx_separated_kit_domains_values;
            
            fi

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client start; then

                echo "Reloading Nginx..."
                if command docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload; then
                
                    printf "\n\033[92mSuccessfully reloaded the Nginx\033[39m\n"
        
                else

                    printf "\033[93mFailed to reload Nginx. Please make sure to start the exchange API server first.\033[39m\n"
                    echo "The web server could be still reachable through 'http://localhost:8080',"
                    echo "But the allocated domain for the web would not function correctly."

                fi

                hollaex_ascii_web_server_is_up;

                hollaex trade

            else 

                printf "\n\033[91mError: Failed to restart the web server.\033[39m\n"
                echo "Please review your settings and try again."
                exit 1;
            
            fi

            exit 0;

        fi
    fi

    if [[ "$WEB_CLIENT_STOP" ]]; then

        if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        echo "*********************************************"
        #Verify remote Kubernetes cluster is correct.
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to stop (scale down) the web server on this cluster? (Y/n)"

            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        # Web server installation status checking.
        echo "Checking the web installation status on your Kubernetes..."
        if ! command helm ls --namespace $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null 2>&1; then

            printf "\033[91mFailed to detect the web server installed on your Kubernetes cluster.\033[39m\n"
            echo "If you haven't launched the web server yet, Please run 'hollaex web --setup --kube' to set it up first."

            exit 1;
        
        fi

        echo "Removing web ingress rules from the Kubernetes"
        kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

        echo "Stopping (Scaling down) the web server..."
        if command kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-web --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME; then

            printf "\n\033[92mSuccessfully stopped the web server.\033[39m\n"
            echo "To bring it up, Please run 'hollaex web --start --kube' command".
        
        else 

            printf "\033[91m\nError: Failed to stop the web server on the Kubernetes.\033[39m\n"
            echo "Please review the logs and try again."

            exit 1;
        
        fi
    
        elif [[ ! "$USE_KUBERNETES" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to stop the web client on this machine? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Generating web docker-compose file"
            generate_local_docker_compose_for_web

            # echo "Cleaning up the web Nginx configuration..."
            # cp -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf
            # rm $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client stop; then

                # echo "Reloading Nginx..."
                # if command docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload; then
                
                #     printf "\n\033[92mSuccessfully reloaded the Nginx\033[39m\n"
        
                # else

                #     printf "\033[93mFailed to reload Nginx. Please make sure to start the exchange API server first.\033[39m\n"

                # fi

                printf "\n\033[92mSuccessfully stopped the web server.\033[39m\n"
                echo "To bring it up, Please run 'hollaex web --start' command".

            else 

                printf "\n\033[91mError: Failed to stop the web server.\033[39m\n"
                echo "Please review your settings and try again."
                exit 1;
            
            fi

        fi

        exit 0;
        
    fi

    if [[ "$WEB_CLIENT_RESTART" ]]; then

        # if [[ "$RUN_WITH_VERIFY" == true ]]; then

        #     if command docker images | grep $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY > /dev/null && command docker images | grep $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION > /dev/null; then

        #         printf "\nPre-built image for web server has been detected on your system.\n"
        #         echo "You should build the image again if you made code changes for web."
        #         echo "Plase input 'Y' to skip the build, 'N' to build the image again."
        #         echo "Do you want to proceed with the pre-built image? (Y/n)"
        #         read answer 

        #         if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then

        #             export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-web-$(cat version)-$(date +%y%m%d%H%M)"
        #             echo "Building the web server image..."
        #             build_user_hollaex_web;
                
        #         else 

        #             echo "Proceeding..."
                
        #         fi
            
        #     else 

        #         export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-web-$(cat version)-$(date +%y%m%d%H%M)"
        #         echo "Building the web server image..."
        #         build_user_hollaex_web;

        #     fi

        # else 

        #     export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-web-$(cat version)-$(date +%y%m%d%H%M)"
        #     echo "Building the web server image..."
        #     build_user_hollaex_web;

        # fi

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            #Verify remote Kubernetes cluster is correct.
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to restart web client for the exchange on this cluster? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Generating web ingress rules for Kubernetes"
            generate_kubernetes_ingress_for_web;

            echo "Applying web ingress rules for Kubernetes"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml
            
            # FOR GENERATING NODESELECTOR VALUES
            generate_nodeselector_values ${ENVIRONMENT_KUBERNETES_EXCHANGE_STATELESS_NODESELECTOR:-$ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR} hollaex-stateless

            echo "Restarting the $HOLLAEX_CONFIGMAP_API_NAME web server."
            if command helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-web \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY" \
                        --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION" \
                        --set stable.replicaCount="${ENVIRONMENT_KUBERNETES_WEB_SERVER_REPLICAS:-1}" \
                        --set autoScaling.hpa.enable="${ENVIRONMENT_KUBERNETES_WEB_HPA_ENABLE:-false}" \
                        --set autoScaling.hpa.avgMemory="${ENVIRONMENT_KUBERNETES_WEB_HPA_AVGMEMORY:-500000000}" \
                        --set autoScaling.hpa.maxReplicas="${ENVIRONMENT_KUBERNETES_WEB_HPA_MAXREPLICAS:-4}" \
                        --set envName="$ENVIRONMENT_EXCHANGE_NAME-web-env" \
                        --set resources.limits.cpu="${ENVIRONMENT_WEB_CPU_LIMITS:-1000m}" \
                        --set resources.limits.memory="${ENVIRONMENT_WEB_MEMORY_LIMITS:-1024Mi}" \
                        --set resources.requests.cpu="${ENVIRONMENT_WEB_CPU_REQUESTS:-2m}" \
                        --set resources.requests.memory="${ENVIRONMENT_WEB_MEMORY_REQUESTS:-100Mi}" \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex-stateless.yaml \
                        -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-web/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-web; then

                # Scaling up the web in case of it gets already scaled down.
                kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-web --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

                echo -e "\n\033[92mSuccessfully restarted the web server on the Kubernetes!\033[39m\n"

                hollaex_ascii_web_server_is_up;
               
            else 

                printf "\033[91mFailed to restart the web server.\033[39m\n"
                echo "Please review the logs and try agian."
                exit 1;

            fi

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_is_installed;

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to restart web client for the exchange on this machine? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi
                
            fi

            echo "Generating web docker-compose file"
            generate_local_docker_compose_for_web

            echo "Generating web .env file"
            generate_hollaex_web_local_env

            if [[ ! -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/upstream-web.conf" ]]; then

                echo "Generating web Nginx upstream file"
                generate_nginx_upstream_for_web

            fi 

            # Only generated the separated web.conf file if user got a different domain for the API.
            if [[ ! "$HOLLAEX_CONFIGMAP_API_HOST" == "$HOLLAEX_CONFIGMAP_DOMAIN/api"]]; then

                if [[ ! -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]]; then

                    echo "Generating web Nginx configuration file"
                    generate_hollaex_web_local_nginx_conf

                fi

            fi

            echo "Updating main Nginx.conf based on user settings..."
            apply_nginx_user_defined_values

            # Update the nginx if the Kit got a separated domain for the API.
            if [[ ! "$HOLLAEX_CONFIGMAP_API_HOST" == "$HOLLAEX_CONFIGMAP_DOMAIN/api"]]; then

                apply_nginx_separated_kit_domains_values;
            
            fi

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client stop; then
                
                docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client up -d

                echo "Reloading Nginx..."
                if command docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload; then
                
                    printf "\n\033[92mSuccessfully reloaded the Nginx\033[39m\n"
        
                else

                    printf "\033[93mFailed to reload Nginx. Please make sure to start the exchange API server first.\033[39m\n"
                    echo "The web server could be still reachable through 'http://localhost:8080',"
                    echo "But the allocated domain for the web would not function correctly."

                fi

                hollaex_ascii_web_server_is_up;

            else 

                printf "\n\033[91mError: Failed to restart the web server.\033[39m\n"
                echo "Please review your settings and try again."
                exit 1;
            
            fi

            exit 0;

        fi
    fi

    if [[ "$WEB_CLIENT_UPGRADE" ]];  then
        
        export OVERRIDE_THE_WEB_IMAGE_TAG=true 

        export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY=${ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE:-$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY}
        export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-web-$(cat version)-$(date +%y%m%d%H%M)"
        build_user_hollaex_web;

        ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE_PARSED=${ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY}
        ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION_OVERRIDE=${ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION}

        override_user_hollaex_web;

        for i in ${CONFIG_FILE_PATH[@]}; do
            source $i
        done;

        if [[ "$USE_KUBERNETES" ]]; then

                hollaex web --restart --kube --skip

        else 

                hollaex web --restart --skip

        fi

        exit 0;

    fi

    if [[ "$WEB_CLIENT_REBUILD" ]];  then
        
        export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-web-$(cat $HOLLAEX_CLI_INIT_PATH/web/package.json | jq -r '.version')-$(date +%y%m%d%H%M)"
        build_user_hollaex_web;

        echo -e "\nPlease run 'hollaex web --apply --registry $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY --tag $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION $(if [[ "$USE_KUBERNETES" ]]; then echo "--kube"; fi)' to apply it on the server."

        exit 0;

    fi

    if [[ "$WEB_CLIENT_APPLY" ]];  then

        ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE_PARSED=${ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE:-$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY}
        ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION_OVERRIDE=${ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION_OVERRIDE:-$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION}
        
        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            printf "\033[93mWarning: Exchange web service will be unavailable while applying the new image!\033[39m\n"
            echo "Are you sure you want to apply the $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE_PARSED:$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION_OVERRIDE image on your exchange web? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        override_user_hollaex_web

        for i in ${CONFIG_FILE_PATH[@]}; do
            source $i
        done;

        if [[ "$USE_KUBERNETES" ]]; then

                hollaex web --restart --kube --skip

        else 

                hollaex web --restart --skip

        fi

    fi

    if [[ "$WEB_CLIENT_TERMINATE" ]]; then

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            #Verify remote Kubernetes cluster is correct.
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to terminate the web server on this cluster? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Removing web ingress rule on the cluster"
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

            echo "Removing the web server..."
            if command helm uninstall --namespace $ENVIRONMENT_EXCHANGE_NAME $ENVIRONMENT_EXCHANGE_NAME-web; then

                printf "\n\033[92mWeb server has been successfully terminated.\033[39m\n"
                echo "Please run 'hollaex web --setup --kube' if you want to set it up again."
            
            else 

                printf "\033[91mFailed to terminate the web server from the Kubernetes.\033[39m\n"
                echo "Please review the logs and try agian."
                exit 1;

            fi

            exit 0;
                

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_is_installed;

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to terminate the web client on this machine? (y/N)"
                echo "This can't be undo."

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Cleaning up the web Nginx configuration..."
            cp -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf
            rm $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client down --remove-orphans; then

                echo "Reloading Nginx..."
                if command docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload; then
                
                    printf "\n\033[92mSuccessfully reloaded the Nginx\033[39m\n"
        
                else

                    printf "\033[93mFailed to reload Nginx. Please make sure to start the exchange API server first.\033[39m\n"

                fi

                printf "\n\033[92mThe web server has been successfully terminated.\033[39m\n"
                echo "Please run 'hollaex web --setup' to set it up again."

            else 

                printf "\033[91mHollaEx CLI failed to terminate the web server. Please review your settings and try again.\033[39m\n"
                exit 1;
            
            fi

            exit 0;

        fi
    fi

    if [[ "$WEB_CLIENT_SCALE" ]]; then

        if [[ ! "$HOLLAEX_WEB_SCALE_TARGET_REPLICAS" ]]; then

            echo -e "\nError: Target replicas number is not specified."
            echo -e "Please use --replicas flag to specify the replicas number.\n"

            exit 1;

        fi

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            # For scaling up exisitng Exchange on Kubernetes
            if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then

                echo "Scaling up containers on the cluster..."
                kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-web --replicas=$HOLLAEX_WEB_SCALE_TARGET_REPLICAS --namespace $ENVIRONMENT_EXCHANGE_NAME
                
                for i in ${CONFIG_FILE_PATH[@]}; do

                    # Update exchange name
                    if command grep -q "ENVIRONMENT_EXCHANGE_NAME" $i > /dev/null ; then
                        CONFIGMAP_FILE_PATH=$i
                        sed -i.bak "s/$ENVIRONMENT_KUBERNETES_WEB_SERVER_REPLICAS=.*/$ENVIRONMENT_KUBERNETES_WEB_SERVER_REPLICAS=$HOLLAEX_WEB_SCALE_TARGET_REPLICAS/" $CONFIGMAP_FILE_PATH
                        rm $CONFIGMAP_FILE_PATH.bak
                    fi
                    
                done

                printf "\033[92m\nWeb server has been successfully scaled to $HOLLAEX_WEB_SCALE_TARGET_REPLICAS.\033[39m\n"

            else 

                printf "\033[91mFailed to scale the target $HOLLAEX_WEB_SCALE_TARGET_REPLICAS! Please review your settings and try again.\033[39m\n"
                exit 1;

            fi

        else

            generate_local_docker_compose_for_web;

            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client down

            # Running docker-compose scale command.
            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client up -d --no-recreate --scale $ENVIRONMENT_EXCHANGE_NAME-web=$HOLLAEX_WEB_SCALE_TARGET_REPLICAS; then
                
                # Nginx Reload
                # docker exec -it $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload

                printf "\033[92m\nWeb server has been successfully scaled to $HOLLAEX_WEB_SCALE_TARGET_REPLICAS.\033[39m\n"
            
            else 

                printf "\033[91mFailed to scale the web server! Please review your settings and try again.\033[39m\n"
                exit 1;
            
            fi

        fi

    fi

    exit 0

elif [[ "$1" == "toolbox" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --dev)
                IS_DEVELOP=true
                echo "HollaEx CLI is configured as dev mode for development purpose."
                shift; continue
                ;;
            --upgrade_backends)
                UPGRADE_BACKENDS=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will upgrade your backends (PostgreSQL, Redis) based on your settings files value."
                shift; continue
                ;;
            --backup)
                BACKUP_POSTGRESQL=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will run PostgreSQL database dump on your initialized exchange folder."
                shift; continue
                ;;
            --restore)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                RESTORE_POSTGRESQL=true
                RESTORE_POSTGRES_DUMP_PATH=$1
                TOOLBOX_ENABLE=true
                shift; continue
                ;;
            --set_backup_cronjob)
                KUBERNETES_SET_BACKUP_POSTGRESQL_CRONJOB=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will install PostgreSQL database dump cronjob on your Kubernetes cluster."
                shift; continue
                ;;
            --flush_redis)
                FLUSH_REDIS=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will run full flush of Redis stored data. This could be helpful in certain situation If the exchange doesnt work properly."
                shift; continue
                ;;
            --is_hollaex_setup)
                IS_HOLLAEX_SETUP=true
                shift; continue
                ;;
            
            --issue_ssl)
                ISSUE_SSL_CERT=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to issue SSL certificate by using Let's Encrypt for local exchange."
                shift; continue
                ;;
            --renew_ssl)
                RENEW_SSL_CERT=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to renew SSL certificate by using Let's Encrypt for local exchange."
                shift; continue
                ;;
             --update_registry_secret)
                UPDATE_REGISTRY_SECRET=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will update your docker image registry secret for Kubernetes."
                shift; continue
                ;;
            --set_activation_code)
                SET_ACTIVATION_CODE=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will update your activation code for the exchange."
                shift; continue
                ;;
            --check_constants)
                CHECK_CONSTANTS=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will check and update your database constants."
                shift; continue
                ;;
            --set_config)
                SET_CONFIG=true
                TOOLBOX_ENABLE=true
                echo "Override database-stored cosntants with local configmap-stored values."
                shift; continue
                ;;
            --set_security)
                set_security=true
                TOOLBOX_ENABLE=true
                echo "Override exchange secret values with provided ones."
                shift; continue
                ;;
             --connect_database)
                CONNECT_DATABASE=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will open a direct connection to your PostgreSQL database via postgresql-client."
                shift; continue
                ;;
             --connect_redis)
                CONNECT_REDIS=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will open a direct connection to your PostgreSQL database via redis-client."
                shift; continue
                ;;
            --install_cli)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                INSTALL_CLI_ENABLE=true
                INSTALL_CLI_TARGET=$1
                TOOLBOX_ENABLE=true
                shift; continue
                ;;
            --reset_hmac_token)
                RESET_HMAC_TOKEN=true
                TOOLBOX_ENABLE=true
                echo "Getting the HMAC Token from the HollaEx server."
                shift; continue
                ;;
            --enable_maintenance_mode)
                ENABLE_MAINTENANCE_MODE=true
                TOOLBOX_ENABLE=true
                echo "Enabling the maintenance mode with IP whitelists."
                shift; continue
                ;;
            --disable_maintenance_mode)
                DISABLE_MAINTENANCE_MODE=true
                TOOLBOX_ENABLE=true
                echo "Disabling the maintenance mode."
                shift; continue
                ;;
            --whitelist-ip)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_MAINTENANCE_MODE_WHITELIST_IP=$1
                TOOLBOX_ENABLE=true
                

                if [[ "$HOLLAEX_MAINTENANCE_MODE_WHITELIST_IP" == "* *" ]]; then 

                    echo "Error: The whitelisted IPs should be comma separated with no space."
                    echo "Please try it again"
                    exit 1;

                fi 

                shift; continue
                ;;
            --loginKey)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_LOGIN_KEY=$1
                TOOLBOX_ENABLE=true
                shift; continue
                ;;
            --get_seo_html)
                GET_SEO_HTML=true
                TOOLBOX_ENABLE=true
                echo "Download custom SEO html file from HollaEx Dashboard."
                shift; continue
                ;;
            --network)
                IS_NETWORK=true
                TOOLBOX_ENABLE=true
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    # For dev command legacy mode
    if [[ "$HOLLAEX_DEV_FOR_CORE" ]]; then

        HOLLAEX_CODEBASE_PATH=$(pwd)

        HOLLAEX_CLI_INIT_PATH=$HOLLAEX_KIT_PATH
        CONFIG_FILE_PATH=$HOLLAEX_KIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_KIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_KIT_PATH/.hollaex

    fi

    # PATH overriding for develop    
    if [[ "$IS_DEVELOP" ]]; then

        if [[ "$HOLLAEX_CODEBASE_PATH" ]]; then

            CONFIG_FILE_PATH=$HOLLAEX_CODEBASE_PATH/tools/hollaex-cli-settings/*
            TEMPLATE_GENERATE_PATH=$HOLLAEX_CODEBASE_PATH/tools/hollaex-cli-templates
            INIT_PATH_CHECK=$HOLLAEX_CODEBASE_PATH/.hollaex

        elif [[ ! "$HOLLAEX_CODEBASE_PATH" ]]; then

            CONFIG_FILE_PATH=$(pwd)/tools/hollaex-cli-settings/*
            TEMPLATE_GENERATE_PATH=$(pwd)/tools/hollaex-cli-templates
            INIT_PATH_CHECK=$(pwd)/.hollaex
            HOLLAEX_CODEBASE_PATH=$(pwd)

        fi

    fi
    
    

    if [[ ! "$TOOLBOX_ENABLE" ]]; then
    
        print_usage;
        echo "No features are enabled for toolbox. Please recheck the command."
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    #Creating kubernetes_config directory for generating config for Kubernetes.
    if [[ "$USE_KUBERNETES" ]]; then 
        
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes;
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! -f "$TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex-stateful.yaml" ]]; then

            generate_nodeselector_values ${ENVIRONMENT_KUBERNETES_EXCHANGE_STATEFUL_NODESELECTOR:-ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR} hollaex-stateful

        fi

    else 

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi

    fi

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        echo "*********************************************"
        #Verify remote Kubernetes cluster is correct.
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

    fi

    # Features
    if [[ "$UPGRADE_BACKENDS" ]]; then 

        printf "\033[93mWarning: Exchange service will be unavailable during the upgrade!\033[39m\n"

        echo "All workload containers will be restarted once the upgrade process is done."
    
        if [[ "$USE_KUBERNETES" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to upgrade backends (PostgreSQL, Redis) to latest compatible on this cluster? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Deleting Ingress rules for the exchange..."
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

            # DROP OLD INGRESS RULES IF IT EXISTS ON THE CLUSTER
            if command kubectl get ingress/$ENVIRONMENT_EXCHANGE_NAME-ingress-api-order -n $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then
            
                kubectl delete -n $ENVIRONMENT_EXCHANGE_NAME ingress/$ENVIRONMENT_EXCHANGE_NAME-ingress-api-order
                kubectl delete -n $ENVIRONMENT_EXCHANGE_NAME ingress/$ENVIRONMENT_EXCHANGE_NAME-ingress-api-admin
                kubectl delete -n $ENVIRONMENT_EXCHANGE_NAME ingress/$ENVIRONMENT_EXCHANGE_NAME-ingress-api-explorer
                kubectl delete -n $ENVIRONMENT_EXCHANGE_NAME ingress/$ENVIRONMENT_EXCHANGE_NAME-ingress-docs

            fi

            
            if [[ "$ENVIRONMENT_KUBERNETES_RUN_POSTGRESQL_DB" ]]; then

                echo "Upgrading PostgreSQL DB"
                generate_nodeselector_values $ENVIRONMENT_KUBERNETES_POSTGRESQL_DB_NODESELECTOR postgresql

                helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-db \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --set pvc.create=true \
                        --set pvc.name="$ENVIRONMENT_EXCHANGE_NAME-postgres-volume" \
                        --set pvc.size="$ENVIRONMENT_KUBERNETES_POSTGRESQL_DB_VOLUMESIZE" \
                        --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                        --set resources.limits.cpu="${ENVIRONMENT_POSTGRESQL_CPU_LIMITS:-100m}" \
                        --set resources.limits.memory="${ENVIRONMENT_POSTGRESQL_MEMORY_LIMITS:-200Mi}" \
                        --set resources.requests.cpu="${ENVIRONMENT_POSTGRESQL_CPU_REQUESTS:-10m}" \
                        --set resources.requests.memory="${ENVIRONMENT_POSTGRESQL_MEMORY_REQUESTS:-100Mi}" \
                        -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres/values.yaml \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-postgresql.yaml \
                        $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres $(kubernetes_set_backend_image_target $ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_VERSION) $(set_nodeport_access $ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_POSTGRESQL_DB_ACCESS $ENVIRONMENT_KUBERNETES_EXTERNAL_POSTGRESQL_DB_ACCESS_PORT)

            fi

            if [[ "$ENVIRONMENT_KUBERNETES_RUN_REDIS" ]]; then

                echo "Upgrading Redis"
                generate_nodeselector_values $ENVIRONMENT_KUBERNETES_REDIS_NODESELECTOR redis

                helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-redis \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --set setAuth.secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                        --set resources.limits.cpu="${ENVIRONMENT_REDIS_CPU_LIMITS:-100m}" \
                        --set resources.limits.memory="${ENVIRONMENT_REDIS_MEMORY_LIMITS:-200Mi}" \
                        --set resources.requests.cpu="${ENVIRONMENT_REDIS_CPU_REQUESTS:-10m}" \
                        --set resources.requests.memory="${ENVIRONMENT_REDIS_MEMORY_REQUESTS:-100Mi}" \
                        $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-redis $(kubernetes_set_backend_image_target $ENVIRONMENT_DOCKER_IMAGE_REDIS_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_REDIS_VERSION) $(set_nodeport_access $ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_REDIS_ACCESS $ENVIRONMENT_KUBERNETES_EXTERNAL_REDIS_ACCESS_PORT)

            fi

            echo "Restarting all workload containers..."
            kubectl delete pods --namespace $ENVIRONMENT_EXCHANGE_NAME -l role=$ENVIRONMENT_EXCHANGE_NAME

            sleep 10;

            echo "Applying Ingress rules for the exchange..."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

            exit 0;

        elif [[ ! "$USE_KUBERNETES" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to upgrade backends (PostgreSQL, Redis, InfluxDB) to latest compatible on this machine? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "All workload containers will be restarted once the upgrade process is done."

            echo "Regenerating docker-compose file..."
            generate_local_docker_compose $ENVIRONMENT_EXCHANGE_RUN_MODE

            echo "Restarting containers..."
            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d

            exit 0;

        fi

    elif [[ "$RESTORE_POSTGRESQL" ]]; then

        # Check pg_dump is available on your local
        if command pg_restore --version > /dev/null 2>&1; then

            echo "pg_restore detected on your machine!"
            pg_restore --version

        else 

            echo "HollaEx CLI failed to detect pg_restore on your machine"
            echo "Please make sure that you already installed pg_restore."

            exit 1;

        fi 

        if [[ ! $RESTORE_POSTGRES_DUMP_PATH ]]; then

            echo "Error: Dump file path to restore has not been defined."
            echo "Please define a dump file path along the command."
            exit 1;

        fi

        if [[ "$USE_KUBERNETES" ]] && [[ "$ENVIRONMENT_KUBERNETES_RUN_POSTGRESQL_DB" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to restore the PostgreSQL database with your dump file on this cluster? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "HollaEx CLI will open proxy tunnel between your machine and remote proxy with kubectl proxy."

            echo "Opening local proxy on 5432 port of your machine..."
            kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-db" -o name | sed 's/pod\///' | head -n 1) 5432:5432 &

            echo "Waiting for the proxy tunnel get fully ready..."
            sleep 10;
            
            echo "Applying the db dump through pg_restore..."
            export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
            export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
            export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
            export PGHOST=localhost
            
            if ! command pg_restore --verbose --clean -d $PGDATABASE $RESTORE_POSTGRES_DUMP_PATH; then 

                echo "Error: Failed to restore the dump to your Database."
                echo "Please check the logs and try again."
                exit 1;
            
            fi
            
            unset PGUSER
            unset PGPASSWORD
            unset PGDATABASE
            unset PGHOST

            echo -e "\nDump data has been applied on your database."

            if [[ "$HOLLAEX_NETWORK_RESTORE" ]]; then 

                echo -e "Please run 'hollaex network --restart --kube' to fully apply the changes.\n"
            
            else 

                echo -e "Please run 'hollaex server --restart --kube' to fully apply the changes.\n"

            fi 

            echo "Killing the opened proxy tunnel..."
            kill $(ps -ef | grep "kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME" | awk '{print $2}' | head -n 1)

            exit 0;

        fi

        if [[ ! "$USE_KUBERNETES" ]] && [[ "$ENVIRONMENT_DOCKER_COMPOSE_RUN_POSTGRESQL_DB" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to restore the PostgreSQL database with your dump file? (Y/n)"
                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Applying the db dump through pg_restore..."
            
            export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
            export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
            export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
            export PGHOST=localhost

            if ! command pg_restore --verbose --clean -d $PGDATABASE $RESTORE_POSTGRES_DUMP_PATH; then 

                echo "Error: Failed to restore the dump to your Database."
                echo "Please check the logs and try again."
                exit 1;

            fi 
            
            unset PGUSER
            unset PGPASSWORD
            unset PGDATABASE
            unset PGHOST
            unset PGPORT

            echo -e "\nDump data has been applied on your database."

            if [[ "$HOLLAEX_NETWORK_RESTORE" ]]; then 

                echo -e "Please run 'hollaex network --restart' to fully apply the changes.\n"
            
            else 

                echo -e "Please run 'hollaex server --restart' to fully apply the changes.\n"

            fi 

            exit 0;

        fi
    
    elif [[ "$BACKUP_POSTGRESQL" ]]; then

    # Check pg_dump is available on your local
        if command pg_dump --version > /dev/null 2>&1; then

            echo "pg_dump detected on your machine!"
            pg_dump --version

        else 

            echo "HollaEx CLI failed to detect pg_dump on your machine"
            echo "Please make sure that you already installed pg_dump"

            exit 1;

        fi 

        if [[ ! -d $HOLLAEX_CLI_INIT_PATH/backups ]]; then

            echo "Creating '/backups' folder on HollaEx Kit directory"
            mkdir $HOLLAEX_CLI_INIT_PATH/backups

        fi

        if [[ "$IS_NETWORK" ]]; then 

            export PGPORT=5433

        fi 

        if [[ "$USE_KUBERNETES" ]] && [[ "$ENVIRONMENT_KUBERNETES_RUN_POSTGRESQL_DB" ]]; then

            echo "HollaEx CLI will open proxy tunnel between your machine and remote proxy with kubectl proxy."

            echo "Opening local proxy on 5432 port of your machine..."
            kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-db" -o name | sed 's/pod\///' | head -n 1) 5432:5432 &

            echo "Waiting for the proxy tunnel get fully ready..."
            sleep 10;
            
            echo "Running pg_dump..."
            export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
            export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
            export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
            export PGHOST=localhost

            if ! command pg_dump -Fc  > "${HOLLAEX_CLI_INIT_PATH}"/backups/$HOLLAEX_CONFIGMAP_API_NAME-db-"$(date +%y%m%d%H%M)".dump; then 

                echo "Error: Failed to run pg_dump for your Database."
                echo "Please check the logs and try again."
                exit 1;
            
            fi
            
            unset PGUSER
            unset PGPASSWORD
            unset PGDATABASE
            unset PGHOST

            echo "Dump data is saved at ${HOLLAEX_CLI_INIT_PATH}/backups folder"

            echo "Killing the opened proxy tunnel..."
            kill $(ps -ef | grep "kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME" | awk '{print $2}' | head -n 1)

            exit 0;

        fi

        if [[ ! "$USE_KUBERNETES" ]] && [[ "$ENVIRONMENT_DOCKER_COMPOSE_RUN_POSTGRESQL_DB" ]]; then

            echo "HollaEx CLI will backup your local PostgreSQL DB."

            echo "Running pg_dump..."
            
            export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
            export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
            export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
            export PGHOST=localhost
            
            if ! command pg_dump -Fc > $HOLLAEX_CLI_INIT_PATH/backups/$HOLLAEX_CONFIGMAP_API_NAME-db-$(date +%y%m%d%H%M).dump; then 
            
                echo "Error: Failed to run pg_dump for your Database."
                echo "Please check the logs and try again."
                exit 1;
            
            fi
            
            unset PGUSER
            unset PGPASSWORD
            unset PGDATABASE
            unset PGHOST
            unset PGPORT

            echo "Dump data is saved at ${HOLLAEX_CLI_INIT_PATH}/backups folder"

            exit 0;

        fi

    elif [[ "$KUBERNETES_SET_BACKUP_POSTGRESQL_CRONJOB" ]]; then

        if [[ "$USE_KUBERNETES" ]] ; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to install cronjob for database backup on this cluster? (y/N)"
                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            generate_db_s3_backup_cronjob_config;

            echo "Installing cronjob for database backup on Kubernetes."
            if command helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-db-backup-s3 \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/db-s3-backup-cronjob.yaml \
                        $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres-s3-backup-cronjob; then
                
                echo "The cronjob has been installed successfully!"

                echo "The job will be triggered by following $ENVIRONMENT_KUBERNETES_S3_BACKUP_CRONJOB_RULE rule."
                
                exit 0;

            else 

                echo "Failed to install the cronjob at the Kubernetes cluster."
                echo "Please check the error logs and try again."

                exit 1;

            fi
            
        
        elif [[ ! "$USE_KUBERNETES" ]] ; then

            echo "HollaEx CLI only supports install cronjob for database backup on Kubernetes environment."
            echo "Please use --kube flag to target Kubernetes."

            exit 1;

        fi
        
        
    elif [[ "$FLUSH_REDIS" ]]; then

        printf "\033[93mWarning: Exchange service will be unavailable during the flush!\033[39m\n"

        if [[ "$USE_KUBERNETES" ]] ; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to run flush Redis data on this cluster? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Flushing Redis..."
            kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- node tools/dbs/flushRedis.js

            echo "Restarting all workload containers..."
            kubectl delete pods --namespace $ENVIRONMENT_EXCHANGE_NAME -l role=$ENVIRONMENT_EXCHANGE_NAME

            exit 0;

        elif [[ ! "$USE_KUBERNETES" ]] ; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to to run flush Redis data on this machine? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Shutting down Nginx to block exchange external access"
            docker stop $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ")

            IFS=',' read -ra CONTAINER_PREFIX <<< "-${ENVIRONMENT_EXCHANGE_RUN_MODE}"
            
            echo "Flushing Redis..."
            docker exec ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX[0]}_1 node tools/dbs/flushRedis.js

            echo "Restarting all workload containers..."
            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml restart

            sleep 10;

            exit 0;
        fi

    elif [[ "$ISSUE_SSL_CERT" ]]; then
        
        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Would you like to continue to issue SSL cert through Let's Encrypt? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]]; then
                echo "Exiting..."
                exit 0;
            fi
        fi

        echo "Issuing SSL..."

        if command docker exec -it $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") certbot --nginx; then
            
            echo "SSL cert has been successfully set."
            echo "All the Let's encrypt related files can be found at ./templates/local/letsencrypt."

            echo "Updating domanin configurations to use HTTPS at user settings file..."

            UPDATED_HOLLAEX_CONFIGMAP_API_HOST=${HOLLAEX_CONFIGMAP_API_HOST//http:/https:}
            UPDATED_HOLLAEX_CONFIGMAP_DOMAIN=${HOLLAEX_CONFIGMAP_DOMAIN//http:/https:}

            ESCAPED_HOLLAEX_CONFIGMAP_API_HOST=${UPDATED_HOLLAEX_CONFIGMAP_API_HOST//\//\\/}
            ESCAPED_HOLLAEX_CONFIGMAP_DOMAIN=${UPDATED_HOLLAEX_CONFIGMAP_DOMAIN//\//\\/}

            for i in ${CONFIG_FILE_PATH[@]}; do
                if command grep -q "ENVIRONMENT_EXCHANGE_NAME" $i > /dev/null ; then
                    CONFIGMAP_FILE_PATH=$i

                    sed -i.bak "s/HOLLAEX_CONFIGMAP_API_HOST=.*/HOLLAEX_CONFIGMAP_API_HOST=$ESCAPED_HOLLAEX_CONFIGMAP_API_HOST/" $CONFIGMAP_FILE_PATH
                    sed -i.bak "s/HOLLAEX_CONFIGMAP_DOMAIN=.*/HOLLAEX_CONFIGMAP_DOMAIN=$ESCAPED_HOLLAEX_CONFIGMAP_DOMAIN/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak
                fi
            done

            if command docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null ; then

                printf "\n\033[93mWarning: You should rebuild and restart your web server to apply SSL configuraion on the web.\033[39m\n\n"
                echo "The web server would malfunction if the server doesn't get rebuild"
                echo "Please run 'hollaex web --restart' to rebuild the image and apply."
                printf "\n"

            fi

            printf "\n\nNote: The SSL certificate issued by Let's Encrypt requires a \033[1mrenewal in every 3 months.\033[0m\n"
            printf "Please make sure to run '\033[1mhollaex toolbox --renew_ssl\033[0m' to renew your SSL certificate before it gets expired.\n"
            printf "\nIt is recommended to \033[1msetup a Cronjob\033[0m to automate the renewal process.\n"

            exit 0;

        else 

            printf "\033[91mFailed to issue SSL certificate by using Certbot. Please confirm your settings and try again.\033[39m\n"
            exit 1;

        fi
 
        
    
    elif [[ "$RENEW_SSL_CERT" ]]; then

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Would you like to continue to renew SSL cert through Let's Encrypt? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]]; then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo "Renewing SSL..."

        if command docker exec -it $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") certbot renew; then
        
            echo "SSL cert has been successfully renewed."
            echo "All Let's encrypt related files can be found at ./templates/local/letsencrypt."

        else 

            printf "\033[91mFailed to issue SSL certificate by using Certbot. Please confirm your settings and try again.\033[39m\n"
            exit 1;

        fi
      

    elif [[ "$UPDATE_REGISTRY_SECRET" ]]; then

        if [[ ! "$USE_KUBERNETES" ]]; then 

            echo "Warning: Docker registry secret update is only available for Kubernetes."
            echo "Please use 'hollaex toolbox --update_registry_secret --kube' command instead."
            exit 1;

        fi

        check_kubernetes_dependencies;
        
        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        echo "Are you sure that you want to update your existing Docker registry secret at this Kubernets cluster? (y/N)"
        read answer 

        if [[ "$answer" = "${answer#[Yy]}" ]] ;then
            echo "Exiting..."
            exit 0;
        fi

        echo "Removing the current Docker registry secret at $ENVIRONMENT_EXCHANGE_NAME namespace."
        kubectl delete secret docker-registry-secret --namespace $ENVIRONMENT_EXCHANGE_NAME

         if [[ "$ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_USERNAME" ]] && [[ "$ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_PASSWORD" ]] && [[ "$ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_EMAIL" ]]; then

            echo "Docker registry credentials are detected at your configmap file."

            echo "*********************************************"
            echo "Docker Registry Host: $ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_HOST"
            echo "Docker Registry Email: $ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_EMAIL"
            echo "Docker Registery Username: $ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_USERNAME"
            echo "Docker Registry Password: $(echo ${ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_PASSWORD//?/◼︎}$(echo $ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_PASSWORD | grep -o '....$'))"
            echo "*********************************************"
            echo "You can either proceed with this values, or set it again manually by yourself."
            echo "Do you want to proceed with this values? (Y/n)"
            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then

                echo "Proceeding to a from to re-fill up the credentials."
                MANUAL_DOCKER_REGISTRY_SECRET_UPDATE=true

            fi
        
        fi

        create_kubernetes_docker_registry_secret;
    
    elif [[ "$SET_ACTIVATION_CODE" ]]; then
        
        if [[ "$USE_KUBERNETES" ]]; then 

            check_kubernetes_dependencies;
        
            echo "*********************************************"
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            echo "Are you sure that you want to update your activation code for the exchange on this Kubernets cluster? (y/N)"
            read answer 

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

            update_activation_code_input;

            update_activation_code_exec;

            echo "Your activation code has been successfully updated!"
            echo "Make sure to run 'hollaex restart --kube' to fully apply it."


        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_dependencies;

            echo "Are you sure that you want to update your activation code for the exchange on this machine? (y/N)"
            read answer 

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

            update_activation_code_input;

            update_activation_code_exec;

            echo "Your activation code has been successfully updated!"
            echo "Make sure to run 'hollaex restart' to fully apply it."

        fi

    elif [[ "$CHECK_CONSTANTS" ]]; then

        function toolbox_set_constants_confirm_message() {

            echo "This command would check and update the missing database constants, based on your settings files."
            echo "The missing value could be caused by an upgrade or an error at exchange initialization."
            echo "Do you want to proceed? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        }

        if [[ "$USE_KUBERNETES" ]]; then 

            toolbox_set_constants_confirm_message;

            echo "Generating Kubernetes Configmap."
            generate_kubernetes_configmap;

            echo "Generating Kubernetes Secret."
            generate_kubernetes_secret;

             echo "Applying configmap on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml
            
            echo "Applying secret on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

            check_constants_exec;
            
        elif [[ ! "$USE_KUBERNETES" ]]; then 
        
            toolbox_set_constants_confirm_message; 

            toolbox_set_config_confirm_message;
            
            generate_local_env;

            check_constants_exec;

        fi


    elif [[ "$SET_CONFIG" ]]; then

        function toolbox_set_config_confirm_message() {

            echo "Warning: This command is not recommended for most of users in most of use cases."
            echo "This command would completely override your database to update values with local settings."
            echo "Are you sure you want to update database-stored constatns with your local configmap values? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        }

        if [[ "$USE_KUBERNETES" ]]; then 

            toolbox_set_config_confirm_message;

            echo "Generating Kubernetes Configmap."
            generate_kubernetes_configmap;

            echo "Generating Kubernetes Secret."
            generate_kubernetes_secret;

             echo "Applying configmap on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml
            
            echo "Applying secret on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

            set_config_exec;
            
        elif [[ ! "$USE_KUBERNETES" ]]; then 
        
            check_docker_compose_dependencies; 

            toolbox_set_config_confirm_message;
            
            generate_local_env;

            set_config_exec;

        fi

    elif [[ "$set_security" ]]; then

        function toolbox_set_security_confirm_message() {

            echo "Warning: This command would override security values* values of your exchange with new ones provided."
            echo "*Security values: Allowed domains, Allowed Admin IPs, reCaptcha Access & Secret keys."
            echo "Do you want to continue? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        }

        if [[ "$USE_KUBERNETES" ]]; then 

            toolbox_set_security_confirm_message;

            set_security_input;

            echo "Generating Kubernetes Configmap."
            generate_kubernetes_configmap;

            echo "Generating Kubernetes Secret."
            generate_kubernetes_secret;

             echo "Applying configmap on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml
            
            echo "Applying secret on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml
            
            set_security_exec;
            

        elif [[ ! "$USE_KUBERNETES" ]]; then 
        
            check_docker_compose_dependencies; 

            toolbox_set_security_confirm_message;

            set_security_input;

            set_security_exec;

        fi



    elif [[ "$CONNECT_DATABASE" ]]; then

        if ! command psql --version > /dev/null 2>&1; then

            printf "\033[91mHollaEx CLI failed to detect postgresql-client at your computer.\033[39m\n"
            echo "Please install it first, before proceeding."
            exit 1;
        
        fi

        if [[ "$USE_KUBERNETES" ]]; then 

            check_kubernetes_dependencies;

            if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1 && command kubectl get pods -n $ENVIRONMENT_EXCHANGE_NAME -l app=$ENVIRONMENT_EXCHANGE_NAME-db > /dev/null 2>&1; then

                echo "Successfully detected the PostgreSQL DB created by HollaEx CLI."
                echo "Opening kube-proxy tunnel for database connection..."

                kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-db" -o name | sed 's/pod\///' | head -n 1) 5432:5432 &
                sleep 5;
                
                echo "Opening local proxy on 5432 port of your machine..."
                export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
                export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
                export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
                export PGHOST=localhost

                echo "Opening postgresql-client shell..."
                psql 

                echo "Killing the opened proxy tunnel..."
                kill $(ps -ef | grep "kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME" | awk '{print $2}' | head -n 1)

                exit 0;
            
            else

                echo "Failed to detect PostgreSQL database at your Kubernetes which created by HollaEx CLI."
                echo "If you setup PostgreSQL database in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_dependencies;

            if command docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-db > /dev/null 2>&1; then

                echo "Successfully detected the PostgreSQL DB created by HollaEx CLI."

                echo "Opening postgresql-client shell..."
                export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
                export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
                export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
                export PGHOST=localhost

                psql 

                exit 0;

            else

                echo "Failed to detect PostgreSQL database at your machine which created by HollaEx CLI."
                echo "If you setup PostgreSQL database in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        fi

    elif [[ "$CONNECT_REDIS" ]]; then

        if ! command rdcli --version > /dev/null 2>&1; then

            printf "\033[91mHollaEx CLI failed to detect redis-cli at your computer.\033[39m\n"
            echo "Please install it first, before proceeding."
            exit 1;
        
        fi

        if [[ "$USE_KUBERNETES" ]]; then 

            check_kubernetes_dependencies;

            if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1 && command kubectl get pods -n $ENVIRONMENT_EXCHANGE_NAME -l app=$ENVIRONMENT_EXCHANGE_NAME-redis > /dev/null 2>&1; then

                echo "Successfully detected the Redis created by HollaEx CLI."
                echo "Opening kube-proxy tunnel for Redis connection..."

                kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-redis" -o name | sed 's/pod\///' | head -n 1) 6379:6379 &
                sleep 5;
                
                echo "Opening local proxy on 6379 port of your machine..."
                export REDISCLI_AUTH=$HOLLAEX_SECRET_REDIS_PASSWORD

                echo "Opening redis-client shell..."
                redis-cli 

                echo "Killing the opened proxy tunnel..."
                kill $(ps -ef | grep "kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME" | awk '{print $2}' | head -n 1)

                exit 0;
            
            else

                echo "Failed to detect Redis at your Kubernetes which created by HollaEx CLI."
                echo "If you setup Redis in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_dependencies;

            if command docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-redis > /dev/null 2>&1; then

                echo "Successfully detected the Redis created by HollaEx CLI."

                echo "Opening redis-cli shell..."
                export REDISCLI_AUTH=$HOLLAEX_SECRET_REDIS_PASSWORD

                redis-cli 

                exit 0;

            else

                echo "Failed to detect Redis at your machine which created by HollaEx CLI."
                echo "If you setup Redis in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        fi
    
    elif [[ "$INSTALL_CLI_ENABLE" ]]; then

        if [[ ! "$INSTALL_CLI_TARGET" ]]; then

            echo "Error: You must specify version of the CLI to downgrade."
            echo "eg. 'hollaex toolbox --install_cli 1.8.5'."

            exit 1;

        fi

        echo "Are you sure you want to install HollaEx CLI v$INSTALL_CLI_TARGET? (y/N)"
        read answer

        if [[ "$answer" = "${answer#[Yy]}" ]]; then
            echo "Exiting..."
            exit 0;
        fi
 
        bash $SCRIPTPATH/install.sh $INSTALL_CLI_TARGET

    elif [[ "$RESET_HMAC_TOKEN" ]]; then

        for i in ${CONFIG_FILE_PATH[@]}; do
            source $i
        done;

        load_config_variables;

        for i in ${CONFIG_FILE_PATH[@]}; do

            if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

                export SECRET_FILE_PATH=$i

            fi

        done

        echo -e "\033[91m\nWarning: Running this command will REVOKE your existing token without any additional confirmation!\033[39m\n"

        if [[ ! "$RUN_WITH_VERIFY" == false ]]; then 

            echo "Are you sure you reset (get) the HMAC token for your exchange? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]]; then
                echo "Exiting..."
                exit 0;
            fi

            unset answer
        
        fi 

        if [[ -f "$HOLLAEX_CLI_INIT_PATH/.token" ]]; then

            export BITHOLLA_ACCOUNT_TOKEN=$(cat $HOLLAEX_CLI_INIT_PATH/.token)

        else 

            printf "\033[91mError: An access token has not been detected.\033[39m\n"
            printf "Please login with your HollaEx account to issue an access token.\n\n"
            
            if ! command hollaex login --renew; then 

                exit 1;
            fi


        fi

        get_hmac_token;

        echo "To apply the new HMAC Token on your exchange, please run 'hollaex toolbox --set_activation_code (--kube)."
        echo "Please make sure that it's all good to rollback the security settings to the default, before proceeding."

    elif [[ "$ENABLE_MAINTENANCE_MODE" ]]; then

        if [[ ! "$HOLLAEX_MAINTENANCE_MODE_WHITELIST_IP" ]]; then 

            echo "Error: There is not whitelist IP defined for the maintenance mode."
            echo "Please pass the list of IPs you want to set as a whitelist while the maintenance mode is enabled."
            echo "Example: 'hollaex toolbox --enable_maintenance_mode --whitelist-ip 1.2.3.4,5.6.7.8'"

            exit 1;
        
        fi 

        if [[ "$USE_KUBERNETES" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo -e "\nWarning: Enabling the maintenance mode would block the requests coming from non-whitelisted IPs."
                echo "Are you sure you want to enable the maintenance mode? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_INGRESS_ENABLE" == true ]]; then

                echo "Generating Kubernetes Ingress"
                generate_kubernetes_ingress;

                echo "Generating Kubernetes Ingress for Web"
                generate_kubernetes_ingress_for_web;

            fi

            if command cat $TEMPLATE_GENERATE_PATH/kubernetes/config/${ENVIRONMENT_EXCHANGE_NAME}-ingress.yaml | grep whitelist-source-range > /dev/null 2>&1; then 

                if command sed -i.bak "s/\#nginx.ingress.kubernetes.io\/whitelist-source-range.*/nginx.ingress.kubernetes.io\/whitelist-source-range\: \"$HOLLAEX_MAINTENANCE_MODE_WHITELIST_IP\"/" $TEMPLATE_GENERATE_PATH/kubernetes/config/${ENVIRONMENT_EXCHANGE_NAME}-ingress.yaml; then
                    
                    sed -i.bak "s/\#error_page 403 @maintenance_503;/error_page 403 @maintenance_503;/" $TEMPLATE_GENERATE_PATH/kubernetes/config/${ENVIRONMENT_EXCHANGE_NAME}-ingress.yaml

                    rm $TEMPLATE_GENERATE_PATH/kubernetes/config/${ENVIRONMENT_EXCHANGE_NAME}-ingress.yaml.bak

                    kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/${ENVIRONMENT_EXCHANGE_NAME}-ingress.yaml

                fi

                if command sed -i.bak "s/\#nginx.ingress.kubernetes.io\/whitelist-source-range.*/nginx.ingress.kubernetes.io\/whitelist-source-range\: \"\"/" $TEMPLATE_GENERATE_PATH/kubernetes/config/${ENVIRONMENT_EXCHANGE_NAME}-ingress-web.yaml; then

                    sed -i.bak "s/\#error_page 403 @maintenance_503;/error_page 403 @maintenance_503;/" $TEMPLATE_GENERATE_PATH/kubernetes/config/${ENVIRONMENT_EXCHANGE_NAME}-ingress-web.yaml

                    rm $TEMPLATE_GENERATE_PATH/kubernetes/config/${ENVIRONMENT_EXCHANGE_NAME}-ingress-web.yaml.bak
                    
                    kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/${ENVIRONMENT_EXCHANGE_NAME}-ingress-web.yaml

                fi

            else 

                echo "Error: Cannot found 'whitelist-source-range' annotation in your Ingress file."
                echo "If you are using a custom Ingress template, please make sure you to set '#nginx.ingress.kubernetes.io/whitelist-source-range: ""' annoation first."

                exit 1;
            
            fi 
        
        else 

            echo "Error: The maintenance mode only works for Kubernetes environment at the moment."
            echo "Please add '--kube' flag behind of the command."

            exit 1;


        fi 


        echo -e "\nMaintenance mode is enabled!\n"
        echo -e "Requests from non-whitelisted IPs will get HTTP 503 Service Unavailable code."
        echo -e "Whitelisted IPs: $HOLLAEX_MAINTENANCE_MODE_WHITELIST_IP\n"

        echo -e "To disable the maintenance mode, run 'hollaex toolbox --disable_maintenance_mode (--kube).\n"
    
     elif [[ "$GET_SEO_HTML" ]]; then

        echo "Attempting to download the custom SEO settings from HollaEx Dashboard..."

        hollaex_login_token_validate_and_issue;

        HOLLAEX_CLOUD_GET_EXCHANGE_INFO_REQUEST=$(curl -s -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN"\
          --request GET \
          $hollaexAPIURL/v2/exchange)

        HOLLAEX_CLOUD_GET_EXCHANGE_NAME_LIST=$(echo $HOLLAEX_CLOUD_GET_EXCHANGE_INFO_REQUEST | jq -r '.data[].name')

        j=0
        for i in ${HOLLAEX_CLOUD_GET_EXCHANGE_NAME_LIST[@]}; do 

            if [[ "$i" == "$HOLLAEX_CONFIGMAP_API_NAME" ]]; then

                EXCHANGE_ARRAY_ORDER=$j

            fi

            ((j++))

        done

        HOLLAEX_CLOUD_EXCHANGE_ID=$(echo $HOLLAEX_CLOUD_GET_EXCHANGE_INFO_REQUEST | jq -r ".data[$EXCHANGE_ARRAY_ORDER].id")

        HOLLAEX_CLOUD_SEO_HTML_REQUEST=$(curl -s -w "&%{http_code}" \
        -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN" \
        --request GET \
        $hollaexAPIURL/v2/exchange/html?exchange_id=$HOLLAEX_CLOUD_EXCHANGE_ID) 

        HOLLAEX_CLOUD_SEO_HTML=$(echo $HOLLAEX_CLOUD_SEO_HTML_REQUEST | cut -f1 -d "&")
        HOLLAEX_CLOUD_SEO_HTML_CODE=$(echo $HOLLAEX_CLOUD_SEO_HTML_REQUEST | cut -f2 -d "&")

        if [[ "$HOLLAEX_CLOUD_SEO_HTML_CODE" == "200" ]]; then 
            
            echo -e "\n\033[92mSuccessfully downloaded and saved the custom SEO settings.\033[39m"

            curl -s -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN" \
            --request GET \
            $hollaexAPIURL/v2/exchange/html?exchange_id=$HOLLAEX_CLOUD_EXCHANGE_ID > $HOLLAEX_CLI_INIT_PATH/web/public/index.html

        else 

            echo -e "\033[91m\nError: Failed to download the custom SEO settings.\033[39m"
            exit 1;

        fi 

    elif [[ "$DISABLE_MAINTENANCE_MODE" ]]; then

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo -e "\nWarning: Disabling the maintenance mode would allow the requests coming from non-whitelisted IPs."
            echo "Are you sure you want to disable the maintenance mode? (Y/n)"

            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi


        if [[ "$USE_KUBERNETES" ]]; then

            if command cat $TEMPLATE_GENERATE_PATH/kubernetes/config/${ENVIRONMENT_EXCHANGE_NAME}-ingress.yaml | grep whitelist-source-range > /dev/null 2>&1; then 

                if command sed -i.bak "s/nginx.ingress.kubernetes.io\/whitelist-source-range.*/\#nginx.ingress.kubernetes.io\/whitelist-source-range\: \"\"/" $TEMPLATE_GENERATE_PATH/kubernetes/config/${ENVIRONMENT_EXCHANGE_NAME}-ingress.yaml; then

                    sed -i.bak "s/error_page 403 @maintenance_503;/\#error_page 403 @maintenance_503;/" $TEMPLATE_GENERATE_PATH/kubernetes/config/${ENVIRONMENT_EXCHANGE_NAME}-ingress.yaml

                    rm $TEMPLATE_GENERATE_PATH/kubernetes/config/${ENVIRONMENT_EXCHANGE_NAME}-ingress.yaml.bak
                    
                    kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/${ENVIRONMENT_EXCHANGE_NAME}-ingress.yaml

                fi

                if command sed -i.bak "s/nginx.ingress.kubernetes.io\/whitelist-source-range.*/\#nginx.ingress.kubernetes.io\/whitelist-source-range\: \"\"/" $TEMPLATE_GENERATE_PATH/kubernetes/config/${ENVIRONMENT_EXCHANGE_NAME}-ingress-web.yaml; then

                    sed -i.bak "s/error_page 403 @maintenance_503;/\#error_page 403 @maintenance_503;/" $TEMPLATE_GENERATE_PATH/kubernetes/config/${ENVIRONMENT_EXCHANGE_NAME}-ingress-web.yaml

                    rm $TEMPLATE_GENERATE_PATH/kubernetes/config/${ENVIRONMENT_EXCHANGE_NAME}-ingress-web.yaml.bak
                    
                    kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/${ENVIRONMENT_EXCHANGE_NAME}-ingress-web.yaml

                fi

            else 

                echo "Error: Cannot found 'whitelist-source-range' annotation in your Ingress file."
                echo "If you are using a custom Ingress template, please make sure you to set '#nginx.ingress.kubernetes.io/whitelist-source-range: ""' annoation first."

                exit 1;
            
            fi


        else 

            echo "Error: The maintenance mode only works for Kubernetes environment atm."
            echo "Please add '--kube' flag behind of the command."

            exit 1;

        fi

        echo -e "\nMaintenance mode is disabled!\n"
        echo -e "Requests from all IPs will be allowed with no restriction."

        echo -e "To enable the maintenance mode, run 'hollaex toolbox --disable_maintenance_mode --whitelist-ip <MY_IP> (--kube).\n"

    fi

elif [[ "$1" == "cloud" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kit_repo)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLOUD_CUSTOM_KIT_REPO="${1:-https://github.com/bitholla/hollaex-kit.git}"
                echo "Your Custom HollaEx Kit Git Repository : $HOLLAEX_CLOUD_CUSTOM_KIT_REPO."
                shift; continue
                ;;
            --kit_branch)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLOUD_CUSTOM_KIT_BRANCH="${1:-master}"
                echo "Your Custom HollaEx Kit Git Branch : $HOLLAEX_CLOUD_CUSTOM_KIT_BRANCH."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --start)
                HOLLAEX_CLOUD_INPUT=true
                HOLLAEX_CLOUD_START=true
                shift; continue
                ;;
            --stop)
                HOLLAEX_CLOUD_INPUT=true
                HOLLAEX_CLOUD_STOP=true
                shift; continue
                ;;
            --restart)
                HOLLAEX_CLOUD_INPUT=true
                HOLLAEX_CLOUD_RESTART=true
                shift; continue
                ;;
            --upgrade)
                HOLLAEX_CLOUD_INPUT=true
                HOLLAEX_CLOUD_UPGRADE=true
                shift; continue
                ;;
            --terminate)
                HOLLAEX_CLOUD_INPUT=true
                HOLLAEX_CLOUD_TERMINATE=true
                shift; continue
                ;;
            # Build related
            --user_image_registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE=$1
                echo "Target hollaex docker registry : $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! "$USE_KUBERNETES" ]]; then

         if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi
    
    elif [[ "$USE_KUBERNETES" ]]; then

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

    fi

    if [[ ! "$HOLLAEX_CLOUD_INPUT" ]]; then 

        print_usage

        echo -e "\033[91mError: You haven't specified any action for the 'hollaex cloud' command.\033[39m"
        echo -e "Please check the command list above and try it again.\n"

        exit 1;

    fi 
    
    hollaex_login_token_validate_and_issue;

    # # # FIGURE OUT THE EXCHANGE ID # # #
    HOLLAEX_CLOUD_GET_EXCHANGE_INFO_REQUEST=$(curl -s -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN"\
          --request GET \
          $hollaexAPIURL/v2/exchange)

    HOLLAEX_CLOUD_GET_EXCHANGE_NAME_LIST=$(echo $HOLLAEX_CLOUD_GET_EXCHANGE_INFO_REQUEST | jq -r '.data[].name')

    j=0
    for i in ${HOLLAEX_CLOUD_GET_EXCHANGE_NAME_LIST[@]}; do 

        if [[ "$i" == "$HOLLAEX_CONFIGMAP_API_NAME" ]]; then

            EXCHANGE_ARRAY_ORDER=$j

        fi

        ((j++))

    done

    HOLLAEX_CLOUD_EXCHANGE_ID=$(echo $HOLLAEX_CLOUD_GET_EXCHANGE_INFO_REQUEST | jq -r ".data[$EXCHANGE_ARRAY_ORDER].id")
    
    # # # END # # # 

    hollaex pull --skip

    if [[ "$HOLLAEX_CLOUD_START" ]]; then 

        echo -e "\nSending a request to start the stopped exchange on the HollaCloud..."

        # HOLLAEX_CLOUD_START_API_REQUEST=$(curl -s -o /dev/null -w "%{http_code}" -H "Content-Type: application/json" \
        # -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN" \
        # --request POST \
        # --data "{\"exchange_id\": ${HOLLAEX_CLOUD_EXCHANGE_ID}, \"command\": \"start\", \"data\": { \"exchange_name\": \"$HOLLAEX_CONFIGMAP_API_NAME\", \"agent\": \"CLI v$(cat $SCRIPTPATH/version)\" }}" \
        # $hollaexAPIURL/v2/exchange/cloud) 

        HOLLAEX_CLOUD_START_API_REQUEST=$(curl -s -w "&%{http_code}" -H "Content-Type: application/json" \
        -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN" \
        --request POST \
        --data "{\"exchange_id\": ${HOLLAEX_CLOUD_EXCHANGE_ID}, \"command\": \"start\", \"data\": { \"exchange_name\": \"$HOLLAEX_CONFIGMAP_API_NAME\", \"agent\": \"CLI v$(cat $SCRIPTPATH/version)\" }}" \
        $hollaexAPIURL/v2/exchange/cloud) 

        HOLLAEX_CLOUD_START_API_REQUEST_RESPONSE_PARSE=$(echo $HOLLAEX_CLOUD_START_API_REQUEST | cut -f1 -d "&" | jq -r '.message')
        HOLLAEX_CLOUD_START_API_REQUEST_HTTP_CODE=$(echo $HOLLAEX_CLOUD_START_API_REQUEST | cut -f2 -d "&")

        
        if [[ "$HOLLAEX_CLOUD_START_API_REQUEST_HTTP_CODE" == "200" ]]; then 

            echo -e "\n\033[92mSuccessfully sent the request to the HollaCloud to start your exchange.\033[39m\n"
            echo "The job would take around 10~20 minutes."
            echo -e "We will inform you through the email once it's done!\n"

            exit 0;
        
        else 
            
            echo -e "\n\033[91mFailed to send the request to the server.\033[39m"
            echo -e "$HOLLAEX_CLOUD_START_API_REQUEST_RESPONSE_PARSE\n"
            echo -e "Please review the logs, and try it again.\n"

            exit 1;

        fi

    elif [[ "$HOLLAEX_CLOUD_STOP" ]]; then 

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to stop the $HOLLAEX_CONFIGMAP_API_NAME on the HollaCloud? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo -e "\nSending a request to stop the running exchange on the HollaCloud..."

        HOLLAEX_CLOUD_STOP_API_REQUEST=$(curl -s -w "&%{http_code}" -H "Content-Type: application/json" \
        -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN" \
        --request POST \
        --data "{\"exchange_id\": ${HOLLAEX_CLOUD_EXCHANGE_ID}, \"command\": \"stop\", \"data\": { \"exchange_name\": \"$HOLLAEX_CONFIGMAP_API_NAME\", \"agent\": \"CLI v$(cat $SCRIPTPATH/version)\" }}" \
        $hollaexAPIURL/v2/exchange/cloud) 

        HOLLAEX_CLOUD_STOP_API_REQUEST_RESPONSE_PARSE=$(echo $HOLLAEX_CLOUD_STOP_API_REQUEST | cut -f1 -d "&" | jq -r '.message')
        HOLLAEX_CLOUD_STOP_API_REQUEST_HTTP_CODE=$(echo $HOLLAEX_CLOUD_STOP_API_REQUEST | cut -f2 -d "&")
        
        if [[ "$HOLLAEX_CLOUD_STOP_API_REQUEST_HTTP_CODE" == "200" ]]; then

            echo -e "\n\033[92mSuccessfully sent the request to the HollaCloud to stop your exchange.\033[39m\n"
            echo "The job would take around 10 ~ 20 minutes."
            echo -e "We will inform you through the email once it's done!\n"

            exit 0;
        
        else 

            echo -e "\n\033[91mFailed to send the request to the server.\033[39m"
            echo -e "$HOLLAEX_CLOUD_STOP_API_REQUEST_RESPONSE_PARSE\n"
            echo "Please review the logs, and try it again."

            exit 1;

        fi
    
    elif [[ "$HOLLAEX_CLOUD_RESTART" ]]; then 

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to restart the $HOLLAEX_CONFIGMAP_API_NAME on the HollaCloud? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo -e "\nSending a request to restart the running exchange on the HollaCloud..."

        HOLLAEX_CLOUD_RESTART_API_REQUEST=$(curl -s -w "&%{http_code}" -H "Content-Type: application/json" \
        -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN" \
        --request POST \
        --data "{\"exchange_id\": ${HOLLAEX_CLOUD_EXCHANGE_ID}, \"command\": \"restart\", \"data\": { \"exchange_name\": \"$HOLLAEX_CONFIGMAP_API_NAME\", \"agent\": \"CLI v$(cat $SCRIPTPATH/version)\" }}" \
        $hollaexAPIURL/v2/exchange/cloud) 

        HOLLAEX_CLOUD_RESTART_API_REQUEST_RESPONSE_PARSE=$(echo $HOLLAEX_CLOUD_RESTART_API_REQUEST | cut -f1 -d "&" | jq -r '.message')
        HOLLAEX_CLOUD_RESTART_API_REQUEST_HTTP_CODE=$(echo $HOLLAEX_CLOUD_RESTART_API_REQUEST | cut -f2 -d "&")
        
        if [[ "$HOLLAEX_CLOUD_RESTART_API_REQUEST_HTTP_CODE" == "200" ]]; then 

            echo -e "\n\033[92mSuccessfully sent the request to the HollaCloud to restart your exchange.\033[39m\n"
            echo "The job would take around 10~20 minutes."
            echo -e "We will inform you through the email once it's done!\n"

            exit 0;
        
        else 

            echo -e "\n\033[91mFailed to send the request to the server.\033[39m"
            echo -e "$HOLLAEX_CLOUD_RESTART_API_REQUEST_RESPONSE_PARSE\n"
            echo "Please review the logs, and try it again."

            exit 1;

        fi

    elif [[ "$HOLLAEX_CLOUD_UPGRADE" ]]; then 

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Warning: The upgrade would cause a downtime on your exchange."
            echo "Are you sure you want to upgrade the $HOLLAEX_CONFIGMAP_API_NAME on the HollaCloud? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo -e "\nSending a request to upgrade the running exchange on the HollaCloud..."

        echo -e "\n# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"
        echo "Your HollaEx Kit Git repository: ${HOLLAEX_CLOUD_CUSTOM_KIT_REPO:-'https://github.com/bitholla/hollaex-kit.git'}"
        echo "Your HollaEx Kit Git branch: ${HOLLAEX_CLOUD_CUSTOM_KIT_BRANCH:-'master'}"
        echo -e "# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"

        HOLLAEX_CLOUD_UPGRADE_API_REQUEST=$(curl -s -w "&%{http_code}" -H "Content-Type: application/json" \
        -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN" \
        --request POST \
        --data "{\"exchange_id\": ${HOLLAEX_CLOUD_EXCHANGE_ID}, \"command\": \"upgrade\", \"data\": { \"kit_repo\": \"$HOLLAEX_CLOUD_CUSTOM_KIT_REPO\", \"kit_branch\": \"$HOLLAEX_CLOUD_CUSTOM_KIT_BRANCH\", \"exchange_name\": \"$HOLLAEX_CONFIGMAP_API_NAME\", \"agent\": \"CLI v$(cat $SCRIPTPATH/version)\"}}" \
        $hollaexAPIURL/v2/exchange/cloud) 

        HOLLAEX_CLOUD_UPGRADE_API_REQUEST_RESPONSE_PARSE=$(echo $HOLLAEX_CLOUD_UPGRADE_API_REQUEST | cut -f1 -d "&" | jq -r '.message')
        HOLLAEX_CLOUD_UPGRADE_API_REQUEST_HTTP_CODE=$(echo $HOLLAEX_CLOUD_UPGRADE_API_REQUEST | cut -f2 -d "&")
        
        if [[ "$HOLLAEX_CLOUD_UPGRADE_API_REQUEST_HTTP_CODE" == "200" ]]; then 

            echo -e "\n\033[92mSuccessfully sent the request to the HollaCloud to stop your exchange.\033[39m\n"
            echo "The job would take around 20~30 minutes."
            echo -e "We will inform you through the email once it's done!\n"

            exit 0;
        
        else 

            echo -e "\n\033[91mFailed to send the request to the server.\033[39m"
            echo -e "$HOLLAEX_CLOUD_UPGRADE_API_REQUEST_RESPONSE_PARSE\n"
            echo "Please review the logs, and try it again."

            exit 1;

        fi

    elif [[ "$HOLLAEX_CLOUD_TERMINATE" ]]; then 

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Warning: The termination could not be undo."
            echo "Are you sure you want to TERMINATE the $HOLLAEX_CONFIGMAP_API_NAME on the HollaCloud? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo -e "\nSending a request to TERMINATE the running exchange on the HollaCloud..."
        echo "Warning: This can't be undo."

        HOLLAEX_CLOUD_TERMINATE_API_REQUEST=$(curl -s -w "&%{http_code}" -H "Content-Type: application/json" \
        -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN" \
        --request POST \
        --data "{\"exchange_id\": ${HOLLAEX_CLOUD_EXCHANGE_ID}, \"command\": \"terminate\", \"data\": { \"exchange_name\": \"$HOLLAEX_CONFIGMAP_API_NAME\", \"agent\": \"CLI v$(cat $SCRIPTPATH/version)\" }}" \
        $hollaexAPIURL/v2/exchange/cloud) 

        HOLLAEX_CLOUD_TERMINATE_API_REQUEST_RESPONSE_PARSE=$(echo $HOLLAEX_CLOUD_TERMINATE_API_REQUEST | cut -f1 -d "&" | jq -r '.message')
        HOLLAEX_CLOUD_TERMINATE_API_REQUEST_HTTP_CODE=$(echo $HOLLAEX_CLOUD_TERMINATE_API_REQUEST | cut -f2 -d "&")
        
        if [[ "$HOLLAEX_CLOUD_TERMINATE_API_REQUEST_HTTP_CODE" == "200" ]]; then 

            echo -e "\n\033[92mSuccessfully sent the request to the HollaCloud to terminate your exchange.\033[39m\n"
            echo "The job would take around 20~30 minutes."
            echo -e "We will inform you through the email once it's done!\n"

            exit 0;
        
        else 

            echo -e "\n\033[91mFailed to send the request to the server.\033[39m"
            echo -e "$HOLLAEX_CLOUD_TERMINATE_API_REQUEST_RESPONSE_PARSE\n"
            echo -e "Please review the logs, and try it again.\n"

            exit 1;

        fi

    fi

    exit 0;
    

elif [[ "$1" == "status" ]]; then

     while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
     done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    
    
    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        kubectl get pods --namespace $ENVIRONMENT_EXCHANGE_NAME

    fi
    
    if [[ ! "$USE_KUBERNETES" ]]; then

        if [[ -z $(docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME) ]]; then

            printf "\033[91m\nFailed to detect HollaEx on this machine. Please try it again.\033[39m\n"

        else 

            docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME

        fi

    fi

    printf "\nCalling the exchange health page ($HOLLAEX_CONFIGMAP_API_HOST/v2/health) ...\n"

    if command curl -s $HOLLAEX_CONFIGMAP_API_HOST/v2/health | grep $ENVIRONMENT_EXCHANGE_NAME; then 

        printf "\n\033[92mSuccessfully reached to the health page.\033[39m\n"

    else 

        printf "\033[91m\nThe health page is not responding. Please check the exchange is up.\033[39m\n"
        echo -e "\nIf you just started the server, it could take a minute for the server to get fully ready."
        echo -e "Please try it again after few minutes.\n"
        curl -s $HOLLAEX_CONFIGMAP_API_HOST/v2/health

    fi

    exit 0;

elif [[ "$1" == "logs" ]]; then

     while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --target)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_LOGS_TARGET=$1
                echo "Displaying Logs from $1..."
                shift; continue
                ;;
            # --lines and --line does same thing.
            --lines)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_LOGS_TARGET_LINE=$1
                shift; continue
                ;;
            --line)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_LOGS_TARGET_LINE=$1
                shift; continue
                ;;
           --export)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                echo "Exporting the result as a file."
                HOLLAEX_LOGS_EXPORT=true
                HOLLAEX_LOGS_EXPORT_PATH=$1
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
     done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    
    
    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    function hollaex_log_target_whitelist() {

        local whitelist=("api" "stream" "db" "redis")

        if ! command printf '%s\n' ${whitelist[@]} | grep $HOLLAEX_LOGS_TARGET > /dev/null; then
        
            printf "\033[91mError: Invalid target $HOLLAEX_LOGS_TARGET.\033[39m\n"
            echo "Command 'hollaex logs' only supports '${whitelist[@]}' as log target."
            echo "Pleases try it again."

            exit 1;

        fi
    }
    
    if [[ "$HOLLAEX_LOGS_TARGET" ]]; then

        hollaex_log_target_whitelist;
    
    fi

    if [[ -d "$HOLLAEX_LOGS_EXPORT_PATH" ]]; then

        export HOLLAEX_LOGS_EXPORT_PATH="${HOLLAEX_LOGS_EXPORT_PATH}/hollaex-logs-$(date +%s).log"

    fi

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        function show_kubernetes_logs_simple() {

            hollaex version

            # Printing general system information
            echo "Client System OS Type: $OSTYPE"
            echo "Client System Shell Type: $SHELL"
            echo "Client System Shell Version: $(${SHELL} --version)"

            printf "\nKubernetes Version: $(kubectl version)\n\n"
            echo "Helm Version: $(helm version)"

            printf "\n#########################################################################\n"

            if [[ "$HOLLAEX_LOGS_TARGET" ]]; then

                local POD_ID=$(kubectl get pods --namespace $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME | grep $HOLLAEX_LOGS_TARGET | cut -f1 -d " ")

            else 
                
                local POD_ID=$(kubectl get pods --namespace $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME | cut -f1 -d " ")
            
            fi

            for i in ${POD_ID[@]}; do

                printf "\nPod : $i\n"

                    if [[ $(kubectl logs $i --namespace $ENVIRONMENT_EXCHANGE_NAME --tail 10) ]]; then

                            kubectl logs $i --namespace $ENVIRONMENT_EXCHANGE_NAME --tail ${HOLLAEX_LOGS_TARGET_LINE:-100}

                    else 

                        echo "There are no logs for Pod : $i."

                    fi

                printf "\n"

            done;
        
        }

        if [[ "$HOLLAEX_LOGS_EXPORT" == true ]]; then

            show_kubernetes_logs_simple &> "${HOLLAEX_LOGS_EXPORT_PATH}"

        else 

            show_kubernetes_logs_simple
        
        fi


        printf "\n"
        echo "Displayed (Saved) last ${HOLLAEX_LOGS_TARGET_LINE:-100} lines of logs from pod(s)."

        if [[ ! "$HOLLAEX_LOGS_TARGET" ]]; then
            
            echo "To see logs from specific pod(s), Please run 'hollaex logs --kube --target <NAME_OF_COMPONENT> --lines <LINES_OF_LOGS>'."
            echo "For example, 'hollaex logs --kube --target api --lines 20'."
        
        fi

        if [[ "$HOLLAEX_LOGS_EXPORT" == true ]]; then

            printf "\nYou can find the exported logs file at ${HOLLAEX_LOGS_EXPORT_PATH}.\n"
            exit 0;

        fi

    fi
    
    if [[ ! "$USE_KUBERNETES" ]]; then

        if [[ -z $(docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME) ]]; then

            printf "\033[91m\nFailed to detect $ENVIRONMENT_EXCHANGE_NAME on this machine. Please try it again.\033[39m\n"

        else 

            function show_docker_logs_simple() {

                hollaex version

                # Printing general system information
                echo "System OS Type: $OSTYPE"
                echo "System Shell Type: $SHELL"
                echo "System Shell Version: $(${SHELL} --version)"

                printf "\n#########################################################################\n"

                if [[ "$HOLLAEX_LOGS_TARGET" ]]; then

                    local CONTAINER_ID=$(docker ps -a --format "{{.Names}}" | grep $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME-.*-$HOLLAEX_LOGS_TARGET)
                    echo $CONTAINER_ID

                else 
                
                    local CONTAINER_ID=$(docker ps -a --format "{{.Names}}" | grep $ENVIRONMENT_EXCHANGE_NAME)

                fi

                for i in ${CONTAINER_ID[@]}; do

                    printf "\nContainer : $i\n"

                    if [[ $(docker logs $i --tail 10) ]]; then

                            docker logs $i --tail ${HOLLAEX_LOGS_TARGET_LINE:-100} 

                    else 

                        echo "There are no logs for container : $i."

                    fi

                    printf "\n"

                done;
            
            }

            if [[ "$HOLLAEX_LOGS_EXPORT" == true ]]; then

                show_docker_logs_simple &> "${HOLLAEX_LOGS_EXPORT_PATH}"

            else 

                show_docker_logs_simple
            
            fi

            printf "\n"
            echo "Displayed (Exported) last ${HOLLAEX_LOGS_TARGET_LINE:-100} lines of logs from container(s)."

            if [[ ! "$HOLLAEX_LOGS_TARGET" ]]; then

                echo "To see logs from specific container(s), Please run 'hollaex logs --target <NAME_OF_COMPONENT> --lines <LINES_OF_LOGS>'."
                echo "For example, 'hollaex logs --target api --lines 20'."
            
            fi

            if [[ "$HOLLAEX_LOGS_EXPORT" == true ]]; then

                printf "\nYou can find the exported logs file at ${HOLLAEX_LOGS_EXPORT_PATH}.\n"
                exit 0;

            fi

        fi

    fi

    exit 0;

elif [[ "$1" == "mode" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --testnet)
                echo "Updating the CLI mode to testnet..."
                HOLLAEX_UPDATE_MODE=testnet
                shift; continue
                ;;
            --mainnet)
                echo "Updating the CLI mode to mainnet..."
                HOLLAEX_UPDATE_MODE=mainnet
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
     done

    # Get the configmap file path.

    CONFIG_FILE_PATH=$(pwd)/settings/*

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "ENVIRONMENT_EXCHANGE_NAME=" $i > /dev/null ; then
            
            export CONFIGMAP_FILE_PATH=$i

        fi

    done

    if [[ "$HOLLAEX_UPDATE_MODE" == "testnet" ]]; then 

        echo "ENVIRONMENT_HOLLAEX_KIT_NETWORK=testnet" > $(pwd)/.hollaex
        sed -i.bak "s/HOLLAEX_CONFIGMAP_NETWORK=.*/HOLLAEX_CONFIGMAP_NETWORK=testnet/" $CONFIGMAP_FILE_PATH
        rm $CONFIGMAP_FILE_PATH.bak

    
    elif [[ "$HOLLAEX_UPDATE_MODE" == "mainnet" ]]; then 

        echo "ENVIRONMENT_HOLLAEX_KIT_NETWORK=mainnet" > $(pwd)/.hollaex
        sed -i.bak "s/HOLLAEX_CONFIGMAP_NETWORK=.*/HOLLAEX_CONFIGMAP_NETWORK=mainnet/" $CONFIGMAP_FILE_PATH
        rm $CONFIGMAP_FILE_PATH.bak
    
    else 
    
        echo -e "\nError: Mode selector has not been defined."
        echo -e "Plesae use either '--testnet' flag or '--mainnet' flag.\n"
        exit 1;

    fi 

    exit 0

elif [[ "$1" == "docs" ]]; then

    export HOLLAEX_DOCS_URL="https://docs.hollaex.com"

    if [[ "$OSTYPE" == *"darwin"* ]]; then 

        open $HOLLAEX_DOCS_URL
    
    else 

        if ! command xdg-open $HOLLAEX_DOCS_URL > /dev/null 2>&1; then

            echo "Error: Your system does not support xdg-open compatible browser."
            echo "Please open the website ($HOLLAEX_DOCS_URL) through your browser by yourself."

        fi

    fi

elif [[ "$1" == "forum" ]]; then

    export HOLLAEX_FORUM_URL="https://forum.hollaex.com"

    if [[ "$OSTYPE" == *"darwin"* ]]; then 

        open $HOLLAEX_FORUM_URL
    
    else 

        if ! command xdg-open $HOLLAEX_FORUM_URL > /dev/null 2>&1; then

            echo "Error: Your system does not support xdg-open compatible browser."
            echo "Please open the website ($HOLLAEX_FORUM_URL) through your browser by yourself."

        fi

    fi

elif [[ "$1" == "discord" ]]; then

    export HOLLAEX_DISCORD_URL="https://discord.gg/nu8DJUHjBR"

    if [[ "$OSTYPE" == *"darwin"* ]]; then 

        open $HOLLAEX_DISCORD_URL
    
    else 

        if ! command xdg-open $HOLLAEX_DISCORD_URL > /dev/null 2>&1; then

            echo "Error: Your system does not support xdg-open compatible browser."
            echo "Please open the website ($HOLLAEX_DISCORD_URL) through your browser by yourself."

        fi

    fi 

elif [[ "$1" == "bug" ]] || [[ "$1" == "bug-report" ]]; then

    export HOLLAEX_GITHUB_ISSUES_NEW_URL="https://github.com/bitholla/hollaex-kit/issues/new"

    if [[ "$OSTYPE" == *"darwin"* ]]; then 

        open $HOLLAEX_GITHUB_ISSUES_NEW_URL
    
    else

         if ! command xdg-open $HOLLAEX_GITHUB_ISSUES_NEW_URL > /dev/null 2>&1; then

            echo "Error: Your system does not support xdg-open compatible browser."
            echo "Please open the website ($HOLLAEX_GITHUB_ISSUES_NEW_URL) through your browser by yourself."

        fi

    fi 

elif [[ "$1" == "xht-market" ]]; then

    export HOLLAEX_TRADE_XHT_URL="https://pro.hollaex.com/trade/xht-usdt"

    if [[ "$OSTYPE" == *"darwin"* ]]; then 

        open $HOLLAEX_TRADE_XHT_URL
    
    else 

        if ! command xdg-open $HOLLAEX_TRADE_XHT_URL > /dev/null 2>&1; then

            echo "Error: Your system does not support xdg-open compatible browser."
            echo "Please open the website ($HOLLAEX_TRADE_XHT_URL) through your browser by yourself."

        fi

    fi

elif [[ "$1" == "trade" ]]; then

    source $(pwd)/settings/configmap

    if [[ "$HOLLAEX_CONFIGMAP_DOMAIN" == *"yourdomain.com"* ]]; then 

        export HOLLAEX_CONFIGMAP_DOMAIN="http://localhost:8080"

    fi

    if [[ "$OSTYPE" == *"darwin"* ]]; then 

        open $HOLLAEX_CONFIGMAP_DOMAIN
    
    else 

        if ! command xdg-open $HOLLAEX_CONFIGMAP_DOMAIN > /dev/null 2>&1; then

            echo "Error: Your system does not support xdg-open compatible browser."
            echo "Please open the website ($HOLLAEX_CONFIGMAP_DOMAIN) through your browser by yourself."

        fi 

    fi

elif [[ "$1" == "version" ]]; then

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
        
    source $SCRIPTPATH/tools_generator.sh
     
    /bin/cat << EOF

:tt1   ;tti          LCC:1CC1         ,11tffttt            :tt;  ;tfi.tt1 ,,,
t@@8   f@@0  ,;ii;.  8@@;L@@f .:i1i:. ;@@@CLCGC;ii; ,iii.  t@@L,C@@L,.CCf,0@@;,
t@@8LLf0@@G,C@@G0@8L.0@@;L@@t.C80L0@8i:@@8tt;  :8@@1G@@1.  t@@0@@8:  ,8888@@@8G
t@@8CCC0@@CC@@L  G@@fG@@;L@@t,fCCfG@@L:@@@LLi    C@@@8,    t@@@C8@0: ,@@G.G@@,
t@@8   L@@G1@@0;;8@@i0@@;L@@fC@@Li0@@f:@@@iii11:i8@G@@C,   t@@L :0@@1,@@0 G@@1;
iGGL   tGGf ;LG00Gf: CGG:tGG1:LGGCLCG1:GGG0000fiGGL 1GGf.  iCC1  .LGG1CGf :LG0G,


HollaEx CLI : v$(cat $SCRIPTPATH/version).
HollaEx Kit : $(if [[ -f "$INIT_PATH_CHECK" ]]; then 
    echo "v$(cat $HOLLAEX_CLI_INIT_PATH/version)."
else
    echo -e "\033[91mNot in the Kit directory.\033[39m"
fi)

Made with <3 by bitHolla Inc.

EOF

else

    printf "\nInvalid Command. Please try it again.\n"
    print_usage;

    exit 1;

fi

exit 0;